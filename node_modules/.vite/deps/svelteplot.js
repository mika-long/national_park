import {
  MediaQuery,
  SvelteMap
} from "./chunk-X3UXDTIA.js";
import {
  devicePixelRatio
} from "./chunk-H3FHOGSZ.js";
import "./chunk-BRH6YQ23.js";
import "./chunk-7RQDXF5S.js";
import "./chunk-2FA5TWU5.js";
import {
  add_locations,
  append_styles,
  attach,
  attribute_effect,
  bind_element_size,
  bind_this,
  check_target,
  cleanup_styles,
  clsx,
  component,
  createAttachmentKey,
  create_ownership_validator,
  each,
  element,
  hmr,
  html,
  if_block,
  index,
  key,
  legacy_api,
  log_if_contains_state,
  prop,
  rest_props,
  set_attribute,
  set_class,
  set_style,
  setup_stores,
  snippet,
  spread_props,
  store_get,
  validate_binding,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_snippet_args,
  validate_store,
  validate_void_dynamic_element,
  wrap_snippet,
  writable
} from "./chunk-PNRPTIB5.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  set_text,
  text
} from "./chunk-FD57FX2G.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  boundary,
  child,
  equals,
  exclude_from_object,
  fallback,
  first_child,
  get,
  getContext,
  hasContext,
  noop,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  sibling,
  state,
  strict_equals,
  tag,
  tag_proxy,
  template_effect,
  to_array,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-2ZDPGQTT.js";
import "./chunk-XWATFG4W.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-DZ7PW52E.js";
import "./chunk-OHYQYV5R.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/binary-search-bounds/search-bounds.js
var require_search_bounds = __commonJS({
  "node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
    "use strict";
    function ge(a2, y2, c4, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a2[m];
        var p = c4 !== void 0 ? c4(x2, y2) : x2 - y2;
        if (p >= 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function gt(a2, y2, c4, l, h) {
      var i = h + 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a2[m];
        var p = c4 !== void 0 ? c4(x2, y2) : x2 - y2;
        if (p > 0) {
          i = m;
          h = m - 1;
        } else {
          l = m + 1;
        }
      }
      return i;
    }
    function lt(a2, y2, c4, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a2[m];
        var p = c4 !== void 0 ? c4(x2, y2) : x2 - y2;
        if (p < 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function le(a2, y2, c4, l, h) {
      var i = l - 1;
      while (l <= h) {
        var m = l + h >>> 1, x2 = a2[m];
        var p = c4 !== void 0 ? c4(x2, y2) : x2 - y2;
        if (p <= 0) {
          i = m;
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return i;
    }
    function eq(a2, y2, c4, l, h) {
      while (l <= h) {
        var m = l + h >>> 1, x2 = a2[m];
        var p = c4 !== void 0 ? c4(x2, y2) : x2 - y2;
        if (p === 0) {
          return m;
        }
        if (p <= 0) {
          l = m + 1;
        } else {
          h = m - 1;
        }
      }
      return -1;
    }
    function norm(a2, y2, c4, l, h, f) {
      if (typeof c4 === "function") {
        return f(a2, y2, c4, l === void 0 ? 0 : l | 0, h === void 0 ? a2.length - 1 : h | 0);
      }
      return f(a2, y2, void 0, c4 === void 0 ? 0 : c4 | 0, l === void 0 ? a2.length - 1 : l | 0);
    }
    module.exports = {
      ge: function(a2, y2, c4, l, h) {
        return norm(a2, y2, c4, l, h, ge);
      },
      gt: function(a2, y2, c4, l, h) {
        return norm(a2, y2, c4, l, h, gt);
      },
      lt: function(a2, y2, c4, l, h) {
        return norm(a2, y2, c4, l, h, lt);
      },
      le: function(a2, y2, c4, l, h) {
        return norm(a2, y2, c4, l, h, le);
      },
      eq: function(a2, y2, c4, l, h) {
        return norm(a2, y2, c4, l, h, eq);
      }
    };
  }
});

// node_modules/interval-tree-1d/interval-tree.js
var require_interval_tree = __commonJS({
  "node_modules/interval-tree-1d/interval-tree.js"(exports, module) {
    "use strict";
    var bounds = require_search_bounds();
    var NOT_FOUND = 0;
    var SUCCESS = 1;
    var EMPTY = 2;
    module.exports = createWrapper;
    function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
      this.mid = mid;
      this.left = left;
      this.right = right;
      this.leftPoints = leftPoints;
      this.rightPoints = rightPoints;
      this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
    }
    var proto = IntervalTreeNode.prototype;
    function copy3(a2, b) {
      a2.mid = b.mid;
      a2.left = b.left;
      a2.right = b.right;
      a2.leftPoints = b.leftPoints;
      a2.rightPoints = b.rightPoints;
      a2.count = b.count;
    }
    function rebuild(node, intervals) {
      var ntree = createIntervalTree(intervals);
      node.mid = ntree.mid;
      node.left = ntree.left;
      node.right = ntree.right;
      node.leftPoints = ntree.leftPoints;
      node.rightPoints = ntree.rightPoints;
      node.count = ntree.count;
    }
    function rebuildWithInterval(node, interval2) {
      var intervals = node.intervals([]);
      intervals.push(interval2);
      rebuild(node, intervals);
    }
    function rebuildWithoutInterval(node, interval2) {
      var intervals = node.intervals([]);
      var idx = intervals.indexOf(interval2);
      if (idx < 0) {
        return NOT_FOUND;
      }
      intervals.splice(idx, 1);
      rebuild(node, intervals);
      return SUCCESS;
    }
    proto.intervals = function(result) {
      result.push.apply(result, this.leftPoints);
      if (this.left) {
        this.left.intervals(result);
      }
      if (this.right) {
        this.right.intervals(result);
      }
      return result;
    };
    proto.insert = function(interval2) {
      var weight = this.count - this.leftPoints.length;
      this.count += 1;
      if (interval2[1] < this.mid) {
        if (this.left) {
          if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval2);
          } else {
            this.left.insert(interval2);
          }
        } else {
          this.left = createIntervalTree([interval2]);
        }
      } else if (interval2[0] > this.mid) {
        if (this.right) {
          if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
            rebuildWithInterval(this, interval2);
          } else {
            this.right.insert(interval2);
          }
        } else {
          this.right = createIntervalTree([interval2]);
        }
      } else {
        var l = bounds.ge(this.leftPoints, interval2, compareBegin);
        var r = bounds.ge(this.rightPoints, interval2, compareEnd);
        this.leftPoints.splice(l, 0, interval2);
        this.rightPoints.splice(r, 0, interval2);
      }
    };
    proto.remove = function(interval2) {
      var weight = this.count - this.leftPoints;
      if (interval2[1] < this.mid) {
        if (!this.left) {
          return NOT_FOUND;
        }
        var rw = this.right ? this.right.count : 0;
        if (4 * rw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval2);
        }
        var r = this.left.remove(interval2);
        if (r === EMPTY) {
          this.left = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else if (interval2[0] > this.mid) {
        if (!this.right) {
          return NOT_FOUND;
        }
        var lw = this.left ? this.left.count : 0;
        if (4 * lw > 3 * (weight - 1)) {
          return rebuildWithoutInterval(this, interval2);
        }
        var r = this.right.remove(interval2);
        if (r === EMPTY) {
          this.right = null;
          this.count -= 1;
          return SUCCESS;
        } else if (r === SUCCESS) {
          this.count -= 1;
        }
        return r;
      } else {
        if (this.count === 1) {
          if (this.leftPoints[0] === interval2) {
            return EMPTY;
          } else {
            return NOT_FOUND;
          }
        }
        if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {
          if (this.left && this.right) {
            var p = this;
            var n = this.left;
            while (n.right) {
              p = n;
              n = n.right;
            }
            if (p === this) {
              n.right = this.right;
            } else {
              var l = this.left;
              var r = this.right;
              p.count -= n.count;
              p.right = n.left;
              n.left = l;
              n.right = r;
            }
            copy3(this, n);
            this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
          } else if (this.left) {
            copy3(this, this.left);
          } else {
            copy3(this, this.right);
          }
          return SUCCESS;
        }
        for (var l = bounds.ge(this.leftPoints, interval2, compareBegin); l < this.leftPoints.length; ++l) {
          if (this.leftPoints[l][0] !== interval2[0]) {
            break;
          }
          if (this.leftPoints[l] === interval2) {
            this.count -= 1;
            this.leftPoints.splice(l, 1);
            for (var r = bounds.ge(this.rightPoints, interval2, compareEnd); r < this.rightPoints.length; ++r) {
              if (this.rightPoints[r][1] !== interval2[1]) {
                break;
              } else if (this.rightPoints[r] === interval2) {
                this.rightPoints.splice(r, 1);
                return SUCCESS;
              }
            }
          }
        }
        return NOT_FOUND;
      }
    };
    function reportLeftRange(arr, hi, cb) {
      for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRightRange(arr, lo, cb) {
      for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    function reportRange(arr, cb) {
      for (var i = 0; i < arr.length; ++i) {
        var r = cb(arr[i]);
        if (r) {
          return r;
        }
      }
    }
    proto.queryPoint = function(x2, cb) {
      if (x2 < this.mid) {
        if (this.left) {
          var r = this.left.queryPoint(x2, cb);
          if (r) {
            return r;
          }
        }
        return reportLeftRange(this.leftPoints, x2, cb);
      } else if (x2 > this.mid) {
        if (this.right) {
          var r = this.right.queryPoint(x2, cb);
          if (r) {
            return r;
          }
        }
        return reportRightRange(this.rightPoints, x2, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    proto.queryInterval = function(lo, hi, cb) {
      if (lo < this.mid && this.left) {
        var r = this.left.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi > this.mid && this.right) {
        var r = this.right.queryInterval(lo, hi, cb);
        if (r) {
          return r;
        }
      }
      if (hi < this.mid) {
        return reportLeftRange(this.leftPoints, hi, cb);
      } else if (lo > this.mid) {
        return reportRightRange(this.rightPoints, lo, cb);
      } else {
        return reportRange(this.leftPoints, cb);
      }
    };
    function compareNumbers(a2, b) {
      return a2 - b;
    }
    function compareBegin(a2, b) {
      var d = a2[0] - b[0];
      if (d) {
        return d;
      }
      return a2[1] - b[1];
    }
    function compareEnd(a2, b) {
      var d = a2[1] - b[1];
      if (d) {
        return d;
      }
      return a2[0] - b[0];
    }
    function createIntervalTree(intervals) {
      if (intervals.length === 0) {
        return null;
      }
      var pts = [];
      for (var i = 0; i < intervals.length; ++i) {
        pts.push(intervals[i][0], intervals[i][1]);
      }
      pts.sort(compareNumbers);
      var mid = pts[pts.length >> 1];
      var leftIntervals = [];
      var rightIntervals = [];
      var centerIntervals = [];
      for (var i = 0; i < intervals.length; ++i) {
        var s2 = intervals[i];
        if (s2[1] < mid) {
          leftIntervals.push(s2);
        } else if (mid < s2[0]) {
          rightIntervals.push(s2);
        } else {
          centerIntervals.push(s2);
        }
      }
      var leftPoints = centerIntervals;
      var rightPoints = centerIntervals.slice();
      leftPoints.sort(compareBegin);
      rightPoints.sort(compareEnd);
      return new IntervalTreeNode(
        mid,
        createIntervalTree(leftIntervals),
        createIntervalTree(rightIntervals),
        leftPoints,
        rightPoints
      );
    }
    function IntervalTree2(root15) {
      this.root = root15;
    }
    var tproto = IntervalTree2.prototype;
    tproto.insert = function(interval2) {
      if (this.root) {
        this.root.insert(interval2);
      } else {
        this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);
      }
    };
    tproto.remove = function(interval2) {
      if (this.root) {
        var r = this.root.remove(interval2);
        if (r === EMPTY) {
          this.root = null;
        }
        return r !== NOT_FOUND;
      }
      return false;
    };
    tproto.queryPoint = function(p, cb) {
      if (this.root) {
        return this.root.queryPoint(p, cb);
      }
    };
    tproto.queryInterval = function(lo, hi, cb) {
      if (lo <= hi && this.root) {
        return this.root.queryInterval(lo, hi, cb);
      }
    };
    Object.defineProperty(tproto, "count", {
      get: function() {
        if (this.root) {
          return this.root.count;
        }
        return 0;
      }
    });
    Object.defineProperty(tproto, "intervals", {
      get: function() {
        if (this.root) {
          return this.root.intervals([]);
        }
        return [];
      }
    });
    function createWrapper(intervals) {
      if (!intervals || intervals.length === 0) {
        return new IntervalTree2(null);
      }
      return new IntervalTree2(createIntervalTree(intervals));
    }
  }
});

// node_modules/d3-array/src/ascending.js
function ascending(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S2, w, h) {
  for (let y2 = 0, n = w * h; y2 < n; ) {
    blur3(T, S2, y2, y2 += w, 1);
  }
}
function blurv(blur3, T, S2, w, h) {
  for (let x2 = 0, n = w * h; x2 < w; ++x2) {
    blur3(T, S2, x2, x2 + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S2, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S2, start + 0, stop + 0, step);
    blur3(T, S2, start + 1, stop + 1, step);
    blur3(T, S2, start + 2, stop + 2, step);
    blur3(T, S2, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S2, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius0 * S2[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum4 += S2[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S2[Math.min(stop, i + s0)];
      T[i] = (sum4 + t * (S2[Math.max(start, i - s1)] + S2[Math.min(stop, i + s1)])) / w;
      sum4 -= S2[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S2, start, stop, step) => {
    if (!((stop -= step) >= start)) return;
    let sum4 = radius * S2[start];
    const s2 = step * radius;
    for (let i = start, j = start + s2; i < j; i += step) {
      sum4 += S2[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum4 += S2[Math.min(stop, i + s2)];
      T[i] = sum4 / w;
      sum4 -= S2[Math.max(start, i - s2)];
    }
  };
}

// node_modules/d3-array/src/count.js
function count(values, valueof) {
  let count2 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count2;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        ++count2;
      }
    }
  }
  return count2;
}

// node_modules/d3-array/src/variance.js
function variance(values, valueof) {
  let count2 = 0;
  let delta;
  let mean3 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean3;
        mean3 += delta / ++count2;
        sum4 += delta * (value - mean3);
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        delta = value - mean3;
        mean3 += delta / ++count2;
        sum4 += delta * (value - mean3);
      }
    }
  }
  if (count2 > 1) return sum4 / (count2 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values, valueof) {
  const v = variance(values, valueof);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min3;
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min3 === void 0) {
          if (value >= value) min3 = max3 = value;
        } else {
          if (min3 > value) min3 = value;
          if (max3 < value) max3 = value;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null) {
        if (min3 === void 0) {
          if (value >= value) min3 = max3 = value;
        } else {
          if (min3 > value) min3 = value;
          if (max3 < value) max3 = value;
        }
      }
    }
  }
  return [min3, max3];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x2) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
      if (lo) p[i++] = lo;
      x2 = hi;
    }
    p[i] = x2;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x2, y2, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x2 = hi;
        y2 = p[--n];
        hi = x2 + y2;
        lo = y2 - (hi - x2);
        if (lo) break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y2 = lo * 2;
        x2 = hi + y2;
        if (y2 == x2 - hi) hi = x2;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key2 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
    if (entries != null) for (const [key3, value] of entries) this.set(key3, value);
  }
  get(key2) {
    return super.get(intern_get(this, key2));
  }
  has(key2) {
    return super.has(intern_get(this, key2));
  }
  set(key2, value) {
    return super.set(intern_set(this, key2), value);
  }
  delete(key2) {
    return super.delete(intern_delete(this, key2));
  }
};
function intern_get({ _intern, _key }, value) {
  const key2 = _key(value);
  return _intern.has(key2) ? _intern.get(key2) : value;
}
function intern_set({ _intern, _key }, value) {
  const key2 = _key(value);
  if (_intern.has(key2)) return _intern.get(key2);
  _intern.set(key2, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key2 = _key(value);
  if (_intern.has(key2)) {
    value = _intern.get(key2);
    _intern.delete(key2);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

// node_modules/d3-array/src/identity.js
function identity(x2) {
  return x2;
}

// node_modules/d3-array/src/group.js
function groups(values, ...keys) {
  return nest(values, Array.from, identity, keys);
}
function nest(values, map5, reduce2, keys) {
  return (function regroup(values2, i) {
    if (i >= keys.length) return reduce2(values2);
    const groups2 = new InternMap();
    const keyof2 = keys[i++];
    let index3 = -1;
    for (const value of values2) {
      const key2 = keyof2(value, ++index3, values2);
      const group3 = groups2.get(key2);
      if (group3) group3.push(value);
      else groups2.set(key2, [value]);
    }
    for (const [key2, values3] of groups2) {
      groups2.set(key2, regroup(values3, i));
    }
    return map5(groups2);
  })(values, 0);
}

// node_modules/d3-array/src/sort.js
function compareDefined(compare = ascending) {
  if (compare === ascending) return ascendingDefined;
  if (typeof compare !== "function") throw new TypeError("compare is not a function");
  return (a2, b) => {
    const x2 = compare(a2, b);
    if (x2 || x2 === 0) return x2;
    return (compare(b, b) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b) {
  return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/constant.js
function constant(x2) {
  return () => x2;
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power2 = Math.floor(Math.log10(step)), error = step / Math.pow(10, power2), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc2;
  if (power2 < 0) {
    inc2 = Math.pow(10, -power2) / factor;
    i1 = Math.round(start * inc2);
    i2 = Math.round(stop * inc2);
    if (i1 / inc2 < start) ++i1;
    if (i2 / inc2 > stop) --i2;
    inc2 = -inc2;
  } else {
    inc2 = Math.pow(10, power2) * factor;
    i1 = Math.round(start / inc2);
    i2 = Math.round(stop / inc2);
    if (i1 * inc2 < start) ++i1;
    if (i2 * inc2 > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc2];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start === stop) return [start];
  const reverse3 = stop < start, [i1, i2, inc2] = reverse3 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse3) {
    if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc2;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc2;
  } else {
    if (inc2 < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc2;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc2;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse3 = stop < start, inc2 = reverse3 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
}

// node_modules/d3-array/src/nice.js
function nice(start, stop, count2) {
  let prestep;
  while (true) {
    const step = tickIncrement(start, stop, count2);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}

// node_modules/d3-array/src/threshold/sturges.js
function thresholdSturges(values) {
  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
}

// node_modules/d3-array/src/bin.js
function bin() {
  var value = identity, domain = extent, threshold2 = thresholdSturges;
  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i, n = data.length, x2, step, values = new Array(n);
    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }
    var xz = domain(values), x06 = xz[0], x12 = xz[1], tz = threshold2(values, x06, x12);
    if (!Array.isArray(tz)) {
      const max3 = x12, tn = +tz;
      if (domain === extent) [x06, x12] = nice(x06, x12, tn);
      tz = ticks(x06, x12, tn);
      if (tz[0] <= x06) step = tickIncrement(x06, x12, tn);
      if (tz[tz.length - 1] >= x12) {
        if (max3 >= x12 && domain === extent) {
          const step2 = tickIncrement(x06, x12, tn);
          if (isFinite(step2)) {
            if (step2 > 0) {
              x12 = (Math.floor(x12 / step2) + 1) * step2;
            } else if (step2 < 0) {
              x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m = tz.length, a2 = 0, b = m;
    while (tz[a2] <= x06) ++a2;
    while (tz[b - 1] > x12) --b;
    if (a2 || b < m) tz = tz.slice(a2, b), m = b - a2;
    var bins = new Array(m + 1), bin3;
    for (i = 0; i <= m; ++i) {
      bin3 = bins[i] = [];
      bin3.x0 = i > 0 ? tz[i - 1] : x06;
      bin3.x1 = i < m ? tz[i] : x12;
    }
    if (isFinite(step)) {
      if (step > 0) {
        for (i = 0; i < n; ++i) {
          if ((x2 = values[i]) != null && x06 <= x2 && x2 <= x12) {
            bins[Math.min(m, Math.floor((x2 - x06) / step))].push(data[i]);
          }
        }
      } else if (step < 0) {
        for (i = 0; i < n; ++i) {
          if ((x2 = values[i]) != null && x06 <= x2 && x2 <= x12) {
            const j = Math.floor((x06 - x2) * step);
            bins[Math.min(m, j + (tz[j] <= x2))].push(data[i]);
          }
        }
      }
    } else {
      for (i = 0; i < n; ++i) {
        if ((x2 = values[i]) != null && x06 <= x2 && x2 <= x12) {
          bins[bisect_default(tz, x2, 0, m)].push(data[i]);
        }
      }
    }
    return bins;
  }
  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };
  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };
  histogram.thresholds = function(_) {
    return arguments.length ? (threshold2 = typeof _ === "function" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold2;
  };
  return histogram;
}

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
        max3 = value;
      }
    }
  }
  return max3;
}

// node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min3;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (min3 > value || min3 === void 0 && value >= value)) {
        min3 = value;
      }
    }
  }
  return min3;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k2, left = 0, right = Infinity, compare) {
  k2 = Math.floor(k2);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array2.length - 1, right));
  if (!(left <= k2 && k2 <= right)) return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k2 - left + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m * s2 / n + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n - m) * s2 / n + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t = array2[k2];
    let i = left;
    let j = right;
    swap(array2, left, k2);
    if (compare(array2[right], t) > 0) swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t) < 0) ++i;
      while (compare(array2[j], t) > 0) --j;
    }
    if (compare(array2[left], t) === 0) swap(array2, left, j);
    else ++j, swap(array2, j, right);
    if (j <= k2) left = j + 1;
    if (k2 <= j) right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t = array2[i];
  array2[i] = array2[j];
  array2[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = number) {
  if (!(n = values.length) || isNaN(p = +p)) return;
  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/threshold/freedmanDiaconis.js
function thresholdFreedmanDiaconis(values, min3, max3) {
  const c4 = count(values), d = quantile(values, 0.75) - quantile(values, 0.25);
  return c4 && d ? Math.ceil((max3 - min3) / (2 * d * Math.pow(c4, -1 / 3))) : 1;
}

// node_modules/d3-array/src/threshold/scott.js
function thresholdScott(values, min3, max3) {
  const c4 = count(values), d = deviation(values);
  return c4 && d ? Math.ceil((max3 - min3) * Math.cbrt(c4) / (3.49 * d)) : 1;
}

// node_modules/d3-array/src/mean.js
function mean(values, valueof) {
  let count2 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count2, sum4 += value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && (value = +value) >= value) {
        ++count2, sum4 += value;
      }
    }
  }
  if (count2) return sum4 / count2;
}

// node_modules/d3-array/src/median.js
function median(values, valueof) {
  return quantile(values, 0.5, valueof);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array2 of arrays) {
    yield* array2;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/mode.js
function mode(values, valueof) {
  const counts = new InternMap();
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null && value >= value) {
        counts.set(value, (counts.get(value) || 0) + 1);
      }
    }
  }
  let modeValue;
  let modeCount = 0;
  for (const [value, count2] of counts) {
    if (count2 > modeCount) {
      modeCount = count2;
      modeValue = value;
    }
  }
  return modeValue;
}

// node_modules/d3-array/src/range.js
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range3 = new Array(n);
  while (++i < n) {
    range3[i] = start + i * step;
  }
  return range3;
}

// node_modules/d3-array/src/rank.js
function rank(values, valueof = ascending) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  let V = Array.from(values);
  const R = new Float64Array(V.length);
  if (valueof.length !== 2) V = V.map(valueof), valueof = ascending;
  const compareIndex = (i, j) => valueof(V[i], V[j]);
  let k2, r;
  values = Uint32Array.from(V, (_, i) => i);
  values.sort(valueof === ascending ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex));
  values.forEach((j, i) => {
    const c4 = compareIndex(j, k2 === void 0 ? j : k2);
    if (c4 >= 0) {
      if (k2 === void 0 || c4 > 0) k2 = j, r = i;
      R[j] = r;
    } else {
      R[j] = NaN;
    }
  });
  return R;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random2) {
  return function shuffle3(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random2() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        sum4 += value;
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index3, values)) {
        sum4 += value;
      }
    }
  }
  return sum4;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = /* @__PURE__ */ Symbol("implicit");
function ordinal() {
  var index3 = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale(d) {
    let i = index3.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index3.set(d, i = domain.push(d) - 1);
    }
    return range3[i % range3.length];
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index3 = new InternMap();
    for (const value of _) {
      if (index3.has(value)) continue;
      index3.set(value, domain.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), scale) : range3.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse3 = r1 < r0, start = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round2) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse3 ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round2 = !!_, rescale()) : round2;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition) prototype[key2] = definition[key2];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h = NaN, s2 = max3 - min3, l = (max3 + min3) / 2;
  if (s2) {
    if (r === max3) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max3) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b) x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c4, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c4, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c4, l, opacity) {
  this.h = +h;
  this.c = +c4;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a2 * (A * cosh2 + B * sinh2)),
      255 * (l + a2 * (C * cosh2 + D * sinh2)),
      255 * (l + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x2) => () => x2;

// node_modules/d3-interpolate/src/color.js
function linear(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function hue(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential(a2, b, y2) : constant_default(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear(a2, d) : constant_default(isNaN(a2) ? b : a2);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
})(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b) {
  if (!b) b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c4 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c4[i] = a2[i] * (1 - t) + b[i] * t;
    return c4;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c4 = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = value_default(a2[i], b[i]);
  for (; i < nb; ++i) c4[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c4[i] = x2[i](t);
    return c4;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b) {
  var d = /* @__PURE__ */ new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b) {
  var i = {}, c4 = {}, k2;
  if (a2 === null || typeof a2 !== "object") a2 = {};
  if (b === null || typeof b !== "object") b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = value_default(a2[k2], b[k2]);
    } else {
      c4[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i) c4[k2] = i[k2](t);
    return c4;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b) {
  var t = typeof b, c4;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c4 = color(b)) ? (b = c4, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a2, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b, c4, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b)) a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c4 + b * d) c4 -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c4 * c4 + d * d)) c4 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c4) a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity2 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop2(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180) b += 360;
      else if (b - a2 > 180) a2 += 360;
      q.push({ i: s2.push(pop2(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop2(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop2(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b) });
    } else if (b) {
      s2.push(pop2(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop2(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop2(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse(a2), b = parse(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
var zoom_default = (function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S2;
    if (d2 < epsilon2) {
      S2 = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S2)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S2 = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S2, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S2 * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
})(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/lab.js
function lab2(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l), a2 = nogamma(start.a, end.a), b = nogamma(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a2(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c4 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c4(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return (function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y2));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  })(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values) {
  if (values === void 0) values = interpolate, interpolate = value_default;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/d3-interpolate/src/quantize.js
function quantize_default(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

// node_modules/d3-scale/src/constant.js
function constants(x2) {
  return function() {
    return x2;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x2) {
  return +x2;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a2, b) {
  var t;
  if (a2 > b) t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range3, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range3, interpolate) {
  var j = Math.min(domain.length, range3.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range3[i], range3[i + 1]);
  }
  return function(x2) {
    var i2 = bisect_default(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range3 = unit, interpolate = value_default, transform, untransform, unknown, clamp2 = identity3, piecewise2, output2, input;
  function rescale() {
    var n = Math.min(domain.length, range3.length);
    if (clamp2 !== identity3) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output2 = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output2 || (output2 = piecewise2(domain.map(transform), range3, interpolate)))(transform(clamp2(x2)));
  }
  scale.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise2(range3, domain.map(transform), number_default)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale.rangeRound = function(_) {
    return range3 = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity3, rescale()) : clamp2 !== identity3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if (!isFinite(x2) || x2 === 0) return null;
  var i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e"), coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d) return prefixExponent = void 0, x2.toPrecision(p);
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d) return x2 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal_default,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded_default(x2 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x2) {
  return x2;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier, options) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
    if (zero3 || fill2 === "0" && align === "=") zero3 = true, fill2 = "0", align = "=";
    var prefix = (options && options.prefix !== void 0 ? options.prefix : "") + (symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : ""), suffix = (symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "") + (options && options.suffix !== void 0 ? options.suffix : "");
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c4;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign3 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type === "s" && !isNaN(value) && prefixExponent !== void 0 ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c4 = value.charCodeAt(i), 48 > c4 || c4 > 57) {
              valueSuffix = (c4 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group3(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill2) : "";
      if (comma && zero3) value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k2 = Math.pow(10, -e), f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier), { suffix: prefixes[8 + e / 3] });
    return function(value2) {
      return f(k2 * value2);
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max3) {
  step = Math.abs(step), max3 = Math.abs(max3) - step;
  return Math.max(0, exponent_default(max3) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x06 = domain[i0], x12 = domain[i1], t;
  if (x12 < x06) {
    t = i0, i0 = i1, i1 = t;
    t = x06, x06 = x12, x12 = t;
  }
  domain[i0] = interval2.floor(x06);
  domain[i1] = interval2.ceil(x12);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f) {
  return (x2, k2) => -f(-x2, k2);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;
    if (r) [u, v] = [v, u];
    let i = logs(u);
    let j = logs(v);
    let k2;
    let t;
    const n = count2 == null ? 10 : +count2;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k2 = 1; k2 < base; ++k2) {
          t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      else for (; i <= j; ++i) {
        for (k2 = base - 1; k2 >= 1; --k2) {
          t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null) count2 = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count2 === Infinity) return specifier;
    const k2 = Math.max(1, base * count2 / scale.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale.nice = () => {
    return domain(nice2(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c4) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c4));
  };
}
function transformSymexp(c4) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c4;
  };
}
function symlogish(transform) {
  var c4 = 1, scale = transform(transformSymlog(c4), transformSymexp(c4));
  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c4 = +_), transformSymexp(c4)) : c4;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  var scale = transform(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform(identity3, identity3) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range3.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range3[bisect_default(thresholds, x2)];
  }
  scale.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x06 = 0, x12 = 1, n = 1, domain = [0.5], range3 = [0, 1], unknown;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range3[bisect_default(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);
    return scale;
  }
  scale.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
  };
  scale.range = function(_) {
    return arguments.length ? (n = (range3 = Array.from(_)).length - 1, rescale()) : range3.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x06, x12]).range(range3).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n = 1;
  function scale(x2) {
    return x2 != null && x2 <= x2 ? range3[bisect_default(domain, x2, 0, n)] : unknown;
  }
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range3.length - 1), scale) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), n = Math.min(domain.length, range3.length - 1), scale) : range3.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = (date2) => {
    const d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = (start, stop, step) => {
    const range3 = [];
    start = interval2.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range3;
  };
  interval2.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval2.count = (start, end) => {
      t02.setTime(+start), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval2.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? (d) => field(d) % step === 0 : (d) => interval2.count(0, d) % step === 0);
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0)) return null;
  if (!(k2 > 1)) return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals2 = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count2) {
    const reverse3 = stop < start;
    if (reverse3) [start, stop] = [stop, start];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks3 = interval2 ? interval2.range(start, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals2, target);
    if (i === tickIntervals2.length) return year.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
    const [t, step] = tickIntervals2[target / tickIntervals2[i - 1][2] < tickIntervals2[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth2,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c4, pad3, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads[c4 = specifier.charAt(++i)]) != null) c4 = specifier.charAt(++i);
          else pad3 = c4 === "e" ? " " : "0";
          if (format2 = formats2[c4]) c4 = format2(date2, pad3);
          string.push(c4);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c4, parse;
    while (i < n) {
      if (j >= m) return -1;
      c4 = specifier.charCodeAt(i++);
      if (c4 === 37) {
        c4 = specifier.charAt(i++);
        parse = parses[c4 in pads ? specifier.charAt(i++) : c4];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c4 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth2(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill2, width) {
  var sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length = string.length;
  return sign3 + (length < width ? new Array(width - length + 1).join(fill2) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale = continuous(), invert2 = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth2 = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number3)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice2(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x06 = 0, x12 = 1, t03, t13, k10, transform, interpolator = identity3, clamp2 = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t03) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, t03 = transform(x06 = +x06), t13 = transform(x12 = +x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03), scale) : [x06, x12];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform = t, t03 = t(x06), t13 = t(x12), k10 = t03 === t13 ? 0 : 1 / (t13 - t03);
    return scale;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer2()(identity3));
  scale.copy = function() {
    return copy2(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer2()).domain([1, 10]);
  scale.copy = function() {
    return copy2(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
  var domain = [], interpolator = identity3;
  function scale(x2) {
    if (x2 != null && !isNaN(x2 = +x2)) return interpolator((bisect_default(domain, x2, 1) - 1) / (domain.length - 1));
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return scale;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };
  scale.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x06 = 0, x12 = 0.5, x2 = 1, s2 = 1, t03, t13, t22, k10, k21, interpolator = identity3, transform, clamp2 = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t13) * (s2 * x3 < s2 * t13 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x06, x12, x2] = _, t03 = transform(x06 = +x06), t13 = transform(x12 = +x12), t22 = transform(x2 = +x2), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1, scale) : [x06, x12, x2];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale) : clamp2;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform = t, t03 = t(x06), t13 = t(x12), t22 = t(x2), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t03 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer3()(identity3));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer3()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy2(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// node_modules/svelteplot/dist/constants.js
var ORIGINAL_NAME_KEYS = {
  x: /* @__PURE__ */ Symbol("origName_x"),
  x1: /* @__PURE__ */ Symbol("origName_x1"),
  x2: /* @__PURE__ */ Symbol("origName_x2"),
  y: /* @__PURE__ */ Symbol("origName_y"),
  y1: /* @__PURE__ */ Symbol("origName_y1"),
  y2: /* @__PURE__ */ Symbol("origName_y2"),
  fill: /* @__PURE__ */ Symbol("origName_color"),
  stroke: /* @__PURE__ */ Symbol("origName_color"),
  opacity: /* @__PURE__ */ Symbol("origName_opacity"),
  symbol: /* @__PURE__ */ Symbol("origName_symbol"),
  r: /* @__PURE__ */ Symbol("origName_r"),
  z: /* @__PURE__ */ Symbol("origName_z"),
  sort: /* @__PURE__ */ Symbol("origName_sort"),
  filter: /* @__PURE__ */ Symbol("origName_filter"),
  interval: /* @__PURE__ */ Symbol("origName_interval"),
  length: /* @__PURE__ */ Symbol("origName_length"),
  fx: /* @__PURE__ */ Symbol("origName_fx"),
  fy: /* @__PURE__ */ Symbol("origName_fy"),
  fillOpacity: /* @__PURE__ */ Symbol("origName_opacity"),
  strokeOpacity: /* @__PURE__ */ Symbol("origName_opacity")
};
var SCALES = [
  "x",
  "y",
  "color",
  "opacity",
  "symbol",
  "r",
  "length",
  "fx",
  "fy",
  "projection"
];
var VALID_SCALE_TYPES = {
  color: /* @__PURE__ */ new Set([
    "linear",
    "categorical",
    "ordinal",
    "diverging",
    "quantile",
    "quantize",
    "quantile-cont",
    "threshold",
    "log",
    "symlog",
    "pow",
    "sqrt",
    "diverging-log",
    "diverging-pow",
    "diverging-sqrt",
    "diverging-symlog"
  ]),
  x: /* @__PURE__ */ new Set([
    "linear",
    "log",
    "symlog",
    "time",
    "ordinal",
    "band",
    "point",
    "quantile",
    "quantize",
    "threshold"
  ]),
  y: /* @__PURE__ */ new Set([
    "linear",
    "log",
    "symlog",
    "time",
    "ordinal",
    "band",
    "point",
    "quantile",
    "quantize",
    "threshold"
  ]),
  symbol: /* @__PURE__ */ new Set(["categorical", "ordinal"]),
  opacity: /* @__PURE__ */ new Set(["linear", "log", "symlog", "sqrt", "pow"]),
  r: /* @__PURE__ */ new Set(["linear", "log", "symlog", "sqrt", "pow"]),
  length: /* @__PURE__ */ new Set(["linear", "log", "symlog", "sqrt", "pow"]),
  fx: /* @__PURE__ */ new Set(["band"]),
  fy: /* @__PURE__ */ new Set(["band"]),
  // projection is a special type not mapping to a D3 scale
  projection: /* @__PURE__ */ new Set()
};
var CHANNEL_SCALE = {
  x: "x",
  x1: "x",
  x2: "x",
  y: "y",
  y1: "y",
  y2: "y",
  r: "r",
  length: "length",
  fx: "fx",
  fy: "fy",
  symbol: "symbol",
  fill: "color",
  stroke: "color",
  opacity: "opacity",
  fillOpacity: "opacity",
  strokeOpacity: "opacity"
};
var CSS_VAR = /^var\(--([a-z-0-9,\s]+)\)$/;
var CSS_COLOR = /^color\(/;
var CSS_COLOR_MIX = /^color-mix\(/;
var CSS_COLOR_CONTRAST = /^color-contrast\(/;
var CSS_RGBA = /^rgba\(/;
var CSS_URL = /^url\(#/;
var INDEX = /* @__PURE__ */ Symbol("index");
var PI = Math.PI;
var TAU = PI * 2;

// node_modules/svelteplot/dist/helpers/isDataRecord.js
function isDataRecord_default(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}

// node_modules/d3-shape/src/constant.js
function constant_default2(x2) {
  return function constant4() {
    return x2;
  };
}

// node_modules/d3-shape/src/math.js
var cos = Math.cos;
var min2 = Math.min;
var sin = Math.sin;
var sqrt2 = Math.sqrt;
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon3 = 1e-6;
var tauEpsilon = tau2 - epsilon3;
function append2(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append2;
  const k2 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append2 : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x12, y12, x2, y2) {
    this._append`Q${+x12},${+y12},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x12, y12, x2, y2, x3, y3) {
    this._append`C${+x12},${+y12},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x12, y12, x2, y2, r) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let x06 = this._x1, y06 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x12},${this._y1 = y12}`;
    } else if (!(l01_2 > epsilon3)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r) {
      this._append`L${this._x1 = x12},${this._y1 = y12}`;
    } else {
      let x20 = x2 - x06, y20 = y2 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0) throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x06 = x2 + dx, y06 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x06},${y06}`;
    } else if (Math.abs(this._x1 - x06) > epsilon3 || Math.abs(this._y1 - y06) > epsilon3) {
      this._append`L${x06},${y06}`;
    }
    if (!r) return;
    if (da < 0) da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
    } else if (da > epsilon3) {
      this._append`A${r},${r},0,${+(da >= pi2)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;
function pathRound(digits = 3) {
  return new Path(+digits);
}

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default2(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  var defined = constant_default2(true), context = null, curve = linear_default, output2 = null, path2 = withPath(line);
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default2(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default2(y2);
  function line(data) {
    var i, n = (data = array_default2(data)).length, d, defined0 = false, buffer;
    if (context == null) output2 = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output2.lineStart();
        else output2.lineEnd();
      }
      if (defined0) output2.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer) return output2 = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x2 = typeof _ === "function" ? _ : constant_default2(+_), line) : x2;
  };
  line.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant_default2(+_), line) : y2;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output2 = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output2 = null : output2 = curve(context = _), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default(x06, y06, y12) {
  var x12 = null, defined = constant_default2(true), context = null, curve = linear_default, output2 = null, path2 = withPath(area);
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x : constant_default2(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default2(0) : constant_default2(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default2(+y12);
  function area(data) {
    var i, j, k2, n = (data = array_default2(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null) output2 = curve(buffer = path2());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output2.areaStart();
          output2.lineStart();
        } else {
          output2.lineEnd();
          output2.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output2.point(x0z[k2], y0z[k2]);
          }
          output2.lineEnd();
          output2.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x06(d, i, data), y0z[i] = +y06(d, i, data);
        output2.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output2 = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default2(+_), x12 = null, area) : x06;
  };
  area.x0 = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default2(+_), area) : x06;
  };
  area.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : x12;
  };
  area.y = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default2(+_), y12 = null, area) : y06;
  };
  area.y0 = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default2(+_), area) : y06;
  };
  area.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default2(+_), area) : y12;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default2(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output2 = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output2 = null : output2 = curve(context = _), area) : context;
  };
  return area;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/curve/bump.js
var Bump = class {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x2, y2);
        else this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
};
function bumpX(context) {
  return new Bump(context, true);
}
function bumpY(context) {
  return new Bump(context, false);
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt2(3);
var asterisk_default = {
  draw(context, size) {
    const r = sqrt2(size + min2(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u = t * sqrt3;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u, -t);
    context.lineTo(u, t);
    context.moveTo(-u, t);
    context.lineTo(u, -t);
  }
};

// node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw(context, size) {
    const r = sqrt2(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

// node_modules/d3-shape/src/symbol/cross.js
var cross_default = {
  draw(context, size) {
    const r = sqrt2(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt2(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = {
  draw(context, size) {
    const y2 = sqrt2(size / tan30_2);
    const x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/diamond2.js
var diamond2_default = {
  draw(context, size) {
    const r = sqrt2(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/plus.js
var plus_default = {
  draw(context, size) {
    const r = sqrt2(size - min2(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
};

// node_modules/d3-shape/src/symbol/square.js
var square_default = {
  draw(context, size) {
    const w = sqrt2(size);
    const x2 = -w / 2;
    context.rect(x2, x2, w, w);
  }
};

// node_modules/d3-shape/src/symbol/square2.js
var square2_default = {
  draw(context, size) {
    const r = sqrt2(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/star.js
var ka = 0.8908130915292852;
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;
var star_default = {
  draw(context, size) {
    const r = sqrt2(size * ka);
    const x2 = kx * r;
    const y2 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x2, y2);
    for (let i = 1; i < 5; ++i) {
      const a2 = tau * i / 5;
      const c4 = cos(a2);
      const s2 = sin(a2);
      context.lineTo(s2 * r, -c4 * r);
      context.lineTo(c4 * x2 - s2 * y2, s2 * x2 + c4 * y2);
    }
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt2(3);
var triangle_default = {
  draw(context, size) {
    const y2 = -sqrt2(size / (sqrt32 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt32 * y2, -y2);
    context.lineTo(sqrt32 * y2, -y2);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt2(3);
var triangle2_default = {
  draw(context, size) {
    const s2 = sqrt2(size) * 0.6824;
    const t = s2 / 2;
    const u = s2 * sqrt33 / 2;
    context.moveTo(0, -s2);
    context.lineTo(u, t);
    context.lineTo(-u, t);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/wye.js
var c = -0.5;
var s = sqrt2(3) / 2;
var k = 1 / sqrt2(12);
var a = (k / 2 + 1) * 3;
var wye_default = {
  draw(context, size) {
    const r = sqrt2(size / a);
    const x06 = r / 2, y06 = r * k;
    const x12 = x06, y12 = r * k + r;
    const x2 = -x12, y2 = y12;
    context.moveTo(x06, y06);
    context.lineTo(x12, y12);
    context.lineTo(x2, y2);
    context.lineTo(c * x06 - s * y06, s * x06 + c * y06);
    context.lineTo(c * x12 - s * y12, s * x12 + c * y12);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x06 + s * y06, c * y06 - s * x06);
    context.lineTo(c * x12 + s * y12, c * y12 - s * x12);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

// node_modules/d3-shape/src/symbol/times.js
var times_default = {
  draw(context, size) {
    const r = sqrt2(size - min2(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
};

// node_modules/d3-shape/src/symbol.js
function Symbol2(type, size) {
  let context = null, path2 = withPath(symbol);
  type = typeof type === "function" ? type : constant_default2(type || circle_default);
  size = typeof size === "function" ? size : constant_default2(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context) context = buffer = path2();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant_default2(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default2(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basis_default2(context) {
  return new Basis(context);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisClosed_default2(context) {
  return new BasisClosed(context);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x2) / 6, y06 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x06 = x2[0], y06 = y2[0], dx = x2[j] - x06, dy = y2[j] - y06, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x06 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y06 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
var bundle_default = (function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
})(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinal_default = (function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalClosed_default = (function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var cardinalOpen_default = (function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
})(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x2, y2) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point4(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRom_default = (function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point4(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomClosed_default = (function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        point4(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
var catmullRomOpen_default = (function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
})(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) this._context.lineTo(x2, y2);
    else this._point = 1, this._context.moveTo(x2, y2);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point5(that, t03, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t13 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t13 = slope3(this, x2, y2)), t13);
        break;
      default:
        point5(this, this._t0, t13 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t13;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i) a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i) m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

// node_modules/d3-shape/src/stack.js
function stackValue(d, key2) {
  return d[key2];
}
function stackSeries(key2) {
  const series = [];
  series.key = key2;
  return series;
}
function stack_default() {
  var keys = constant_default2([]), order = none_default2, offset = none_default, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }
    for (i = 0, oz = array_default2(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : keys;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant_default2(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none_default2 : typeof _ === "function" ? _ : constant_default2(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
  };
  return stack;
}

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
    for (y2 = i = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    if (y2) for (i = 0; i < n; ++i) series[i][j][1] /= y2;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y2 = 0; i < n; ++i) y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1) y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  none_default(series, order);
}

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a2, b) {
    return peaks[a2] - peaks[b];
  });
}
function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

// node_modules/d3-shape/src/order/ascending.js
function ascending_default(series) {
  var sums = series.map(sum2);
  return none_default2(series).sort(function(a2, b) {
    return sums[a2] - sums[b];
  });
}
function sum2(series) {
  var s2 = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s2 += v;
  return s2;
}

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n = series.length, i, j, sums = series.map(sum2), order = appearance_default(series), top = 0, bottom = 0, tops = [], bottoms = [];
  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }
  return bottoms.reverse().concat(tops);
}

// node_modules/svelteplot/dist/helpers/symbols.js
var sqrt34 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt34;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  if (typeof value === "string")
    return false;
  return value && typeof value.draw === "function";
}
function isSymbol(value) {
  if (isSymbolObject(value))
    return true;
  if (typeof value !== "string")
    return false;
  return symbols.has(value.toLowerCase());
}
function maybeSymbol(symbol) {
  if (symbol == null || isSymbolObject(symbol))
    return symbol;
  const value = symbols.get(`${symbol}`.toLowerCase());
  if (value)
    return value;
  throw new Error(`invalid symbol: ${symbol}`);
}

// node_modules/svelteplot/dist/helpers/typeChecks.js
function isDate(v) {
  return v instanceof Date && !isNaN(v.getTime());
}
function isDateOrNull(v) {
  return v == null || isDate(v);
}
function isNumberOrNull(v) {
  return v == null || Number.isFinite(v) || typeof v === "string" && !Number.isNaN(+v);
}
function isNumberOrNullOrNaN(v) {
  return v == null || Number.isFinite(v) || Number.isNaN(v) || typeof v === "string" && !Number.isNaN(+v);
}
function isStringOrNull(v) {
  return v == null || typeof v === "string";
}
function isSymbolOrNull(v) {
  return v == null || (typeof v === "string" || typeof v === "object") && isSymbol(v);
}
function isColorOrNull(v) {
  if (v == null)
    return true;
  if (typeof v === "string") {
    v = `${v}`.toLowerCase();
    return v === "currentcolor" || CSS_VAR.test(v) || CSS_COLOR.test(v) || CSS_COLOR_MIX.test(v) || CSS_COLOR_CONTRAST.test(v) || CSS_RGBA.test(v) || CSS_URL.test(v) || color(v) !== null;
  }
  return false;
}

// node_modules/svelteplot/dist/helpers/isRawValue.js
function isRawValue_default(value) {
  const t = typeof value;
  return t === "string" || t === "number" || t === "boolean" || t === "object" || isDate(value) || t === null;
}

// node_modules/svelteplot/dist/helpers/index.js
function coalesce(...args) {
  for (const arg of args) {
    if (arg !== null && arg !== void 0) {
      return arg;
    }
  }
  return null;
}
function testFilter(datum, options) {
  return options.filter == null || resolveProp(options.filter, datum);
}
function randomId() {
  return Math.ceil(1e9 + Math.random() * 1e9).toString(36);
}
function isSnippet(value) {
  return typeof value === "function" && value.length === 1;
}
function isValid(value) {
  return value !== null && value !== void 0 && !Number.isNaN(value) && (typeof value !== "number" || Number.isFinite(value));
}
function isObject(option) {
  return typeof option === "object" && !isDate(option) && !Array.isArray(option) && option !== null;
}
var NUMERIC = /^[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
function maybeNumber(value) {
  if (typeof value === "number" && Number.isFinite(value))
    return value;
  if (typeof value === "string") {
    if (NUMERIC.test(value.trim())) {
      return parseFloat(value);
    }
  }
  return null;
}
var constant2 = (x2) => () => x2;
var POSITION_CHANNELS = /* @__PURE__ */ new Set(["x", "x1", "x2", "y", "y1", "y2"]);
function parseInset(inset, width) {
  if (typeof inset === "number") {
    return inset;
  }
  if (inset.endsWith("%")) {
    return width * +inset.slice(0, -1) / 100;
  }
  return +inset;
}
function omit(obj, ...keys) {
  return Object.fromEntries(Object.entries(obj).filter(([key2]) => !keys.includes(key2)));
}
function identity5(x2) {
  return x2;
}
var GEOJSON_PREFER_STROKE = /* @__PURE__ */ new Set(["MultiLineString", "LineString"]);

// node_modules/svelteplot/dist/helpers/getBaseStyles.js
var styleProps = {
  strokeWidth: "stroke-width",
  strokeDasharray: "stroke-dasharray",
  strokeLinejoin: "stroke-linejoin",
  strokeLinecap: "stroke-linecap",
  blend: "mix-blend-mode",
  clipPath: "clip-path",
  mask: "mask",
  fontFamily: "font-family",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontWeight: "font-weight",
  textAnchor: "text-anchor",
  fontVariant: "font-variant",
  letterSpacing: "letter-spacing",
  textDecoration: "text-decoration",
  textTransform: "text-transform",
  wordSpacing: "word-spacing",
  cursor: "cursor",
  pointerEvents: "pointer-events"
};
var styleDefaults = {
  fontWeight: "normal"
};
function getBaseStylesObject(datum, props) {
  return Object.fromEntries(Object.entries(styleProps).filter(([key2, cssKey]) => cssKey && props[key2] != null).map(([key2, cssKey]) => [
    cssKey,
    maybeToPixel(cssKey, resolveProp(props[key2], datum, styleDefaults[key2] || null) ?? "")
  ]));
}
function maybeToPixel(cssKey, value) {
  if (cssKey === "font-size" || cssKey === "stroke-width") {
    return typeof value === "number" ? `${value}px` : value;
  }
  return value;
}
function maybeFromPixel(value) {
  return typeof value === "string" && value.endsWith("px") ? +value.slice(0, -2) : value;
}
function maybeFromRem(value, rootFontSize = 16) {
  return typeof value === "string" && value.endsWith("rem") ? +value.slice(0, -3) * rootFontSize : value;
}
var nextPatternId = 0;
function getPatternId() {
  return `svp-pattern-${++nextPatternId}`;
}

// node_modules/svelteplot/dist/transforms/recordize.js
var X = /* @__PURE__ */ Symbol("x");
var Y = /* @__PURE__ */ Symbol("y");
var RAW_VALUE = /* @__PURE__ */ Symbol("originalValue");
function indexData(data) {
  return data.map((d, i) => ({ ...d, [INDEX]: i }));
}
function recordizeX({ data, ...channels }, { withIndex } = { withIndex: true }) {
  const dataIsRawValueArray = !isDataRecord_default(data[0]) && !Array.isArray(data[0]) && channels.x == null;
  if (dataIsRawValueArray) {
    const { x: x2, x1: x12, x2: x22, ...nonXChannels } = channels;
    return {
      data: data.map((value, index3) => ({
        [RAW_VALUE]: value,
        [INDEX]: index3
      })),
      ...nonXChannels,
      x: RAW_VALUE,
      ...withIndex ? { y: INDEX } : {}
    };
  }
  return { data: indexData(data), ...channels };
}
function recordizeY({ data, ...channels }, { withIndex } = { withIndex: true }) {
  if (!data)
    return { data, ...channels };
  const dataIsRawValueArray = !isDataRecord_default(data[0]) && !Array.isArray(data[0]) && channels.y == null;
  if (dataIsRawValueArray) {
    const { y: y2, y1: y12, y2: y22, ...nonYChannels } = channels;
    return {
      data: Array.from(data).map((value, index3) => ({
        [INDEX]: index3,
        [RAW_VALUE]: value
      })),
      ...nonYChannels,
      ...withIndex ? { x: INDEX } : {},
      y: RAW_VALUE
    };
  }
  return { data: indexData(data), ...channels };
}
function recordizeXY({ data, ...channels }) {
  if (!data)
    return { data, ...channels };
  if (!isDataRecord_default(data[0]) && Array.isArray(data[0]) && channels.x === void 0 && channels.y === void 0) {
    return {
      data: data.map(([x2, y2, ...rest2], i) => ({
        [RAW_VALUE]: [x2, y2, ...rest2],
        [INDEX]: i,
        [X]: x2,
        [Y]: y2
      })),
      ...channels,
      x: X,
      y: Y
    };
  }
  return { data, ...channels };
}
function recordize({ data, ...channels }) {
  if (!data)
    return { data, ...channels };
  if (!isDataRecord_default(data[0])) {
    return {
      data: data.map((d, i) => ({
        [RAW_VALUE]: d,
        [INDEX]: i
      })),
      ...channels
    };
  }
  return { data: indexData(data), ...channels };
}

// node_modules/svelteplot/dist/helpers/resolve.js
function resolveProp(accessor, datum, _defaultValue = null) {
  if (typeof accessor === "function") {
    const accessorFn = accessor;
    return datum == null ? accessorFn() : accessorFn(datum.hasOwnProperty(RAW_VALUE) ? datum[RAW_VALUE] : datum, datum[INDEX]);
  } else {
    const accessorValue = accessor;
    if ((typeof accessorValue === "string" || typeof accessorValue === "symbol") && datum && datum[accessorValue] !== void 0) {
      return datum[accessor];
    }
  }
  return isRawValue_default(accessor) ? accessor : _defaultValue;
}
function toChannelOption(name, channel) {
  const isPositionScale = CHANNEL_SCALE[name] === "x" || CHANNEL_SCALE[name] === "y";
  const isOpacityScale = CHANNEL_SCALE[name] === "opacity";
  return isDataRecord_default(channel) ? channel : {
    value: channel,
    scale: !isPositionScale && !isOpacityScale && typeof channel === "number" || typeof channel === "undefined" ? null : CHANNEL_SCALE[name],
    channel: null
  };
}
function resolveChannel(channel, datum, channels) {
  const scale = CHANNEL_SCALE[channel];
  const accessor = channel === "z" ? channels.z || channels.fill || channels.stroke : channels[channel];
  const channelOptions = toChannelOption(channel, accessor);
  if (channelOptions.channel) {
    return resolveChannel(channelOptions.channel, datum, channels);
  }
  return resolve(datum, channelOptions.value, channel, scale);
}
function resolve(datum, accessor, channel, scale) {
  if (isDataRecord_default(datum)) {
    if (typeof accessor === "function")
      return accessor(datum[RAW_VALUE] != null ? datum[RAW_VALUE] : datum, datum?.[INDEX]);
    if ((typeof accessor === "string" || typeof accessor === "symbol") && datum[accessor] !== void 0)
      return datum[accessor];
    if (accessor === null && datum[channel] !== void 0)
      return datum[channel];
    return isRawValue_default(accessor) ? accessor : null;
  } else if (Array.isArray(datum) && (typeof accessor === "string" || typeof accessor === "number") && datum[accessor] != null) {
    return datum[accessor];
  } else {
    return typeof accessor === "function" ? accessor(datum, datum?.[INDEX]) : accessor !== null && isRawValue_default(accessor) ? accessor : !Array.isArray(datum) && (scale === "x" || scale === "y") ? datum : null;
  }
}
var scaledStyleProps = {
  fill: "fill",
  stroke: "stroke",
  fillOpacity: "fill-opacity",
  strokeOpacity: "stroke-opacity",
  opacity: "opacity"
};
var scaledStylePropsKeys = Object.keys(scaledStyleProps);
var oppositeColor = {
  fill: "stroke",
  stroke: "fill"
};
function resolveScaledStyleProps(datum, channels, useScale, plot, defaultColorProp = null) {
  return {
    ...getBaseStylesObject(datum, channels),
    fill: "none",
    stroke: "none",
    ...defaultColorProp && channels[oppositeColor[defaultColorProp]] == null ? { [defaultColorProp]: "currentColor" } : {},
    ...Object.fromEntries(Object.entries(scaledStyleProps).filter(([key2]) => channels[key2] != null).map(([key2, cssAttr]) => [key2, cssAttr, resolveChannel(key2, datum, channels)]).filter(([key2, , value]) => isValid(value) || key2 === "fill" || key2 === "stroke").map(([key2, cssAttr, value]) => {
      if (useScale[key2]) {
        if (value == void 0 && (key2 === "fill" || key2 === "stroke") && plot.options.color.unknown) {
          return [cssAttr, plot.options.color.unknown];
        }
        return [cssAttr, plot.scales[CHANNEL_SCALE[key2]].fn(value)];
      }
      return [cssAttr, value];
    }))
  };
}
function resolveScaledStyles(datum, channels, useScale, plot, defaultColorProp = null) {
  return `${stylePropsToCSS(resolveScaledStyleProps(datum, channels, useScale, plot, defaultColorProp))};${channels.style || ""}`;
}
function stylePropsToCSS(props) {
  return `${Object.entries(props).map(([key2, value]) => `${key2}: ${value}`).join(";")}`;
}
function resolveStyles(plot, datum, channels, defaultColorProp = null, useScale, recomputeChannels = false) {
  const styleProps2 = {
    ...getBaseStylesObject(datum?.datum, channels),
    fill: "none",
    stroke: "none",
    ...defaultColorProp && (channels[oppositeColor[defaultColorProp]] == null || channels[oppositeColor[defaultColorProp]] === "none") ? { [defaultColorProp]: "currentColor" } : {},
    ...Object.fromEntries(Object.entries(scaledStyleProps).filter(([key2]) => channels[key2] != null).map(([key2, cssAttr]) => [
      key2,
      cssAttr,
      recomputeChannels ? resolveChannel(key2, datum?.datum, channels) : datum?.[key2]
    ]).filter(([key2, , value]) => isValid(value) || key2 === "fill" || key2 === "stroke").map(([key2, cssAttr, value]) => {
      if (useScale[key2]) {
        if (value == void 0 && (key2 === "fill" || key2 === "stroke") && plot.options.color.unknown) {
          return [cssAttr, plot.options.color.unknown];
        }
      } else if ((key2 === "fill" || key2 === "stroke") && value === true) {
        return [cssAttr, "currentColor"];
      }
      return [cssAttr, value];
    }))
  };
  if (plot.css) {
    return [null, plot.css(`${stylePropsToCSS(styleProps2)};${channels.style ?? ""}`)];
  } else {
    return [`${stylePropsToCSS(styleProps2)};${channels.style ?? ""}`, null];
  }
}

// node_modules/svelteplot/dist/core/Facet.svelte
Facet[FILENAME] = "node_modules/svelteplot/dist/core/Facet.svelte";
function Facet($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Facet);
  setContext("svelteplot/facet", {
    getTestFacet() {
      return (datum, options) => {
        return (equals(options.fx, null) || strict_equals(resolveChannel("fx", datum, options), $$props.fx)) && (equals(options.fy, null) || strict_equals(resolveChannel("fy", datum, options), $$props.fy));
      };
    },
    getFacetState() {
      return {
        fx: $$props.fx,
        fy: $$props.fy,
        left: $$props.left,
        top: $$props.top,
        right: $$props.right,
        bottom: $$props.bottom,
        topEmpty: $$props.topEmpty,
        bottomEmpty: $$props.bottomEmpty,
        leftEmpty: $$props.leftEmpty,
        rightEmpty: $$props.rightEmpty
      };
    }
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Facet, 58, 0);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Facet = hmr(Facet);
  import.meta.hot.accept((module) => {
    Facet[HMR].update(module.default);
  });
}
var Facet_default = Facet;

// node_modules/svelteplot/dist/helpers/facets.js
function getEmptyFacets(marks, fxValues, fyValues) {
  const facettedMarks = marks.filter((mark) => {
    return mark.options.__firstFacet && mark.data.length > 0 && // has data
    !mark.options.automatic && // not an automatic mark
    (fxValues.length === 1 || mark.options.fx != null) && // uses x faceting
    (fyValues.length === 1 || mark.options.fy != null);
  });
  const facettedData = facettedMarks.map((mark) => mark.data.map((datum) => {
    const fx = resolveChannel("fx", datum, mark.options);
    const fy = resolveChannel("fy", datum, mark.options);
    return {
      fx,
      fy
    };
  })).flat(1);
  const out = /* @__PURE__ */ new Map();
  for (const fx of fxValues) {
    out.set(fx, /* @__PURE__ */ new Map());
    for (const fy of fyValues) {
      let hasFacettedData = fxValues.length === 1 || fyValues.length === 1;
      for (const datum of facettedData) {
        if (datum.fx === fx && datum.fy === fy) {
          hasFacettedData = true;
          break;
        }
      }
      out.get(fx)?.set(fy, !hasFacettedData);
    }
  }
  return out;
}

// node_modules/svelteplot/dist/hooks/usePlot.svelte.js
var PlotState = class {
  #width = tag(
    // Define properties and methods for PlotState as needed
    state(50),
    "PlotState.width"
  );
  get width() {
    return get(this.#width);
  }
  set width(value) {
    set(this.#width, value, true);
  }
  #height = tag(state(50), "PlotState.height");
  get height() {
    return get(this.#height);
  }
  set height(value) {
    set(this.#height, value, true);
  }
  #options = tag(state(proxy({})), "PlotState.options");
  get options() {
    return get(this.#options);
  }
  set options(value) {
    set(this.#options, value, true);
  }
  #facetWidth = tag(state(0), "PlotState.facetWidth");
  get facetWidth() {
    return get(this.#facetWidth);
  }
  set facetWidth(value) {
    set(this.#facetWidth, value, true);
  }
  #facetHeight = tag(state(0), "PlotState.facetHeight");
  get facetHeight() {
    return get(this.#facetHeight);
  }
  set facetHeight(value) {
    set(this.#facetHeight, value, true);
  }
  #plotWidth = tag(state(0), "PlotState.plotWidth");
  get plotWidth() {
    return get(this.#plotWidth);
  }
  set plotWidth(value) {
    set(this.#plotWidth, value, true);
  }
  #plotHeight = tag(state(0), "PlotState.plotHeight");
  get plotHeight() {
    return get(this.#plotHeight);
  }
  set plotHeight(value) {
    set(this.#plotHeight, value, true);
  }
  #scales = tag(state(), "PlotState.scales");
  get scales() {
    return get(this.#scales);
  }
  set scales(value) {
    set(this.#scales, value, true);
  }
  #body = tag(state(), "PlotState.body");
  get body() {
    return get(this.#body);
  }
  set body(value) {
    set(this.#body, value, true);
  }
  #colorSymbolRedundant = tag(state(false), "PlotState.colorSymbolRedundant");
  get colorSymbolRedundant() {
    return get(this.#colorSymbolRedundant);
  }
  set colorSymbolRedundant(value) {
    set(this.#colorSymbolRedundant, value, true);
  }
  #hasFilledDotMarks = tag(state(false), "PlotState.hasFilledDotMarks");
  get hasFilledDotMarks() {
    return get(this.#hasFilledDotMarks);
  }
  set hasFilledDotMarks(value) {
    set(this.#hasFilledDotMarks, value, true);
  }
  #css = tag(state(null), "PlotState.css");
  get css() {
    return get(this.#css);
  }
  set css(value) {
    set(this.#css, value, true);
  }
  constructor(state2) {
    Object.assign(this, state2);
  }
  update(newState) {
    Object.assign(this, newState);
  }
  get publicState() {
    return new PublicPlotState(this);
  }
};
var PublicPlotState = class {
  #plotState;
  constructor(plotState) {
    this.#plotState = plotState;
  }
  get width() {
    return this.#plotState.width;
  }
  get height() {
    return this.#plotState.height;
  }
  get options() {
    return this.#plotState.options;
  }
  get scales() {
    return this.#plotState.scales;
  }
  get plotWidth() {
    return this.#plotState.plotWidth;
  }
  get plotHeight() {
    return this.#plotState.plotHeight;
  }
  get facetWidth() {
    return this.#plotState.facetWidth;
  }
  get facetHeight() {
    return this.#plotState.facetHeight;
  }
  get body() {
    return this.#plotState.body;
  }
  get colorSymbolRedundant() {
    return this.#plotState.colorSymbolRedundant;
  }
  get hasFilledDotMarks() {
    return this.#plotState.hasFilledDotMarks;
  }
  get css() {
    return this.#plotState.css;
  }
};
function setPlot(initialState) {
  return new PlotState({ ...initialState });
}
function usePlot() {
  const { getPlotState } = getContext("svelteplot");
  return getPlotState().publicState;
}

// node_modules/svelteplot/dist/core/FacetGrid.svelte
FacetGrid[FILENAME] = "node_modules/svelteplot/dist/core/FacetGrid.svelte";
var root_2 = add_locations(from_svg(`<g class="facet" fill="currentColor"><rect fill="transparent" pointer-events="all"></rect><!></g>`), FacetGrid[FILENAME], [[71, 8, [[82, 12]]]]);
function FacetGrid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, FacetGrid);
  const { updateDimensions } = getContext("svelteplot");
  const plot = usePlot();
  const useFacetX = tag(user_derived(() => plot.scales.fx.domain.length > 0), "useFacetX");
  const useFacetY = tag(user_derived(() => plot.scales.fy.domain.length > 0), "useFacetY");
  const fxValues = tag(user_derived(() => get(useFacetX) ? plot.scales.fx.domain : [true]), "fxValues");
  const fyValues = tag(user_derived(() => get(useFacetY) ? plot.scales.fy.domain : [true]), "fyValues");
  const emptyFacets = tag(user_derived(() => getEmptyFacets($$props.marks, get(fxValues), get(fyValues))), "emptyFacets");
  const facetXScale = tag(
    user_derived(() => band().paddingOuter(0).paddingInner(get(fxValues).length > 1 ? plot.options.fx?.paddingInner ?? plot.options.fx?.padding ?? 0.1 : 0).domain(get(fxValues)).rangeRound([0, plot.plotWidth])),
    "facetXScale"
  );
  const facetYScale = tag(
    user_derived(() => band().paddingOuter(0).paddingInner(get(fyValues).length > 1 ? plot.options.fy?.paddingInner ?? plot.options.fy?.padding ?? 0.1 : 0).domain(get(fyValues)).rangeRound([0, plot.plotHeight])),
    "facetYScale"
  );
  const facetWidth = tag(user_derived(() => get(useFacetX) ? get(facetXScale).bandwidth() : plot.plotWidth), "facetWidth");
  const facetHeight = tag(user_derived(() => get(useFacetY) ? get(facetYScale).bandwidth() : plot.plotHeight), "facetHeight");
  user_pre_effect(() => {
    updateDimensions(get(facetWidth), get(facetHeight));
  });
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => each(node, 17, () => get(fxValues), index, ($$anchor2, facetX, i) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => each(node_1, 17, () => get(fyValues), index, ($$anchor3, facetY, j) => {
          var g = root_2();
          set_attribute(g, "data-facet-x", i);
          set_attribute(g, "data-facet-y", j);
          let styles;
          var rect = child(g);
          var node_2 = sibling(rect);
          {
            let $0 = user_derived(() => strict_equals(i, get(fxValues).length - 1));
            let $1 = user_derived(() => strict_equals(j, get(fyValues).length - 1));
            let $2 = user_derived(() => !!(strict_equals(i, 0) || get(emptyFacets).get(get(fxValues)[i - 1])?.get(get(facetY))));
            let $3 = user_derived(() => !!(strict_equals(j, 0) || get(emptyFacets).get(get(facetX))?.get(get(fyValues)[j - 1])));
            let $4 = user_derived(() => !!(strict_equals(i, get(fxValues).length - 1) || get(emptyFacets).get(get(fxValues)[i + 1])?.get(get(facetY))));
            let $5 = user_derived(() => !!(strict_equals(j, get(fyValues).length - 1) || get(emptyFacets).get(get(facetX))?.get(get(fyValues)[j + 1])));
            add_svelte_meta(
              () => Facet_default(node_2, {
                get fx() {
                  return get(facetX);
                },
                get fy() {
                  return get(facetY);
                },
                left: strict_equals(i, 0),
                get right() {
                  return get($0);
                },
                top: strict_equals(j, 0),
                get bottom() {
                  return get($1);
                },
                get leftEmpty() {
                  return get($2);
                },
                get topEmpty() {
                  return get($3);
                },
                get rightEmpty() {
                  return get($4);
                },
                get bottomEmpty() {
                  return get($5);
                },
                children: wrap_snippet(FacetGrid, ($$anchor4, $$slotProps) => {
                  var fragment_2 = comment();
                  var node_3 = first_child(fragment_2);
                  add_svelte_meta(() => snippet(node_3, () => $$props.children), "render", FacetGrid, 104, 16);
                  append($$anchor4, fragment_2);
                }),
                $$slots: { default: true }
              }),
              "component",
              FacetGrid,
              89,
              12,
              { componentTag: "Facet" }
            );
          }
          reset(g);
          template_effect(
            ($0, $1, $2) => {
              set_attribute(g, "data-facet", i * get(fyValues).length + j);
              set_attribute(g, "transform", `translate(${$0 ?? ""}, ${$1 ?? ""})`);
              styles = set_style(g, "", styles, $2);
              set_attribute(rect, "x", plot.options.marginLeft);
              set_attribute(rect, "y", plot.options.marginTop);
              set_attribute(rect, "width", get(facetWidth));
              set_attribute(rect, "height", get(facetHeight));
            },
            [
              () => get(useFacetX) ? get(facetXScale)(get(facetX)) : 0,
              () => get(useFacetY) ? get(facetYScale)(get(facetY)) : 0,
              () => ({
                display: get(emptyFacets).get(get(facetX))?.get(get(facetY)) ? "none" : "block"
              })
            ]
          );
          append($$anchor3, g);
        }),
        "each",
        FacetGrid,
        70,
        4
      );
      append($$anchor2, fragment_1);
    }),
    "each",
    FacetGrid,
    69,
    0
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  FacetGrid = hmr(FacetGrid);
  import.meta.hot.accept((module) => {
    FacetGrid[HMR].update(module.default);
  });
}
var FacetGrid_default = FacetGrid;

// node_modules/svelteplot/dist/helpers/mergeDeep.js
function isObject2(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(target, ...sources) {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject2(target) && isObject2(source)) {
    for (const key2 in source) {
      if (isObject2(source[key2])) {
        if (!target[key2]) {
          Object.assign(target, { [key2]: {} });
        } else {
          target[key2] = Object.assign({}, target[key2]);
        }
        mergeDeep(target[key2], source[key2]);
      } else if (source[key2] !== null) {
        Object.assign(target, { [key2]: source[key2] });
      }
    }
  }
  return mergeDeep(target, ...sources);
}

// node_modules/d3-geo/src/math.js
var epsilon4 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees3 = 180 / pi3;
var radians2 = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var hypot = Math.hypot;
var log2 = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt4 = Math.sqrt;
var tan = Math.tan;
function acos2(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi3 : Math.acos(x2);
}
function asin2(x2) {
  return x2 > 1 ? halfPi2 : x2 < -1 ? -halfPi2 : Math.asin(x2);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos2(phi);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi)];
}
function cartesianDot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cartesianCross(a2, b) {
  return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
}
function cartesianAddInPlace(a2, b) {
  a2[0] += b[0], a2[1] += b[1], a2[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt4(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda00;
var phi00;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop2,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos2(phi);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi));
}
function centroidPointCartesian(x2, y2, z) {
  ++W0;
  X0 += (x2 - X0) / W0;
  Y0 += (y2 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos2(phi);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos2(phi), x2 = cosPhi * cos2(lambda), y2 = cosPhi * sin2(lambda), z = sin2(phi), w = atan22(sqrt4((w = y0 * z - z0 * y2) * w + (w = z0 * x2 - x0 * z) * w + (w = x0 * y2 - y0 * x2) * w), x0 * x2 + y0 * y2 + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x2));
  Y1 += w * (y0 + (y0 = y2));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= radians2, phi *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos2(phi), x2 = cosPhi * cos2(lambda), y2 = cosPhi * sin2(lambda), z = sin2(phi), cx = y0 * z - z0 * y2, cy = z0 * x2 - x0 * z, cz = x0 * y2 - y0 * x2, m = hypot(cx, cy, cz), w = asin2(m), v = m && -w / m;
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x2));
  Y1 += w * (y0 + (y0 = y2));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object, centroidStream);
  var x2 = +X2, y2 = +Y2, z = +Z2, m = hypot(x2, y2, z);
  if (m < epsilon22) {
    x2 = X1, y2 = Y1, z = Z1;
    if (W1 < epsilon4) x2 = X0, y2 = Y0, z = Z0;
    m = hypot(x2, y2, z);
    if (m < epsilon22) return [NaN, NaN];
  }
  return [atan22(y2, x2) * degrees3, asin2(z / m) * degrees3];
}

// node_modules/d3-geo/src/compose.js
function compose_default(a2, b) {
  function compose(x2, y2) {
    return x2 = a2(x2, y2), b(x2[0], x2[1]);
  }
  if (a2.invert && b.invert) compose.invert = function(x2, y2) {
    return x2 = b.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos2(phi), x2 = cos2(lambda) * cosPhi, y2 = sin2(lambda) * cosPhi, z = sin2(phi), k2 = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan22(y2 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos2(phi), x2 = cos2(lambda) * cosPhi, y2 = sin2(lambda) * cosPhi, z = sin2(phi), k2 = z * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan22(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate) {
  rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t03, t13) {
  if (!delta) return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction * delta;
  if (t03 == null) {
    t03 = radius + direction * tau3;
    t13 = radius - step / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau3;
  }
  for (var point6, t = t03; direction > 0 ? t > t13 : t < t13; t -= step) {
    point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point6[0], point6[1]);
  }
}
function circleRadius(cosRadius, point6) {
  point6 = cartesian(point6), point6[0] -= cosRadius;
  cartesianNormalizeInPlace(point6);
  var radius = acos2(-point6[1]);
  return ((-point6[2] < 0 ? -radius : radius) + tau3 - epsilon4) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x2, y2, m) {
      line.push([x2, y2, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a2, b) {
  return abs2(a2[0] - b[0]) < epsilon4 && abs2(a2[1] - b[1]) < epsilon4;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point6, points2, other, entry) {
  this.x = point6;
  this.z = points2;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p0 = segment[0], p1 = segment[n2], x2;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon4;
    }
    subject.push(x2 = new Intersection(p0, segment, null, true));
    clip.push(x2.o = new Intersection(p0, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link2(subject);
  link2(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point6;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points2 = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i) stream.point((point6 = points2[i])[0], point6[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points2 = current.p.z;
          for (i = points2.length - 1; i >= 0; --i) stream.point((point6 = points2[i])[0], point6[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points2 = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link2(array2) {
  if (!(n = array2.length)) return;
  var n, i = 0, a2 = array2[0], b;
  while (++i < n) {
    a2.n = b = array2[i];
    b.p = a2;
    a2 = b;
  }
  a2.n = b = array2[0];
  b.p = a2;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point6) {
  return abs2(point6[0]) <= pi3 ? point6[0] : sign2(point6[0]) * ((abs2(point6[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point6) {
  var lambda = longitude(point6), phi = point6[1], sinPhi = sin2(phi), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1) phi = halfPi2 + epsilon4;
  else if (sinPhi === -1) phi = -halfPi2 - epsilon4;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum4.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection3 = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection3);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection3[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon4 || angle2 < epsilon4 && sum4 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point6;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point6(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point6;
      line.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point7;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point7 = segment[i])[0], point7[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi2 - epsilon4 : halfPi2 - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon4 : halfPi2 - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon4) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon4) lambda0 -= sign0 * epsilon4;
        if (abs2(lambda1 - sign1) < epsilon4) lambda1 -= sign1 * epsilon4;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon4 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi2;
    stream.point(-pi3, phi);
    stream.point(0, phi);
    stream.point(pi3, phi);
    stream.point(pi3, 0);
    stream.point(pi3, -phi);
    stream.point(0, -phi);
    stream.point(-pi3, -phi);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi);
  } else if (abs2(from[0] - to[0]) > epsilon4) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius) {
  var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon4;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos2(lambda) * cos2(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point22, v = visible(lambda, phi), c4 = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point22 = intersect(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c4 & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c4;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a2, b, two) {
    var pa = cartesian(a2), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant) return !two && a2;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B2);
    var u = n1xn2, w = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0) return;
    var t = sqrt4(t22), q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda0 = a2[0], lambda1 = b[0], phi0 = a2[1], phi1 = b[1], z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi3) < epsilon4, meridian = polar || delta2 < epsilon4;
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon4 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r) code2 |= 1;
    else if (lambda > r) code2 |= 2;
    if (phi < -r) code2 |= 4;
    else if (phi > r) code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a2, b, x06, y06, x12, y12) {
  var ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
  r = x06 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dx > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dx > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  r = y06 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dy > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dy > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  if (t03 > 0) a2[0] = ax + t03 * dx, a2[1] = ay + t03 * dy;
  if (t13 < 1) b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x12, y12) {
  function visible(x2, y2) {
    return x06 <= x2 && x2 <= x12 && y06 <= y2 && y2 <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a2 = 0, a1 = 0;
    if (from == null || (a2 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a2 === 0 || a2 === 3 ? x06 : x12, a2 > 1 ? y12 : y06);
      while ((a2 = (a2 + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs2(p[0] - x06) < epsilon4 ? direction > 0 ? 0 : 3 : abs2(p[0] - x12) < epsilon4 ? direction > 0 ? 2 : 1 : abs2(p[1] - y06) < epsilon4 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b) {
    return comparePoint(a2.x, b.x);
  }
  function comparePoint(a2, b) {
    var ca = corner(a2, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a2[1] : ca === 1 ? a2[0] - b[0] : ca === 2 ? a2[1] - b[1] : b[0] - a2[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point6(x2, y2) {
      if (visible(x2, y2)) activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point7 = ring2[j], b0 = point7[0], b1 = point7[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x06 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x06 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point6;
      if (v_) activeStream.lineEnd();
    }
    function linePoint(x2, y2) {
      var v = visible(x2, y2);
      if (polygon) ring.push([x2, y2]);
      if (first) {
        x__ = x2, y__ = y2, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v && v_) activeStream.point(x2, y2);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (line_default2(a2, b, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y2 = range(y06, y12 - epsilon4, dy).concat(y12);
  return function(x2) {
    return y2.map(function(y3) {
      return [x2, y3];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x2 = range(x06, x12 - epsilon4, dx).concat(x12);
  return function(y2) {
    return x2.map(function(x3) {
      return [x3, y2];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x3) {
      return abs2(x3 % DX) > epsilon4;
    }).map(x2)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y3) {
      return abs2(y3 % DY) > epsilon4;
    }).map(y2));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X03).concat(
          Y3(Y13).slice(1),
          X3(X13).reverse().slice(1),
          Y3(Y03).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length) return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13) _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13) _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length) return [[x06, y06], [x12, y12]];
    x06 = +_[0][0], x12 = +_[1][0];
    y06 = +_[0][1], y12 = +_[1][1];
    if (x06 > x12) _ = x06, x06 = x12, x12 = _;
    if (y06 > y12) _ = y06, y06 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x2 = graticuleX(y06, y12, 90);
    y2 = graticuleY(x06, x12, precision);
    X3 = graticuleX(Y03, Y13, 90);
    Y3 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon4], [180, 90 - epsilon4]]).extentMinor([[-180, -80 - epsilon4], [180, 80 + epsilon4]]);
}

// node_modules/d3-geo/src/identity.js
var identity_default3 = (x2) => x2;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart;
    areaStream2.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area = areaSum2 / 2;
    areaSum2 = new Adder();
    return area;
  }
};
function areaRingStart() {
  areaStream2.point = areaPointFirst;
}
function areaPointFirst(x2, y2) {
  areaStream2.point = areaPoint;
  x00 = x02 = x2, y00 = y02 = y2;
}
function areaPoint(x2, y2) {
  areaRingSum2.add(y02 * x2 - x02 * y2);
  x02 = x2, y02 = y2;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default2 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x03) x03 = x2;
  if (x2 > x1) x1 = x2;
  if (y2 < y03) y03 = y2;
  if (y2 > y1) y1 = y2;
}
var bounds_default = boundsStream;

// node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint2(x2, y2) {
  X02 += x2;
  Y02 += y2;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y2) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x2, y04 = y2);
}
function centroidPointLine(x2, y2) {
  var dx = x2 - x04, dy = y2 - y04, z = sqrt4(dx * dx + dy * dy);
  X12 += z * (x04 + x2) / 2;
  Y12 += z * (y04 + y2) / 2;
  Z12 += z;
  centroidPoint2(x04 = x2, y04 = y2);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x2, y2) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x2, y002 = y04 = y2);
}
function centroidPointRing(x2, y2) {
  var dx = x2 - x04, dy = y2 - y04, z = sqrt4(dx * dx + dy * dy);
  X12 += z * (x04 + x2) / 2;
  Y12 += z * (y04 + y2) / 2;
  Z12 += z;
  z = y04 * x2 - x04 * y2;
  X22 += z * (x04 + x2);
  Y22 += z * (y04 + y2);
  Z22 += z * 3;
  centroidPoint2(x04 = x2, y04 = y2);
}
var centroid_default2 = centroidStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new Adder();
    return length;
  }
};
function lengthPointFirst(x2, y2) {
  lengthStream.point = lengthPoint;
  x003 = x05 = x2, y003 = y05 = y2;
}
function lengthPoint(x2, y2) {
  x05 -= x2, y05 -= y2;
  lengthSum.add(sqrt4(x05 * x05 + y05 * y05));
  x05 = x2, y05 = y2;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append3 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0) this._ += "Z";
    this._point = NaN;
  }
  point(x2, y2) {
    switch (this._point) {
      case 0: {
        this._append`M${x2},${y2}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x2},${y2}`;
        break;
      }
      default: {
        this._append`M${x2},${y2}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s2 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s2;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append3(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0)) throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15) return append3;
  if (d !== cacheDigits) {
    const k2 = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append4(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection2, context) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path2(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object) {
    stream_default(object, projectionStream(area_default2));
    return area_default2.result();
  };
  path2.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path2.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path2.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path2.projection = function(_) {
    if (!arguments.length) return projection2;
    projectionStream = _ == null ? (projection2 = null, identity_default3) : (projection2 = _).stream;
    return path2;
  };
  path2.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString(digits)) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path2;
  };
  path2.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) digits = null;
    else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    if (context === null) contextStream = new PathString(digits);
    return path2;
  };
  return path2.projection(projection2).digits(digits).context(context);
}

// node_modules/d3-geo/src/transform.js
function transform_default(methods) {
  return {
    stream: transformer4(methods)
  };
}
function transformer4(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key2 in methods) s2[key2] = methods[key2];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object, projection2.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object) {
  return fit(projection2, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x2 = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y2 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object);
}
function fitSize(projection2, size, object) {
  return fitExtent(projection2, [[0, 0], size], object);
}
function fitWidth(projection2, width, object) {
  return fit(projection2, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x2 = (w - k2 * (b[1][0] + b[0][0])) / 2, y2 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object);
}
function fitHeight(projection2, height, object) {
  return fit(projection2, function(b) {
    var h = +height, k2 = h / (b[1][1] - b[0][1]), x2 = -k2 * b[0][0], y2 = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer4({
    point: function(x2, y2) {
      x2 = project(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x06, y06, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b = b0 + b1, c4 = c0 + c1, m = sqrt4(a2 * a2 + b * b + c4 * c4), phi2 = asin2(c4 /= m), lambda2 = abs2(abs2(c4) - 1) < epsilon4 || abs2(lambda0 - lambda1) < epsilon4 ? (lambda0 + lambda1) / 2 : atan22(b, a2), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x06, dy2 = y2 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda0, a0, b0, c0, x2, y2, lambda2, a2 /= m, b /= m, c4, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a2, b, c4, x12, y12, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda002, x004, y004, a00, b00, c00, lambda0, x06, y06, a0, b0, c0;
    var resampleStream = {
      point: point6,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point6(x2, y2) {
      x2 = project(x2, y2);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c4 = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x06, y06, lambda0, a0, b0, c0, x06 = p[0], y06 = p[1], lambda0 = lambda, a0 = c4[0], b0 = c4[1], c0 = c4[2], maxDepth, stream);
      stream.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point6;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda002 = lambda, phi), x004 = x06, y004 = y06, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda0, a0, b0, c0, x004, y004, lambda002, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer4({
  point: function(x2, y2) {
    this.stream.point(x2 * radians2, y2 * radians2);
  }
});
function transformRotate(rotate) {
  return transformer4({
    point: function(x2, y2) {
      var r = rotate(x2, y2);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [dx + k2 * x2, dy - k2 * y2];
  }
  transform.invert = function(x2, y2) {
    return [(x2 - dx) / k2 * sx, (dy - y2) / k2 * sy];
  };
  return transform;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k2, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a2 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [a2 * x2 - b * y2 + dx, dy - b * x2 - a2 * y2];
  }
  transform.invert = function(x2, y2) {
    return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
  };
  return transform;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x2 = 480, y2 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection2(point6) {
    return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
  }
  function invert2(point6) {
    point6 = projectRotateTransform.invert(point6[0], point6[1]);
    return point6 && [point6[0] * degrees3, point6[1] * degrees3];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset2()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset2()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset2()) : theta * degrees3;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset2()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k2 = +_, recenter()) : k2;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x2 = +_[0], y2 = +_[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi * degrees3];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset2()) : sqrt4(delta2);
  };
  projection2.fitExtent = function(extent2, object) {
    return fitExtent(projection2, extent2, object);
  };
  projection2.fitSize = function(size, object) {
    return fitSize(projection2, size, object);
  };
  projection2.fitWidth = function(width, object) {
    return fitWidth(projection2, width, object);
  };
  projection2.fitHeight = function(height, object) {
    return fitHeight(projection2, height, object);
  };
  function recenter() {
    var center = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform = scaleTranslateRotate(k2, x2 - center[0], y2 - center[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform);
    projectRotateTransform = compose_default(rotate, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset2();
  }
  function reset2() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert2;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);
  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians2, phi1 = _[1] * radians2) : [phi0 * degrees3, phi1 * degrees3];
  };
  return p;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin2(phi) / cosPhi0];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi0, asin2(y2 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y12) {
  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;
  if (abs2(n) < epsilon4) return cylindricalEqualAreaRaw(y06);
  var c4 = 1 + sy0 * (2 * n - sy0), r0 = sqrt4(c4) / n;
  function project(x2, y2) {
    var r = sqrt4(c4 - 2 * n * sin2(y2)) / n;
    return [r * sin2(x2 *= n), r0 - r * cos2(x2)];
  }
  project.invert = function(x2, y2) {
    var r0y = r0 - y2, l = atan22(x2, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x2) * sign2(r0y);
    return [l / n, asin2((c4 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x2, y2) {
      var i = -1;
      while (++i < n) streams[i].point(x2, y2);
    },
    sphere: function() {
      var i = -1;
      while (++i < n) streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n) streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x2, y2) {
    point6 = [x2, y2];
  } };
  function albersUsa(coordinates) {
    var x2 = coordinates[0], y2 = coordinates[1];
    return point6 = null, (lower48Point.point(x2, y2), point6) || (alaskaPoint.point(x2, y2), point6) || (hawaiiPoint.point(x2, y2), point6);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x2 = (coordinates[0] - t[0]) / k2, y2 = (coordinates[1] - t[1]) / k2;
    return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset2();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k2 = lower48.scale(), x2 = +_[0], y2 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x2 - 0.455 * k2, y2 - 0.238 * k2], [x2 + 0.455 * k2, y2 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x2 - 0.307 * k2, y2 + 0.201 * k2]).clipExtent([[x2 - 0.425 * k2 + epsilon4, y2 + 0.12 * k2 + epsilon4], [x2 - 0.214 * k2 - epsilon4, y2 + 0.234 * k2 - epsilon4]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x2 - 0.205 * k2, y2 + 0.212 * k2]).clipExtent([[x2 - 0.214 * k2 + epsilon4, y2 + 0.166 * k2 + epsilon4], [x2 - 0.115 * k2 - epsilon4, y2 + 0.234 * k2 - epsilon4]]).stream(pointStream);
    return reset2();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset2() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale) {
  return function(x2, y2) {
    var cx = cos2(x2), cy = cos2(y2), k2 = scale(cx * cy);
    if (k2 === Infinity) return [2, 0];
    return [
      k2 * cy * sin2(x2),
      k2 * sin2(y2)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y2) {
    var z = sqrt4(x2 * x2 + y2 * y2), c4 = angle2(z), sc = sin2(c4), cc = cos2(c4);
    return [
      atan22(x2 * sc, z * cc),
      asin2(z && y2 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt4(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c4) {
  return (c4 = acos2(c4)) && c4 / sin2(c4);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log2(tan((halfPi2 + phi) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project) {
  var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x06 = null, y06, x12, y12;
  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };
  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };
  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };
  m.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  function reclip() {
    var k2 = pi3 * scale(), t = m(rotation_default(m.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x06), y06], [Math.min(t[0] + k2, x12), y12]] : [[x06, Math.max(t[1] - k2, y06)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y2) {
  return tan((halfPi2 + y2) / 2);
}
function conicConformalRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log2(cy0 / cos2(y12)) / log2(tany(y12) / tany(y06)), f = cy0 * pow2(tany(y06), n) / n;
  if (!n) return mercatorRaw;
  function project(x2, y2) {
    if (f > 0) {
      if (y2 < -halfPi2 + epsilon4) y2 = -halfPi2 + epsilon4;
    } else {
      if (y2 > halfPi2 - epsilon4) y2 = halfPi2 - epsilon4;
    }
    var r = f / pow2(tany(y2), n);
    return [r * sin2(n * x2), f - r * cos2(n * x2)];
  }
  project.invert = function(x2, y2) {
    var fy = f - y2, r = sign2(n) * sqrt4(x2 * x2 + fy * fy), l = atan22(x2, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x2) * sign2(fy);
    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;
  if (abs2(n) < epsilon4) return equirectangularRaw;
  function project(x2, y2) {
    var gy = g - y2, nx = n * x2;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x2, y2) {
    var gy = g - y2, l = atan22(x2, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x2) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt4(x2 * x2 + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt4(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l = asin2(M * sin2(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x2, y2) {
  var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon22) break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x2, y2) {
  var cy = cos2(y2), k2 = cos2(x2) * cy;
  return [cy * sin2(x2) / k2, sin2(y2) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi = y2, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y2) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon4 && --i > 0);
  return [
    x2 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
    phi
  ];
};

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x2, y2) {
  return [cos2(y2) * sin2(x2), sin2(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon4);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x2, y2) {
  var cy = cos2(y2), k2 = 1 + cos2(x2) * cy;
  return [cy * sin2(x2) / k2, sin2(y2) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log2(tan((halfPi2 + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi2];
};
function transverseMercator_default() {
  var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };
  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}

// node_modules/svelteplot/dist/helpers/projection.js
var identity6 = constant2({ stream: (stream) => stream });
var defaultAspectRatio = 0.618;
function createProjection({ projOptions, inset: globalInset = 2, insetTop = globalInset, insetRight = globalInset, insetBottom = globalInset, insetLeft = globalInset } = {}, dimensions) {
  if (projOptions == null)
    return;
  if (typeof projOptions.stream === "function")
    return projOptions;
  let options;
  let domain;
  let clip = "frame";
  if (isObject(projOptions)) {
    let inset;
    ({
      type: projOptions,
      domain,
      inset,
      insetTop = inset !== void 0 ? inset : insetTop,
      insetRight = inset !== void 0 ? inset : insetRight,
      insetBottom = inset !== void 0 ? inset : insetBottom,
      insetLeft = inset !== void 0 ? inset : insetLeft,
      clip = clip,
      ...options
    } = projOptions);
    if (projOptions == null)
      return;
  }
  let aspectRatio = defaultAspectRatio;
  const projFactory = projOptions;
  const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
  const dx = width - marginLeft - marginRight - insetLeft - insetRight;
  const dy = height - marginTop - marginBottom - insetTop - insetBottom;
  const projInstance = projFactory?.({ width: dx, height: dy, clip, ...options });
  if (projInstance == null)
    return;
  clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
  let tx = marginLeft + insetLeft;
  let ty = marginTop + insetTop;
  let transform;
  let invertTransform = (d) => d;
  if (domain != null && dx > 0 && dy > 0) {
    const [[x06, y06], [x12, y12]] = path_default(projInstance).bounds(domain);
    const k2 = Math.min(dx / (x12 - x06), dy / (y12 - y06));
    aspectRatio = (y12 - y06) / (x12 - x06);
    if (k2 > 0) {
      tx -= (k2 * (x06 + x12) - dx) / 2;
      ty -= (k2 * (y06 + y12) - dy) / 2;
      transform = transform_default({
        point(x2, y2) {
          this.stream.point(x2 * k2 + tx, y2 * k2 + ty);
        }
      });
      invertTransform = ([x2, y2]) => [(x2 - tx) / k2, (y2 - ty) / k2];
    } else {
      console.warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
    }
  } else if (domain != null) {
    console.warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
  }
  transform ??= tx === 0 && ty === 0 ? identity6() : transform_default({
    point(x2, y2) {
      this.stream.point(x2 + tx, y2 + ty);
    }
  });
  invertTransform ??= ([x2, y2]) => [x2 - tx, y2 - ty];
  return {
    aspectRatio,
    invert([x2, y2]) {
      return projInstance.invert(invertTransform([x2, y2]));
    },
    stream: (s2) => projInstance.stream(transform.stream(clip(s2)))
  };
}
function maybePostClip(clip, x12, y12, x2, y2) {
  if (clip === false || clip == null || typeof clip === "number")
    return (s2) => s2;
  if (clip === true)
    clip = "frame";
  switch (`${clip}`.toLowerCase()) {
    case "frame":
      return clipRectangle(x12, y12, x2, y2);
    default:
      throw new Error(`unknown projection clip type: ${clip}`);
  }
}

// node_modules/svelteplot/dist/helpers/time.js
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var tickIntervals = [
  ["millisecond", 1],
  ["2 milliseconds", 2],
  ["5 milliseconds", 5],
  ["10 milliseconds", 10],
  ["20 milliseconds", 20],
  ["50 milliseconds", 50],
  ["100 milliseconds", 100],
  ["200 milliseconds", 200],
  ["500 milliseconds", 500],
  ["second", durationSecond2],
  ["5 seconds", 5 * durationSecond2],
  ["15 seconds", 15 * durationSecond2],
  ["30 seconds", 30 * durationSecond2],
  ["minute", durationMinute2],
  ["5 minutes", 5 * durationMinute2],
  ["15 minutes", 15 * durationMinute2],
  ["30 minutes", 30 * durationMinute2],
  ["hour", durationHour2],
  ["3 hours", 3 * durationHour2],
  ["6 hours", 6 * durationHour2],
  ["12 hours", 12 * durationHour2],
  ["day", durationDay2],
  ["2 days", 2 * durationDay2],
  ["week", durationWeek2],
  ["2 weeks", 2 * durationWeek2],
  // https://github.com/d3/d3-time/issues/46
  ["month", durationMonth2],
  ["3 months", 3 * durationMonth2],
  ["6 months", 6 * durationMonth2],
  // https://github.com/d3/d3-time/issues/46
  ["year", durationYear2],
  ["2 years", 2 * durationYear2],
  ["5 years", 5 * durationYear2],
  ["10 years", 10 * durationYear2],
  ["20 years", 20 * durationYear2],
  ["50 years", 50 * durationYear2],
  ["100 years", 100 * durationYear2]
  // TODO generalize to longer time scales
];
var durations = /* @__PURE__ */ new Map([
  ["second", durationSecond2],
  ["minute", durationMinute2],
  ["hour", durationHour2],
  ["day", durationDay2],
  ["monday", durationWeek2],
  ["tuesday", durationWeek2],
  ["wednesday", durationWeek2],
  ["thursday", durationWeek2],
  ["friday", durationWeek2],
  ["saturday", durationWeek2],
  ["sunday", durationWeek2],
  ["week", durationWeek2],
  ["month", durationMonth2],
  ["year", durationYear2]
]);
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  // https://github.com/d3/d3-time/issues/62
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday],
  ["week", timeSunday],
  ["month", timeMonth],
  ["year", timeYear]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", unixDay],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday],
  ["week", utcSunday],
  ["month", utcMonth],
  ["year", utcYear]
]);
var intervalDuration = /* @__PURE__ */ Symbol("intervalDuration");
var intervalType = /* @__PURE__ */ Symbol("intervalType");
for (const [name, interval2] of timeIntervals) {
  interval2[intervalDuration] = durations.get(name);
  interval2[intervalType] = "time";
}
for (const [name, interval2] of utcIntervals) {
  interval2[intervalDuration] = durations.get(name);
  interval2[intervalType] = "utc";
}
var utcFormatIntervals = [
  ["year", utcYear, "utc"],
  ["month", utcMonth, "utc"],
  ["day", unixDay, "utc", 6 * durationMonth2],
  ["hour", utcHour, "utc", 3 * durationDay2],
  ["minute", utcMinute, "utc", 6 * durationHour2],
  ["second", second, "utc", 30 * durationMinute2]
];
var timeFormatIntervals = [
  ["year", timeYear, "time"],
  ["month", timeMonth, "time"],
  ["day", timeDay, "time", 6 * durationMonth2],
  ["hour", timeHour, "time", 3 * durationDay2],
  ["minute", timeMinute, "time", 6 * durationHour2],
  ["second", second, "time", 30 * durationMinute2]
];
var formatIntervals = [
  utcFormatIntervals[0],
  timeFormatIntervals[0],
  utcFormatIntervals[1],
  timeFormatIntervals[1],
  utcFormatIntervals[2],
  timeFormatIntervals[2],
  // Below day, local time typically has an hourly offset from UTC and hence the
  // two are aligned and indistinguishable; therefore, we only consider UTC, and
  // we dont consider these if the domain only has a single value.
  ...utcFormatIntervals.slice(3)
];
function parseTimeInterval(input) {
  let name = `${input}`.toLowerCase();
  if (name.endsWith("s"))
    name = name.slice(0, -1);
  let period = 1;
  const match = /^(\d+)\s+/.exec(name);
  if (match) {
    name = name.slice(match[0].length);
    period = +match[1];
  }
  switch (name) {
    case "quarter":
      name = "month";
      period *= 3;
      break;
    case "half":
      name = "month";
      period *= 6;
      break;
  }
  let interval2 = utcIntervals.get(name);
  if (!interval2)
    throw new Error(`unknown interval: ${input}`);
  if (period > 1 && !interval2.every)
    throw new Error(`non-periodic interval: ${name}`);
  return [name, period];
}
function maybeTimeInterval(input) {
  return asInterval(parseTimeInterval(input), "time");
}
function asInterval([name, period], type) {
  let interval2 = (type === "time" ? timeIntervals : utcIntervals).get(name);
  if (period > 1) {
    interval2 = interval2.every(period);
    interval2[intervalDuration] = durations.get(name) * period;
    interval2[intervalType] = type;
  }
  return interval2;
}

// node_modules/svelteplot/dist/helpers/autoTicks.js
function maybeInterval(interval2) {
  if (interval2 == null)
    return;
  if (typeof interval2 === "number") {
    if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2))
      interval2 = -1 / interval2;
    const n = Math.abs(interval2);
    return interval2 < 0 ? {
      floor: (d) => Math.floor(d * n) / n,
      round: (d) => Math.round(d * n) / n,
      offset: (d) => (d * n + 1) / n,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo * n), hi * n).map((x2) => x2 / n)
    } : {
      floor: (d) => Math.floor(d / n) * n,
      round: (d) => Math.round(d / n) * n,
      offset: (d) => d + n,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x2) => x2 * n)
    };
  }
  if (typeof interval2 === "string")
    return maybeTimeInterval(interval2);
  if (typeof interval2.floor !== "function")
    throw new Error("invalid interval; missing floor method");
  if (typeof interval2.offset !== "function")
    throw new Error("invalid interval; missing offset method");
  return interval2;
}
function autoTicks(type, ticks2, interval2, domain, scaleFn, count2) {
  if (ticks2)
    return ticks2;
  if (interval2) {
    const [lo, hi] = extent(domain);
    if (lo == null || hi == null)
      return [];
    const I = maybeInterval(interval2);
    return I.range(lo, I.offset(hi)).filter((d) => d >= lo && d <= hi);
  }
  return typeof scaleFn.ticks === "function" ? scaleFn.ticks(count2) : [];
}

// node_modules/d3-random/src/defaultSource.js
var defaultSource_default = Math.random;

// node_modules/d3-random/src/uniform.js
var uniform_default = (function sourceRandomUniform(source) {
  function randomUniform(min3, max3) {
    min3 = min3 == null ? 0 : +min3;
    max3 = max3 == null ? 1 : +max3;
    if (arguments.length === 1) max3 = min3, min3 = 0;
    else max3 -= min3;
    return function() {
      return source() * max3 + min3;
    };
  }
  randomUniform.source = sourceRandomUniform;
  return randomUniform;
})(defaultSource_default);

// node_modules/d3-random/src/int.js
var int_default = (function sourceRandomInt(source) {
  function randomInt2(min3, max3) {
    if (arguments.length < 2) max3 = min3, min3 = 0;
    min3 = Math.floor(min3);
    max3 = Math.floor(max3) - min3;
    return function() {
      return Math.floor(source() * max3 + min3);
    };
  }
  randomInt2.source = sourceRandomInt;
  return randomInt2;
})(defaultSource_default);

// node_modules/d3-random/src/normal.js
var normal_default = (function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x2, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y2;
      if (x2 != null) y2 = x2, x2 = null;
      else do {
        x2 = source() * 2 - 1;
        y2 = source() * 2 - 1;
        r = x2 * x2 + y2 * y2;
      } while (!r || r > 1);
      return mu + sigma * y2 * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
  randomNormal.source = sourceRandomNormal;
  return randomNormal;
})(defaultSource_default);

// node_modules/d3-random/src/logNormal.js
var logNormal_default = (function sourceRandomLogNormal(source) {
  var N = normal_default.source(source);
  function randomLogNormal() {
    var randomNormal = N.apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }
  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
})(defaultSource_default);

// node_modules/d3-random/src/irwinHall.js
var irwinHall_default = (function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    if ((n = +n) <= 0) return () => 0;
    return function() {
      for (var sum4 = 0, i = n; i > 1; --i) sum4 += source();
      return sum4 + i * source();
    };
  }
  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
})(defaultSource_default);

// node_modules/d3-random/src/bates.js
var bates_default = (function sourceRandomBates(source) {
  var I = irwinHall_default.source(source);
  function randomBates(n) {
    if ((n = +n) === 0) return source;
    var randomIrwinHall = I(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }
  randomBates.source = sourceRandomBates;
  return randomBates;
})(defaultSource_default);

// node_modules/d3-random/src/exponential.js
var exponential_default = (function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log1p(-source()) / lambda;
    };
  }
  randomExponential.source = sourceRandomExponential;
  return randomExponential;
})(defaultSource_default);

// node_modules/d3-random/src/pareto.js
var pareto_default = (function sourceRandomPareto(source) {
  function randomPareto(alpha) {
    if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
    alpha = 1 / -alpha;
    return function() {
      return Math.pow(1 - source(), alpha);
    };
  }
  randomPareto.source = sourceRandomPareto;
  return randomPareto;
})(defaultSource_default);

// node_modules/d3-random/src/bernoulli.js
var bernoulli_default = (function sourceRandomBernoulli(source) {
  function randomBernoulli(p) {
    if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
    return function() {
      return Math.floor(source() + p);
    };
  }
  randomBernoulli.source = sourceRandomBernoulli;
  return randomBernoulli;
})(defaultSource_default);

// node_modules/d3-random/src/geometric.js
var geometric_default = (function sourceRandomGeometric(source) {
  function randomGeometric(p) {
    if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
    if (p === 0) return () => Infinity;
    if (p === 1) return () => 1;
    p = Math.log1p(-p);
    return function() {
      return 1 + Math.floor(Math.log1p(-source()) / p);
    };
  }
  randomGeometric.source = sourceRandomGeometric;
  return randomGeometric;
})(defaultSource_default);

// node_modules/d3-random/src/gamma.js
var gamma_default = (function sourceRandomGamma(source) {
  var randomNormal = normal_default.source(source)();
  function randomGamma(k2, theta) {
    if ((k2 = +k2) < 0) throw new RangeError("invalid k");
    if (k2 === 0) return () => 0;
    theta = theta == null ? 1 : +theta;
    if (k2 === 1) return () => -Math.log1p(-source()) * theta;
    var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c4 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;
    return function() {
      do {
        do {
          var x2 = randomNormal(), v = 1 + c4 * x2;
        } while (v <= 0);
        v *= v * v;
        var u = 1 - source();
      } while (u >= 1 - 0.0331 * x2 * x2 * x2 * x2 && Math.log(u) >= 0.5 * x2 * x2 + d * (1 - v + Math.log(v)));
      return d * v * multiplier() * theta;
    };
  }
  randomGamma.source = sourceRandomGamma;
  return randomGamma;
})(defaultSource_default);

// node_modules/d3-random/src/beta.js
var beta_default = (function sourceRandomBeta(source) {
  var G = gamma_default.source(source);
  function randomBeta(alpha, beta) {
    var X3 = G(alpha), Y3 = G(beta);
    return function() {
      var x2 = X3();
      return x2 === 0 ? 0 : x2 / (x2 + Y3());
    };
  }
  randomBeta.source = sourceRandomBeta;
  return randomBeta;
})(defaultSource_default);

// node_modules/d3-random/src/binomial.js
var binomial_default = (function sourceRandomBinomial(source) {
  var G = geometric_default.source(source), B2 = beta_default.source(source);
  function randomBinomial(n, p) {
    n = +n;
    if ((p = +p) >= 1) return () => n;
    if (p <= 0) return () => 0;
    return function() {
      var acc = 0, nn = n, pp = p;
      while (nn * pp > 16 && nn * (1 - pp) > 16) {
        var i = Math.floor((nn + 1) * pp), y2 = B2(i, nn - i + 1)();
        if (y2 <= pp) {
          acc += i;
          nn -= i;
          pp = (pp - y2) / (1 - y2);
        } else {
          nn = i - 1;
          pp /= y2;
        }
      }
      var sign3 = pp < 0.5, pFinal = sign3 ? pp : 1 - pp, g = G(pFinal);
      for (var s2 = g(), k2 = 0; s2 <= nn; ++k2) s2 += g();
      return acc + (sign3 ? k2 : nn - k2);
    };
  }
  randomBinomial.source = sourceRandomBinomial;
  return randomBinomial;
})(defaultSource_default);

// node_modules/d3-random/src/weibull.js
var weibull_default = (function sourceRandomWeibull(source) {
  function randomWeibull(k2, a2, b) {
    var outerFunc;
    if ((k2 = +k2) === 0) {
      outerFunc = (x2) => -Math.log(x2);
    } else {
      k2 = 1 / k2;
      outerFunc = (x2) => Math.pow(x2, k2);
    }
    a2 = a2 == null ? 0 : +a2;
    b = b == null ? 1 : +b;
    return function() {
      return a2 + b * outerFunc(-Math.log1p(-source()));
    };
  }
  randomWeibull.source = sourceRandomWeibull;
  return randomWeibull;
})(defaultSource_default);

// node_modules/d3-random/src/cauchy.js
var cauchy_default = (function sourceRandomCauchy(source) {
  function randomCauchy(a2, b) {
    a2 = a2 == null ? 0 : +a2;
    b = b == null ? 1 : +b;
    return function() {
      return a2 + b * Math.tan(Math.PI * source());
    };
  }
  randomCauchy.source = sourceRandomCauchy;
  return randomCauchy;
})(defaultSource_default);

// node_modules/d3-random/src/logistic.js
var logistic_default = (function sourceRandomLogistic(source) {
  function randomLogistic(a2, b) {
    a2 = a2 == null ? 0 : +a2;
    b = b == null ? 1 : +b;
    return function() {
      var u = source();
      return a2 + b * Math.log(u / (1 - u));
    };
  }
  randomLogistic.source = sourceRandomLogistic;
  return randomLogistic;
})(defaultSource_default);

// node_modules/d3-random/src/poisson.js
var poisson_default = (function sourceRandomPoisson(source) {
  var G = gamma_default.source(source), B2 = binomial_default.source(source);
  function randomPoisson(lambda) {
    return function() {
      var acc = 0, l = lambda;
      while (l > 16) {
        var n = Math.floor(0.875 * l), t = G(n)();
        if (t > l) return acc + B2(n - 1, l / t)();
        acc += n;
        l -= t;
      }
      for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2) s2 -= Math.log1p(-source());
      return acc + k2;
    };
  }
  randomPoisson.source = sourceRandomPoisson;
  return randomPoisson;
})(defaultSource_default);

// node_modules/d3-random/src/lcg.js
var mul = 1664525;
var inc = 1013904223;
var eps = 1 / 4294967296;
function lcg(seed = Math.random()) {
  let state2 = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
  return () => (state2 = mul * state2 + inc | 0, eps * (state2 >>> 0));
}

// node_modules/svelteplot/dist/transforms/sort.js
var SORT_KEY = /* @__PURE__ */ Symbol("sortKey");
var IS_SORTED = /* @__PURE__ */ Symbol("isSorted");
function sort2({ data, ...channels }, options = {}) {
  if (!Array.isArray(data))
    return { data, ...channels };
  if (channels.sort) {
    const { sort: sort3 } = channels;
    if (isDataRecord_default(sort3) && typeof sort3.channel === "string" && sort3.channel.charAt(0) === "-") {
      sort3.channel = sort3.channel.substring(1);
      sort3.order = "descending";
    }
    const isComparator = typeof channels.sort === "function" && channels.sort.length !== 1;
    return {
      data: isComparator ? data.toSorted(channels.sort) : data.map((d) => ({
        ...d,
        [SORT_KEY]: resolveChannel("sort", d, { ...channels, sort: sort3 })
      })).map((d) => ({
        ...d,
        [SORT_KEY]: typeof d[SORT_KEY] === "number" && !Number.isFinite(d[SORT_KEY]) ? Number.POSITIVE_INFINITY : d[SORT_KEY]
      })).toSorted((a2, b) => (typeof a2[SORT_KEY] === "string" && typeof b[SORT_KEY] === "string" ? a2[SORT_KEY].localeCompare(b[SORT_KEY]) : a2[SORT_KEY] > b[SORT_KEY] ? 1 : a2[SORT_KEY] < b[SORT_KEY] ? -1 : 0) * (options.reverse || isDataRecord_default(sort3) && sort3?.order === "descending" ? -1 : 1)).map(({ [SORT_KEY]: a2, ...rest2 }) => rest2),
      ...channels,
      [IS_SORTED]: sort3,
      // set the sort channel to null to disable the implicit alphabetical
      // ordering of ordinal domains, and also to avoid double sorting in case
      // this transform is used "outside" a mark
      sort: null
    };
  }
  return {
    data,
    ...channels
  };
}
function shuffle({ data, ...channels }, options = {}) {
  const random2 = lcg(options.seed);
  const shuffle3 = shuffler(random2);
  return {
    data: shuffle3([...data]),
    ...channels,
    // set the sort channel to null to disable the implicit
    // alphabetical ordering of ordinal domains
    sort: null,
    [IS_SORTED]: true
  };
}
function reverse2({ data, ...channels }) {
  return {
    data: data.toReversed(),
    ...channels,
    // set the sort channel to null to disable the implicit
    // alphabetical ordering of ordinal domains
    sort: null,
    [IS_SORTED]: true
  };
}

// node_modules/svelteplot/dist/helpers/scales.js
function computeScales(plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, marks, plotDefaults) {
  const x2 = createScale("x", plotOptions.x, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const y2 = createScale("y", plotOptions.y, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const r = createScale("r", plotOptions.r, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const color2 = createScale("color", plotOptions.color, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const opacity = createScale("opacity", plotOptions.opacity, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const length = createScale("length", plotOptions.length, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const symbol = createScale("symbol", plotOptions.symbol, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const fx = createScale("fx", plotOptions.fx, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const fy = createScale("fy", plotOptions.fy, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults);
  const projection2 = plotOptions.projection ? createProjection({ projOptions: plotOptions.projection, inset: plotOptions.inset }, {
    width: plotWidth,
    height: plotHeight,
    marginBottom: plotOptions.marginBottom,
    marginLeft: plotOptions.marginLeft,
    marginRight: plotOptions.marginRight,
    marginTop: plotOptions.marginTop
  }) : null;
  return { x: x2, y: y2, r, color: color2, opacity, length, symbol, fx, fy, projection: projection2 };
}
function createScale(name, scaleOptions, marks, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults) {
  if (!plotOptions.implicitScales && !scaleOptions.scale) {
    const fn2 = name === "color" ? () => "currentColor" : () => 0;
    fn2.range = name === "color" ? () => ["currentColor"] : () => [0];
    return { type: "linear", domain: [0], range: [0], fn: fn2, skip: /* @__PURE__ */ new Map(), isDummy: true };
  }
  const dataValues = /* @__PURE__ */ new Set();
  const allDataValues = [];
  const markTypes = /* @__PURE__ */ new Set();
  const skip = /* @__PURE__ */ new Map();
  let manualActiveMarks = 0;
  const propNames = /* @__PURE__ */ new Set();
  const uniqueScaleProps = /* @__PURE__ */ new Set();
  let sortOrdinalDomain = plotOptions.sortOrdinalDomains ?? true;
  for (const mark of marks) {
    if ((name === "x" || name === "y") && mark.options[IS_SORTED] != void 0) {
      sortOrdinalDomain = false;
    }
    for (const channel of mark.channels) {
      if (!skip.has(channel))
        skip.set(channel, /* @__PURE__ */ new Set());
      if (mark.data.length > 0) {
        const channelOptions = isDataRecord_default(mark.options[channel]) ? mark.options[channel] : { value: mark.options[channel], scale: CHANNEL_SCALE[channel] };
        const useScale = channelOptions.scale === name && // only use scale if implicit scales are enabled or use has explicitly
        // defined a scale
        (plotOptions.implicitScales || scaleOptions.scale) && // type number means, someone is defining a channel as constant, e.g.
        // <Dot r={10} /> in which case we don't want to pass it through a scale
        // typeof channelOptions.value !== 'number' &&
        typeof channelOptions.value !== "undefined";
        if (useScale) {
          if (name === "opacity" && looksLikeOpacity(channelOptions.value)) {
            skip.get(channel).add(mark.id);
          } else {
            const isOutputType = name === "color" ? isColorOrNull : name === "symbol" ? isSymbolOrNull : false;
            let allValuesAreOutputType = !!isOutputType && mark.data.length > 0;
            if (isOutputType) {
              for (const datum of mark.data) {
                const val = resolveProp(channelOptions.value, datum);
                allValuesAreOutputType = allValuesAreOutputType && val !== null && isOutputType(val);
                if (!allValuesAreOutputType)
                  break;
              }
            }
            if (allValuesAreOutputType) {
              skip.get(channel).add(mark.id);
            }
            if (typeof channelOptions.value === "string" && !looksLikeANumber(channelOptions.value) && !channelOptions.value.startsWith("__") && mark.data[0][channelOptions.value] !== void 0) {
              propNames.add(channelOptions.value);
            }
            uniqueScaleProps.add(channelOptions.value);
            if (channelOptions.value != null && !allValuesAreOutputType) {
              manualActiveMarks++;
              markTypes.add(mark.type);
              for (const datum of mark.data) {
                const value = resolveProp(channelOptions.value, datum);
                dataValues.add(value);
                if (name === "color" && scaleOptions.type === "quantile" || scaleOptions.type === "quantile-cont") {
                  allDataValues.push(value);
                }
              }
            }
          }
        }
        if ((name === "x" || name === "y") && mark.options[ORIGINAL_NAME_KEYS[name]] && !mark.options[ORIGINAL_NAME_KEYS[name]].startsWith("__")) {
          propNames.add(mark.options[ORIGINAL_NAME_KEYS[name]]);
        }
      } else {
      }
    }
  }
  if ((name === "x" || name === "y") && scaleOptions.sort) {
    sortOrdinalDomain = true;
  }
  if ((name === "x" || name === "y") && scaleOptions.sort === false) {
    sortOrdinalDomain = false;
  }
  const valueArr = [...dataValues.values(), ...scaleOptions.domain || []].filter((d) => d != null);
  const type = scaleOptions.type === "auto" ? inferScaleType(name, valueArr, markTypes, scaleOptions) : scaleOptions.type;
  if (VALID_SCALE_TYPES[name] && !VALID_SCALE_TYPES[name].has(type)) {
    throw new Error(`Invalid scale type ${type} for scale
            ${name}. Valid types are ${[...VALID_SCALE_TYPES[name]].join(", ")}`);
  }
  const isOrdinal = isOrdinalScale(type);
  if (isOrdinal && sortOrdinalDomain) {
    valueArr.sort(ascending);
  }
  const valueArray = type === "quantile" || type === "quantile-cont" ? allDataValues.toSorted() : valueArr;
  let domain = scaleOptions.domain ? isOrdinal ? scaleOptions.domain : extent(scaleOptions.zero ? [0, ...scaleOptions.domain] : scaleOptions.domain) : type === "band" || type === "point" || type === "ordinal" || type === "categorical" || type === "quantile" || type === "quantile-cont" ? name === "y" ? valueArray.toReversed() : valueArray : extent(scaleOptions.zero ? [0, ...valueArray] : valueArray);
  if (scaleOptions.interval) {
    if (isOrdinal) {
      domain = domainFromInterval(domain, scaleOptions.interval, name);
    } else {
      if (markTypes.size > 0) {
        console.error("Setting interval via axis options is only supported for ordinal scales");
      }
    }
  }
  if (!scaleOptions.scale) {
    throw new Error(`No scale function defined for ${name}`);
  }
  const fn = scaleOptions.scale({
    name,
    type,
    domain,
    scaleOptions,
    plotOptions,
    plotWidth,
    plotHeight,
    plotHasFilledDotMarks,
    plotDefaults
  });
  const range3 = fn.range();
  return {
    type,
    domain,
    range: range3,
    fn,
    skip,
    manualActiveMarks,
    uniqueScaleProps,
    autoTitle: type === "time" ? null : propNames.size === 1 ? `${[...propNames.values()][0]}${type === "log" ? " (log)" : ""}` : null
  };
}
function domainFromInterval(domain, interval2, name) {
  const interval_ = maybeInterval(interval2);
  const [lo, hi] = extent(domain);
  const out = interval_.range(lo, interval_.offset(hi));
  return name === "y" ? out.toReversed() : out;
}
var markTypesWithBandDefault = {
  x: /* @__PURE__ */ new Set(["barY", "cell", "tickY", "waffleY"]),
  y: /* @__PURE__ */ new Set(["barX", "cell", "tickX", "waffleX"])
};
function inferScaleType(name, dataValues, markTypes, scaleOptions = {}) {
  if (name === "color") {
    if (!dataValues.length)
      return "ordinal";
    if (dataValues.every(isNumberOrNullOrNaN))
      return "linear";
    if (dataValues.every(isDateOrNull))
      return "linear";
    if (dataValues.every(isStringOrNull))
      return "categorical";
    return "categorical";
  }
  if (name === "symbol")
    return "ordinal";
  if (name === "x" || name === "y") {
    if (scaleOptions.nice || scaleOptions.zero)
      return "linear";
    if (scaleOptions.domain && scaleOptions.domain.length === 2) {
      if (scaleOptions.domain.every(Number.isFinite))
        return "linear";
      if (scaleOptions.domain.every(isDate))
        return "time";
    }
  }
  if (name === "y" && Array.from(markTypes).some((d) => markTypesWithBandDefault.y.has(d)))
    return "band";
  if (name === "x" && Array.from(markTypes).some((d) => markTypesWithBandDefault.x.has(d)))
    return "band";
  if (!dataValues.length)
    return "linear";
  if (dataValues.length === 1)
    return "point";
  if (dataValues.every(isNumberOrNull))
    return name === "r" ? "sqrt" : "linear";
  if (dataValues.every(isDateOrNull))
    return "time";
  if (dataValues.every(isStringOrNull))
    return "point";
  return "linear";
}
var scaledChannelNames = [
  "x",
  "x1",
  "x2",
  "y",
  "y1",
  "y2",
  "r",
  "opacity",
  "fill",
  "fillOpacity",
  "stroke",
  "strokeOpacity",
  "symbol",
  "length"
];
function getUsedScales(plot, options, mark) {
  return Object.fromEntries(scaledChannelNames.map((channel) => {
    const scale = CHANNEL_SCALE[channel];
    const skipMarks = plot.scales[scale].skip.get(channel) || /* @__PURE__ */ new Set();
    return [
      channel,
      !skipMarks.has(mark.id) && toChannelOption(channel, options[channel]).scale !== null && !plot.scales[scale].isDummy
    ];
  }));
}
function looksLikeANumber(input) {
  return Number.isFinite(input) || typeof input === "string" && input.trim().length > 0 && Number.isFinite(+input);
}
function isWithin(number4, min3, max3) {
  return Number.isFinite(number4) && number4 >= min3 && number4 <= max3;
}
function looksLikeOpacity(input) {
  return looksLikeANumber(input) && isWithin(+input, 0, 1);
}
function projectXY(scales, x2, y2, useXScale = true, useYScale = true) {
  if (scales.projection) {
    let x_, y_;
    const stream = scales.projection.stream({
      point(px, py) {
        x_ = px;
        y_ = py;
      }
    });
    stream.point(x2, y2);
    return [x_, y_];
  }
  return [
    useXScale ? projectX("x", scales, x2) : x2,
    useYScale ? projectY("y", scales, y2) : y2
  ];
}
function projectX(channel, scales, value) {
  return scales.x.fn(value) + (channel === "x" && scales.x.type === "band" ? scales.x.fn.bandwidth() * 0.5 : channel === "x2" && scales.x.type === "band" ? scales.x.fn.bandwidth() : 0);
}
function projectY(channel, scales, value) {
  return scales.y.fn(value) + (channel === "y" && scales.y.type === "band" ? scales.y.fn.bandwidth() * 0.5 : channel === "y2" && scales.y.type === "band" ? scales.y.fn.bandwidth() : 0);
}
function isOrdinalScale(scaleType) {
  return scaleType === "band" || scaleType === "point" || scaleType === "ordinal" || scaleType === "categorical" || scaleType === "threshold";
}

// node_modules/svelteplot/dist/hooks/plotDefaults.js
var PLOT_DEFAULTS_KEY = /* @__PURE__ */ Symbol("svelteplot/defaults");
function setPlotDefaults(plotDefaults) {
  const existingDefaults = getPlotDefaults();
  const mergedDefaults = { ...existingDefaults, ...plotDefaults };
  setContext(PLOT_DEFAULTS_KEY, mergedDefaults);
}
function getPlotDefaults() {
  return hasContext(PLOT_DEFAULTS_KEY) ? getContext(PLOT_DEFAULTS_KEY) : (
    // Fallback for backward compatibility
    hasContext("svelteplot/defaults") ? (console.error(`svelteplot: Please use new setPlotDefaults hook instead of 'svelteplot/defaults' context`), getContext("svelteplot/defaults")) : {}
  );
}

// node_modules/svelteplot/dist/core/Plot.svelte
Plot[FILENAME] = "node_modules/svelteplot/dist/core/Plot.svelte";
var root_1 = add_locations(from_html(`<div class="plot-header s-W5MRypdQgyoZ"><!></div>`), Plot[FILENAME], [[529, 8]]);
var root_22 = add_locations(from_html(`<div class="plot-underlay s-W5MRypdQgyoZ"><!></div>`), Plot[FILENAME], [[534, 22]]);
var root_5 = add_locations(from_html(`<div class="plot-overlay s-W5MRypdQgyoZ"><!></div>`), Plot[FILENAME], [[558, 21]]);
var root_6 = add_locations(from_html(`<figcaption class="plot-footer s-W5MRypdQgyoZ"><!></figcaption>`), Plot[FILENAME], [[574, 8]]);
var root = add_locations(from_html(`<figure><!> <div class="plot-body s-W5MRypdQgyoZ"><!> <svg fill="currentColor"><!><!></svg> <!></div> <!></figure>`), Plot[FILENAME], [[523, 0, [[533, 4, [[535, 8]]]]]]);
var $$css = {
  hash: "s-W5MRypdQgyoZ",
  code: "\n    figure.s-W5MRypdQgyoZ {\n        --svp-bg: var(--svelteplot-bg, white);\n        margin: 0;\n        padding: 0;\n    }\n\n    .plot-body.s-W5MRypdQgyoZ {\n        position: relative;\n    }\n\n    .plot-overlay.s-W5MRypdQgyoZ,\n    .plot-underlay.s-W5MRypdQgyoZ {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        pointer-events: none;\n    }\n\n    .plot-underlay.s-W5MRypdQgyoZ {\n        z-index: -1;\n    }\n\n    .plot-header.s-W5MRypdQgyoZ {\n        margin-top: 1rem;\n        display: flex;\n        flex-direction: column;\n        row-gap: 0.35rem;\n    }\n\n    .plot-header.s-W5MRypdQgyoZ h2,\n    .plot-header.s-W5MRypdQgyoZ h3 {\n        margin: 0 !important;\n        padding: 0 !important;\n        border: 0 !important;\n    }\n\n    .plot-footer.s-W5MRypdQgyoZ {\n        margin-bottom: 2rem;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxvdC5zdmVsdGUiLCJzb3VyY2VzIjpbIlBsb3Quc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cbiAgICBAY29tcG9uZW50XG4gICAgVGhlIGNvcmUgUGxvdCBjb21wb25lbnQgaGFuZGxlcyB0aGUgbWFpbiBsYXlvdXQgb2YgdGhlIHBsb3QgYnV0IGl0IGRvZXMgbm90XG4gICAgaW5jbHVkZSBzbWFydCBhdXRvbWF0aWMgc2NhbGVzIGFuZCBtYXJrcy4gSXQgaXMgdG8gYmUgdXNlZCBpbiBjYXNlcyB3aGVyZVxuICAgIHlvdSB3YW50IHRvIHJlZHVjZSB0aGUgZm9vdHByaW50IG9mIHRoZSBwbG90IHRvIHRoZSBiYXJlIG1pbmltdW0uXG5cbiAgICBLZWVwIGluIG1pbmQgdGhhdCB5b3Ugd2lsbCBoYXZlIHRvIGNyZWF0ZSB5b3VyIG93biBzY2FsZXMgaWYgeW91J3JlIHVzaW5nXG4gICAgdGhpcyBjb21wb25lbnQuIFxuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIGltcG9ydCB7IHNldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IFN2ZWx0ZU1hcCB9IGZyb20gJ3N2ZWx0ZS9yZWFjdGl2aXR5JztcbiAgICBpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cbiAgICBpbXBvcnQgdHlwZSB7XG4gICAgICAgIFBsb3RPcHRpb25zLFxuICAgICAgICBHZW5lcmljTWFya09wdGlvbnMsXG4gICAgICAgIE1hcmssXG4gICAgICAgIFBsb3RTY2FsZXMsXG4gICAgICAgIFNjYWxlTmFtZSxcbiAgICAgICAgUGxvdFNjYWxlLFxuICAgICAgICBQbG90RGVmYXVsdHMsXG4gICAgICAgIFBsb3RTdGF0ZSxcbiAgICAgICAgUmF3VmFsdWUsXG4gICAgICAgIFBsb3RNYXJnaW5cbiAgICB9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbiAgICBpbXBvcnQgRmFjZXRHcmlkIGZyb20gJy4vRmFjZXRHcmlkLnN2ZWx0ZSc7XG5cbiAgICBpbXBvcnQgbWVyZ2VEZWVwIGZyb20gJy4uL2hlbHBlcnMvbWVyZ2VEZWVwLmpzJztcbiAgICBpbXBvcnQgeyBjb21wdXRlU2NhbGVzLCBwcm9qZWN0WFkgfSBmcm9tICcuLi9oZWxwZXJzL3NjYWxlcy5qcyc7XG4gICAgaW1wb3J0IHsgQ0hBTk5FTF9TQ0FMRSwgU0NBTEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbiAgICBpbXBvcnQgeyBnZXRQbG90RGVmYXVsdHMsIHNldFBsb3REZWZhdWx0cyB9IGZyb20gJy4uL2hvb2tzL3Bsb3REZWZhdWx0cy5qcyc7XG4gICAgaW1wb3J0IHsgbWF5YmVOdW1iZXIgfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbiAgICBpbXBvcnQgeyBzZXRQbG90LCB1c2VQbG90IH0gZnJvbSAnLi4vaG9va3MvdXNlUGxvdC5zdmVsdGUuanMnO1xuXG4gICAgLy8gYXV0b21hdGljIG1hcmdpbnMgY2FuIGJlIGFwcGxpZWQgYnkgdGhlIG1hcmtzLCByZWdpc3RlcmVkXG4gICAgLy8gd2l0aCB0aGVpciByZXNwZWN0aXZlIHVuaXF1ZSBpZGVudGlmaWVyIGFzIGtleXNcbiAgICBsZXQgYXV0b01hcmdpbkxlZnQgPSB3cml0YWJsZShuZXcgU3ZlbHRlTWFwPHN0cmluZywgbnVtYmVyPigpKTtcbiAgICBsZXQgYXV0b01hcmdpblJpZ2h0ID0gd3JpdGFibGUobmV3IFN2ZWx0ZU1hcDxzdHJpbmcsIG51bWJlcj4oKSk7XG4gICAgbGV0IGF1dG9NYXJnaW5Cb3R0b20gPSB3cml0YWJsZShuZXcgU3ZlbHRlTWFwPHN0cmluZywgbnVtYmVyPigpKTtcbiAgICBsZXQgYXV0b01hcmdpblRvcCA9IHdyaXRhYmxlKG5ldyBTdmVsdGVNYXA8c3RyaW5nLCBudW1iZXI+KCkpO1xuXG4gICAgLy8gYXV0b01hcmdpbiBzdG9yZXMgYXJlIHNoYXJlZCB2aWEgY29udGV4dFxuICAgIHNldENvbnRleHQoJ3N2ZWx0ZXBsb3QvYXV0b01hcmdpbnMnLCB7XG4gICAgICAgIGF1dG9NYXJnaW5MZWZ0LFxuICAgICAgICBhdXRvTWFyZ2luUmlnaHQsXG4gICAgICAgIGF1dG9NYXJnaW5Cb3R0b20sXG4gICAgICAgIGF1dG9NYXJnaW5Ub3BcbiAgICB9KTtcblxuICAgIC8vIGNvbXB1dGUgbWF4aW11bSBtYXJnaW5zIHRvIGVpdGhlciBzaWRlIG9mIHRoZSBwbG90IGZyb20gdGhlXG4gICAgLy8gYXV0b21hdGljIG1hcmdpbnMgZGVmaW5lZCBieSBtYXJrc1xuICAgIGNvbnN0IG1heE1hcmdpbkxlZnQgPSAkZGVyaXZlZChNYXRoLm1heCguLi4kYXV0b01hcmdpbkxlZnQudmFsdWVzKCkpKTtcbiAgICBjb25zdCBtYXhNYXJnaW5SaWdodCA9ICRkZXJpdmVkKE1hdGgubWF4KC4uLiRhdXRvTWFyZ2luUmlnaHQudmFsdWVzKCkpKTtcbiAgICBjb25zdCBtYXhNYXJnaW5Cb3R0b20gPSAkZGVyaXZlZChNYXRoLm1heCguLi4kYXV0b01hcmdpbkJvdHRvbS52YWx1ZXMoKSkpO1xuICAgIGNvbnN0IG1heE1hcmdpblRvcCA9ICRkZXJpdmVkKE1hdGgubWF4KC4uLiRhdXRvTWFyZ2luVG9wLnZhbHVlcygpKSk7XG5cbiAgICBjb25zdCBVU0VSX0RFRkFVTFRTID0gZ2V0UGxvdERlZmF1bHRzKCk7XG5cbiAgICAvLyBkZWZhdWx0IHNldHRpbmdzIGluIHRoZSBwbG90IGFuZCBtYXJrcyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnlcbiAgICAvLyBkZWZpbmluZyB0aGUgc3ZlbHRlcGxvdC9kZWZhdWx0cyBjb250ZXh0IG91dHNpZGUgb2YgUGxvdFxuICAgIGNvbnN0IERFRkFVTFRTOiBQbG90RGVmYXVsdHMgPSB7XG4gICAgICAgIGhlaWdodDogMzUwLFxuICAgICAgICBpbml0aWFsV2lkdGg6IDUwMCxcbiAgICAgICAgaW5zZXQ6IDAsXG4gICAgICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgICAgICBjb2xvclNjaGVtZTogJ3R1cmJvJyxcbiAgICAgICAgdW5rbm93bjogJyNjY2NjY2M5OScsXG4gICAgICAgIHNvcnRPcmRpbmFsRG9tYWluczogdHJ1ZSxcbiAgICAgICAgY2F0ZWdvcmljYWxDb2xvclNjaGVtZTogJ29ic2VydmFibGUxMCcsXG4gICAgICAgIHBvaW50U2NhbGVIZWlnaHQ6IDIwLFxuICAgICAgICBiYW5kU2NhbGVIZWlnaHQ6IDMwLFxuICAgICAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgICAgIG51bWJlckZvcm1hdDoge1xuICAgICAgICAgICAgc3R5bGU6ICdkZWNpbWFsJyxcbiAgICAgICAgICAgIC8vIG5vdGF0aW9uOiAnY29tcGFjdCcsXG4gICAgICAgICAgICB1c2VHcm91cGluZzogJ21pbjInLFxuICAgICAgICAgICAgY29tcGFjdERpc3BsYXk6ICdzaG9ydCdcbiAgICAgICAgfSxcbiAgICAgICAgbWFya2VyRG90UmFkaXVzOiAzLFxuICAgICAgICAuLi5VU0VSX0RFRkFVTFRTLFxuICAgICAgICBheGlzWDoge1xuICAgICAgICAgICAgYW5jaG9yOiAnYm90dG9tJyxcbiAgICAgICAgICAgIGltcGxpY2l0OiB0cnVlLFxuICAgICAgICAgICAgLi4uVVNFUl9ERUZBVUxUUy5heGlzLFxuICAgICAgICAgICAgLi4uVVNFUl9ERUZBVUxUUy5heGlzWFxuICAgICAgICB9LFxuICAgICAgICBheGlzWToge1xuICAgICAgICAgICAgYW5jaG9yOiAnbGVmdCcsXG4gICAgICAgICAgICBpbXBsaWNpdDogdHJ1ZSxcbiAgICAgICAgICAgIC4uLlVTRVJfREVGQVVMVFMuYXhpcyxcbiAgICAgICAgICAgIC4uLlVTRVJfREVGQVVMVFMuYXhpc1lcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZFg6IHtcbiAgICAgICAgICAgIGltcGxpY2l0OiBmYWxzZSxcbiAgICAgICAgICAgIC4uLlVTRVJfREVGQVVMVFMuZ3JpZCxcbiAgICAgICAgICAgIC4uLlVTRVJfREVGQVVMVFMuZ3JpZFhcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZFk6IHtcbiAgICAgICAgICAgIGltcGxpY2l0OiBmYWxzZSxcbiAgICAgICAgICAgIC4uLlVTRVJfREVGQVVMVFMuZ3JpZCxcbiAgICAgICAgICAgIC4uLlVTRVJfREVGQVVMVFMuZ3JpZFlcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQge1xuICAgICAgICBoZWFkZXIsXG4gICAgICAgIGZvb3RlcixcbiAgICAgICAgb3ZlcmxheSxcbiAgICAgICAgdW5kZXJsYXksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBmYWNldEF4ZXMsXG4gICAgICAgIHRlc3RpZCxcbiAgICAgICAgZmFjZXQsXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWUgPSAnJyxcbiAgICAgICAgY3NzID0gREVGQVVMVFMuY3NzLFxuICAgICAgICB3aWR0aDogZml4ZWRXaWR0aCxcbiAgICAgICAgLi4uaW5pdGlhbE9wdGlvbnNcbiAgICB9OiBQYXJ0aWFsPFBsb3RPcHRpb25zPiA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHdpZHRoID0gJHN0YXRlKERFRkFVTFRTLmluaXRpYWxXaWR0aCk7XG5cbiAgICBzZXRQbG90RGVmYXVsdHMoREVGQVVMVFMpO1xuXG4gICAgLy8gaW5mb3JtYXRpb24gdGhhdCBpbmZsdWVuY2VzIHRoZSBkZWZhdWx0IHBsb3Qgb3B0aW9uc1xuICAgIHR5cGUgUGxvdE9wdGlvbnNQYXJhbWV0ZXJzID0ge1xuICAgICAgICBleHBsaWNpdFNjYWxlczogU2V0PFNjYWxlTmFtZT47XG4gICAgICAgIGV4cGxpY2l0RG9tYWluczogU2V0PFNjYWxlTmFtZT47XG4gICAgICAgIGhhc1Byb2plY3Rpb246IGJvb2xlYW47XG4gICAgICAgIG1hcmdpbj86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgaW5zZXQ/OiBudW1iZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRoZSBtYXJrcyB1c2VkIGluIHRoZSBwbG90XG4gICAgICovXG4gICAgbGV0IG1hcmtzID0gJHN0YXRlLnJhdzxNYXJrPEdlbmVyaWNNYXJrT3B0aW9ucz5bXT4oW10pO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdCBleHBsaWNpdE1hcmtzID0gJGRlcml2ZWQobWFya3MuZmlsdGVyKChtKSA9PiAhbS5vcHRpb25zLmF1dG9tYXRpYykpO1xuXG4gICAgLy8ga25vd2luZyBpZiB0aGUgcGxvdCBpbmNsdWRlcyBleHBsaWNpdCBncmlkcyBhbmQgbWFya3MgaXMgdXNlZnVsIGZvclxuICAgIC8vIGluY2x1ZGluZyB0aGUgYXV0b21hdGljL2ltcGxpY2l0IGF4ZXMvZ3JpZHNcbiAgICBjb25zdCBoYXNFeHBsaWNpdEF4aXNYID0gJGRlcml2ZWQoISFleHBsaWNpdE1hcmtzLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2F4aXNYJykpO1xuICAgIGNvbnN0IGhhc0V4cGxpY2l0QXhpc1kgPSAkZGVyaXZlZCghIWV4cGxpY2l0TWFya3MuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXhpc1knKSk7XG4gICAgY29uc3QgaGFzRXhwbGljaXRHcmlkWCA9ICRkZXJpdmVkKCEhZXhwbGljaXRNYXJrcy5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdncmlkWCcpKTtcbiAgICBjb25zdCBoYXNFeHBsaWNpdEdyaWRZID0gJGRlcml2ZWQoISFleHBsaWNpdE1hcmtzLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2dyaWRZJykpO1xuXG4gICAgY29uc3QgZXhwbGljaXRTY2FsZXMgPSAkZGVyaXZlZChcbiAgICAgICAgbmV3IFNldChcbiAgICAgICAgICAgIGV4cGxpY2l0TWFya3NcbiAgICAgICAgICAgICAgICAubWFwKChtKSA9PlxuICAgICAgICAgICAgICAgICAgICBbLi4ubS5zY2FsZXMudmFsdWVzKCldLmZpbHRlcigoc2NhbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc2NhbGVzIHdoZXJlIG5vIGlucHV0IGNoYW5uZWxzIGFyZSBkZWZpbmVkIGZvciB0aGlzIG1hcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gT2JqZWN0LmVudHJpZXMoQ0hBTk5FTF9TQ0FMRSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChbLCBzY2FsZU5hbWVdKSA9PiBzY2FsZSA9PT0gc2NhbGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFtjaGFubmVsXSkgPT4gY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbHMuZmluZCgoY2hhbm5lbCkgPT4gbS5vcHRpb25zW2NoYW5uZWxdICE9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAuZmxhdCgxKVxuICAgICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IGV4cGxpY2l0RG9tYWlucyA9ICRkZXJpdmVkKFxuICAgICAgICBuZXcgU2V0KFNDQUxFUy5maWx0ZXIoKHNjYWxlKSA9PiAhIWluaXRpYWxPcHRpb25zW3NjYWxlXT8uZG9tYWluKSlcbiAgICApO1xuXG4gICAgLy8gb25lLWRpbWVuc2lvbmFsIHBsb3RzIGhhdmUgZGlmZmVyZW50IGF1dG9tYXRpYyBtYXJnaW5zIGFuZCBoZWlnaHRzXG4gICAgY29uc3QgaXNPbmVEaW1lbnNpb25hbCA9ICRkZXJpdmVkKGV4cGxpY2l0U2NhbGVzLmhhcygneCcpICE9PSBleHBsaWNpdFNjYWxlcy5oYXMoJ3knKSk7XG5cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIHBsb3Qgb3B0aW9ucyBmcm9tIHRoZSB1c2VyLWRlZmluZWQgb3B0aW9ucyAodG9wLWxldmVsIHByb3BzKSBhcyB3ZWxsXG4gICAgLy8gYXMgZXh0ZW5kaW5nIHRoZW0gZnJvbSBzbWFydCBjb250ZXh0LWF3YXJlIGRlZmF1bHRzXG4gICAgY29uc3QgcGxvdE9wdGlvbnMgPSAkZGVyaXZlZChcbiAgICAgICAgZXh0ZW5kUGxvdE9wdGlvbnMoaW5pdGlhbE9wdGlvbnMsIHtcbiAgICAgICAgICAgIGV4cGxpY2l0U2NhbGVzLFxuICAgICAgICAgICAgZXhwbGljaXREb21haW5zLFxuICAgICAgICAgICAgaGFzUHJvamVjdGlvbjogISFpbml0aWFsT3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgICAgICAgbWFyZ2luOiBpbml0aWFsT3B0aW9ucy5tYXJnaW4sXG4gICAgICAgICAgICBpbnNldDogaW5pdGlhbE9wdGlvbnMuaW5zZXRcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gaWYgdGhlIHBsb3QgaXMgc2hvd2luZyBmaWxsZWQgZG90IG1hcmtzIHdlJ3JlIHVzaW5nIGRpZmZlcmVudCBkZWZhdWx0c1xuICAgIC8vIGZvciB0aGUgc3ltYm9sIGF4aXMgcmFuZ2UsIHNvIHdlJ3JlIHBhc3Npbmcgb24gdGhpcyBpbmZvIHRvIHRoZSBjb21wdXRlU2NhbGVzXG4gICAgLy8gZnVuY3Rpb24gYmVsb3dcbiAgICBjb25zdCBoYXNGaWxsZWREb3RNYXJrcyA9ICRkZXJpdmVkKFxuICAgICAgICAhIWV4cGxpY2l0TWFya3MuZmluZCgoZCkgPT4gZC50eXBlID09PSAnZG90JyAmJiBkLm9wdGlvbnMuZmlsbClcbiAgICApO1xuXG4gICAgLy8gY29tcHV0ZSBwcmVsaW1pbmFyeSBzY2FsZXMgd2l0aCBhIGZpeGVkIGhlaWdodCwgc2luY2Ugd2UgZG9uJ3QgaGF2ZVxuICAgIC8vIGhlaWdodCBkZWZpbmVkIGF0IHRoaXMgcG9pbnQsIGJ1dCBzdGlsbCBuZWVkIHNvbWUgb2YgdGhlIHNjYWxlc1xuICAgIGNvbnN0IHByZVNjYWxlczogUGxvdFNjYWxlcyA9ICRkZXJpdmVkKFxuICAgICAgICBjb21wdXRlU2NhbGVzKHBsb3RPcHRpb25zLCB3aWR0aCwgNDAwLCBoYXNGaWxsZWREb3RNYXJrcywgbWFya3MsIERFRkFVTFRTKVxuICAgICk7XG5cbiAgICBjb25zdCBoYXNQcm9qZWN0aW9uID0gJGRlcml2ZWQoISFwcmVTY2FsZXMucHJvamVjdGlvbik7XG5cbiAgICBjb25zdCBwbG90V2lkdGggPSAkZGVyaXZlZChcbiAgICAgICAgKGZpeGVkV2lkdGggfHwgd2lkdGgpIC0gcGxvdE9wdGlvbnMubWFyZ2luTGVmdCAtIHBsb3RPcHRpb25zLm1hcmdpblJpZ2h0XG4gICAgKTtcblxuICAgIC8vIHRoZSBmYWNldCBhbmQgeSBkb21haW4gY291bnRzIGFyZSB1c2VkIGZvciBjb21wdXRpbmcgdGhlIGF1dG9tYXRpYyBoZWlnaHRcbiAgICBjb25zdCB4RmFjZXRDb3VudCA9ICRkZXJpdmVkKE1hdGgubWF4KDEsIHByZVNjYWxlcy5meC5kb21haW4ubGVuZ3RoKSk7XG4gICAgY29uc3QgeUZhY2V0Q291bnQgPSAkZGVyaXZlZChNYXRoLm1heCgxLCBwcmVTY2FsZXMuZnkuZG9tYWluLmxlbmd0aCkpO1xuICAgIGNvbnN0IHlEb21haW5Db3VudCA9ICRkZXJpdmVkKFxuICAgICAgICBpc09uZURpbWVuc2lvbmFsICYmIGV4cGxpY2l0U2NhbGVzLmhhcygneCcpID8gMSA6IHByZVNjYWxlcy55LmRvbWFpbi5sZW5ndGhcbiAgICApO1xuXG4gICAgY29uc3QgZGVmYXVsdFBvaW50U2NhbGVIZWlnaHQgPSAkZGVyaXZlZChcbiAgICAgICAgZXhwbGljaXRTY2FsZXMuaGFzKCdyJykgJiYgcGxvdE9wdGlvbnMuci5yYW5nZVxuICAgICAgICAgICAgPyBwbG90T3B0aW9ucy5yLnJhbmdlWzFdICogMlxuICAgICAgICAgICAgOiBERUZBVUxUUy5wb2ludFNjYWxlSGVpZ2h0XG4gICAgKTtcblxuICAgIC8vIGNvbXB1dGUgdGhlIChhdXRvbWF0aWMpIGhlaWdodCBiYXNlZCBvbiB2YXJpb3VzIGZhY3RvcnM6XG4gICAgLy8gLSBpZiB0aGUgcGxvdCB1c2VkIGEgcHJvamVjdGlvbiBhbmQgdGhlIHByb2plY3Rpb24gcmVxdWlyZXMgYW4gYXNwZWN0IHJhdGlvLFxuICAgIC8vICAgd2UgdXNlIGl0LCBidXQgYWRqdXN0IGZvciB0aGUgZmFjZXQgY291bnRzXG4gICAgLy8gLSBpZiB0aGUgdXNlciBkZWZpbmVkIGEgZG9tYWluLWFzcGVjdCByYXRpbywgd2UgdXNlIHRoZSBoZWlnaHRGcm9tQXNwZWN0XG4gICAgLy8gICBtZXRob2QgdG8gY29tcHV0ZSB0aGUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBwcmVsaW1pbmFyeSB4IGFuZCB5IHNjYWxlc1xuICAgIC8vIC0gZm9yIG9uZS1kaW1lbnNpb25hbCBzY2FsZXMgdXNpbmcgdGhlIHggc2NhbGUgd2Ugc2V0IGEgZml4ZWQgaGVpZ2h0XG4gICAgLy8gLSBmb3IgeSBiYW5kLXNjYWxlcyB3ZSB1c2UgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgeSBkb21haW5cbiAgICBjb25zdCBoZWlnaHQgPSAkZGVyaXZlZChcbiAgICAgICAgdHlwZW9mIHBsb3RPcHRpb25zLmhlaWdodCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwbG90T3B0aW9ucy5oZWlnaHQocGxvdFdpZHRoKVxuICAgICAgICAgICAgOiBtYXliZU51bWJlcihwbG90T3B0aW9ucy5oZWlnaHQpID09PSBudWxsIHx8IHBsb3RPcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nXG4gICAgICAgICAgICAgID8gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAgICAgcHJlU2NhbGVzLnByb2plY3Rpb24gJiYgcHJlU2NhbGVzLnByb2plY3Rpb24uYXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICAgICAgICAgID8gKChwbG90V2lkdGggKiBwcmVTY2FsZXMucHJvamVjdGlvbi5hc3BlY3RSYXRpbykgLyB4RmFjZXRDb3VudCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUZhY2V0Q291bnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdE9wdGlvbnMubWFyZ2luVG9wICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3RPcHRpb25zLm1hcmdpbkJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwbG90T3B0aW9ucy5hc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhlaWdodEZyb21Bc3BlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVNjYWxlcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVTY2FsZXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdE9wdGlvbnMuYXNwZWN0UmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3RXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxvdE9wdGlvbnMubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90T3B0aW9ucy5tYXJnaW5Cb3R0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogKChpc09uZURpbWVuc2lvbmFsICYmIGV4cGxpY2l0U2NhbGVzLmhhcygneCcpKSB8fCAhZXhwbGljaXRNYXJrcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB5RmFjZXRDb3VudCAqIERFRkFVTFRTLmJhbmRTY2FsZUhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByZVNjYWxlcy55LnR5cGUgPT09ICdiYW5kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geUZhY2V0Q291bnQgKiB5RG9tYWluQ291bnQgKiBERUZBVUxUUy5iYW5kU2NhbGVIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByZVNjYWxlcy55LnR5cGUgPT09ICdwb2ludCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geUZhY2V0Q291bnQgKiB5RG9tYWluQ291bnQgKiBkZWZhdWx0UG9pbnRTY2FsZUhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBERUZBVUxUUy5oZWlnaHQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbG90T3B0aW9ucy5tYXJnaW5Ub3AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3RPcHRpb25zLm1hcmdpbkJvdHRvbVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBtYXliZU51bWJlcihwbG90T3B0aW9ucy5oZWlnaHQpXG4gICAgKTtcblxuICAgIGNvbnN0IHBsb3RIZWlnaHQgPSAkZGVyaXZlZChoZWlnaHQgLSBwbG90T3B0aW9ucy5tYXJnaW5Ub3AgLSBwbG90T3B0aW9ucy5tYXJnaW5Cb3R0b20pO1xuXG4gICAgLy8gVE9ETzogY2hlY2sgaWYgdGhlcmUncyBzdGlsbCBhIHJlYXNvbiB0byBzdG9yZSBhbmQgZXhwb3NlIHRoZSBwbG90IGJvZHkgZWxlbWVudFxuICAgIGxldCBwbG90Qm9keTogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gJHN0YXRlKG51bGwpO1xuXG4gICAgbGV0IGZhY2V0V2lkdGg6IG51bWJlciB8IG51bGwgPSAkc3RhdGUobnVsbCk7XG4gICAgbGV0IGZhY2V0SGVpZ2h0OiBudW1iZXIgfCBudWxsID0gJHN0YXRlKG51bGwpO1xuXG4gICAgbGV0IHBsb3RTdGF0ZSA9IHNldFBsb3QoY29tcHV0ZVBsb3RTdGF0ZSgpKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBwbG90U3RhdGUudXBkYXRlKGNvbXB1dGVQbG90U3RhdGUoKSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUGxvdFN0YXRlKCkge1xuICAgICAgICAvLyBub3cgdGhhdCB3ZSBrbm93IHRoZSBhY3R1YWwgaGVpZ2h0IGFuZCBmYWNldCBkaW1lbnNpb25zLCB3ZSBjYW4gY29tcHV0ZVxuICAgICAgICAvLyB0aGUgc2NhbGVzIHVzZWQgaW4gYWxsIHRoZSBtYXJrc1xuICAgICAgICBjb25zdCBzY2FsZXMgPSBjb21wdXRlU2NhbGVzKFxuICAgICAgICAgICAgcGxvdE9wdGlvbnMsXG4gICAgICAgICAgICBmYWNldFdpZHRoIHx8IHdpZHRoLFxuICAgICAgICAgICAgZmFjZXRIZWlnaHQgfHwgaGVpZ2h0LFxuICAgICAgICAgICAgaGFzRmlsbGVkRG90TWFya3MsXG4gICAgICAgICAgICBtYXJrcyxcbiAgICAgICAgICAgIERFRkFVTFRTXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbG9yU3ltYm9sUmVkdW5kYW50ID1cbiAgICAgICAgICAgIHNjYWxlcy5jb2xvci51bmlxdWVTY2FsZVByb3BzPy5zaXplID09PSAxICYmXG4gICAgICAgICAgICBzY2FsZXMuc3ltYm9sLnVuaXF1ZVNjYWxlUHJvcHM/LnNpemUgPT09IDEgJiZcbiAgICAgICAgICAgIFsuLi5zY2FsZXMuY29sb3IudW5pcXVlU2NhbGVQcm9wcz8udmFsdWVzKCldWzBdID09PVxuICAgICAgICAgICAgICAgIFsuLi5zY2FsZXMuc3ltYm9sLnVuaXF1ZVNjYWxlUHJvcHM/LnZhbHVlcygpXVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHBsb3RPcHRpb25zLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBmYWNldFdpZHRoLFxuICAgICAgICAgICAgZmFjZXRIZWlnaHQsXG4gICAgICAgICAgICBwbG90SGVpZ2h0LFxuICAgICAgICAgICAgcGxvdFdpZHRoLFxuICAgICAgICAgICAgc2NhbGVzLFxuICAgICAgICAgICAgY29sb3JTeW1ib2xSZWR1bmRhbnQsXG4gICAgICAgICAgICBoYXNGaWxsZWREb3RNYXJrcyxcbiAgICAgICAgICAgIGJvZHk6IHBsb3RCb2R5LFxuICAgICAgICAgICAgY3NzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2V0Q29udGV4dCgnc3ZlbHRlcGxvdCcsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZWQgYnkgdGhlIE1hcmsgY29tcG9uZW50IHRvIHJlZ2lzdGVyIG5ldyBtYXJrcyB0byB0aGUgcGxvdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTWFyayhtYXJrOiBNYXJrPEdlbmVyaWNNYXJrT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIGlmIChtYXJrcy5maW5kKChtKSA9PiBtLmlkID09PSBtYXJrLmlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFya3MgPSBbLi4ubWFya3MsIG1hcmtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogdXNlZCBieSB0aGUgTWFyayBjb21wb25lbnQgdG8gdXBkYXRlIG1hcmtzIHdoZW4gaXRzIHByb3BzIGNoYW5nZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTWFyayhtYXJrOiBNYXJrPEdlbmVyaWNNYXJrT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIC8vIG1hcmtzID0gbWFya3MubWFwKChtKSA9PiAobS5pZCA9PT0gbWFyay5pZCA/IG1hcmsgOiBtKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VkIGJ5IHRoZSBNYXJrIGNvbXBvbmVudCB0byB1bnJlZ2lzdGVyIG1hcmtzIHdoZW4gdGhlaXJcbiAgICAgICAgICogcmVzcGVjdGl2ZSBjb21wb25lbnRzIGdldCByZW1vdmVkIGZyb20gdGhlIHBsb3RcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZU1hcmsobWFyazogTWFyazxHZW5lcmljTWFya09wdGlvbnM+KSB7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmZpbHRlcigobSkgPT4gbS5pZCAhPT0gbWFyay5pZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBsb3RTdGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBwbG90U3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRvcExldmVsRmFjZXQoKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGV4cG9zZSB0aGUgZmFjZXQgb3B0aW9ucyB0byBhbGxvdyBtYXJrcyB0b1xuICAgICAgICAgICAgLy8gcmVhY3QgdG8gc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyB0aGUgZnggYW5kIGZ5IGNoYW5uZWxzXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZURpbWVuc2lvbnModzogbnVtYmVyLCBoOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChmYWNldFdpZHRoICE9PSB3KSBmYWNldFdpZHRoID0gdztcbiAgICAgICAgICAgIGlmIChmYWNldEhlaWdodCAhPT0gaCkgZmFjZXRIZWlnaHQgPSBoO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVQbG90U3RhdGUoKSB7XG4gICAgICAgICAgICBwbG90U3RhdGUudXBkYXRlKGNvbXB1dGVQbG90U3RhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE86IHBlcmhhcHMgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAgICBleHBvcnQgZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoZWlnaHRGcm9tQXNwZWN0KFxuICAgICAgICB4OiBQbG90U2NhbGUsXG4gICAgICAgIHk6IFBsb3RTY2FsZSxcbiAgICAgICAgYXNwZWN0UmF0aW86IG51bWJlcixcbiAgICAgICAgcGxvdFdpZHRoOiBudW1iZXIsXG4gICAgICAgIG1hcmdpblRvcDogbnVtYmVyLFxuICAgICAgICBtYXJnaW5Cb3R0b206IG51bWJlclxuICAgICkge1xuICAgICAgICBjb25zdCB4RG9tYWluRXh0ZW50ID1cbiAgICAgICAgICAgIHgudHlwZSA9PT0gJ2JhbmQnIHx8IHgudHlwZSA9PT0gJ3BvaW50J1xuICAgICAgICAgICAgICAgID8geC5kb21haW4ubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBNYXRoLmFicyh4LmRvbWFpblsxXSAtIHguZG9tYWluWzBdKTtcbiAgICAgICAgY29uc3QgeURvbWFpbkV4dGVudCA9XG4gICAgICAgICAgICB5LnR5cGUgPT09ICdiYW5kJyB8fCB5LnR5cGUgPT09ICdwb2ludCdcbiAgICAgICAgICAgICAgICA/IHkuZG9tYWluLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogTWF0aC5hYnMoeS5kb21haW5bMV0gLSB5LmRvbWFpblswXSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoKHBsb3RXaWR0aCAvIHhEb21haW5FeHRlbnQpICogeURvbWFpbkV4dGVudCkgLyBhc3BlY3RSYXRpbyArIG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZFBsb3RPcHRpb25zKFxuICAgICAgICBpbml0aWFsT3B0czogUGFydGlhbDxQbG90T3B0aW9ucz4sXG4gICAgICAgIG9wdHM6IFBsb3RPcHRpb25zUGFyYW1ldGVyc1xuICAgICk6IFBsb3RPcHRpb25zIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGVlcDxQbG90T3B0aW9ucz4oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHsgc29ydE9yZGluYWxEb21haW5zOiBERUZBVUxUUy5zb3J0T3JkaW5hbERvbWFpbnMgfSxcbiAgICAgICAgICAgIHNtYXJ0RGVmYXVsdFBsb3RPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgaW5pdGlhbE9wdGlvbnNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXliZU1hcmdpbihcbiAgICAgICAgLy8gdGhlIG1hcmdpbiBvcHRpb24gcHJvdmlkZWQgdG8gdGhlIDxQbG90PiBjb21wb25lbnRcbiAgICAgICAgbWFyZ2luOiBudW1iZXIgfCAnYXV0bycgfCBQbG90TWFyZ2luIHwgdW5kZWZpbmVkLFxuICAgICAgICAvLyBkaXJlY3Rpb24gdG8gZXh0cmFjdCBmcm9tIHRoZSBtYXJnaW4gb2JqZWN0XG4gICAgICAgIGRpcmVjdGlvbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd0b3AnIHwgJ2JvdHRvbScsXG4gICAgICAgIC8vIHRoZSBtYXJnaW4gb3B0aW9uIGRlZmluZWQgaW4gdGhlIHBsb3QgZGVmYXVsdHNcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQbG90TWFyZ2luIHwgbnVtYmVyIHwgJ2F1dG8nLFxuICAgICAgICAvLyBhdXRvbWF0aWMgbWFyZ2lucyBjb21wdXRlZCBmcm9tIHRoZSBtYXJrc1xuICAgICAgICBhdXRvTWFyZ2luczoge1xuICAgICAgICAgICAgbGVmdDogbnVtYmVyO1xuICAgICAgICAgICAgcmlnaHQ6IG51bWJlcjtcbiAgICAgICAgICAgIHRvcDogbnVtYmVyO1xuICAgICAgICAgICAgYm90dG9tOiBudW1iZXI7XG4gICAgICAgIH1cbiAgICApOiBudW1iZXIge1xuICAgICAgICAvLyBkaXJlY3Rpb24tc3BlY2lmaWMgbWFyZ2luIHZhbHVlIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgY29uc3QgbWFyZ2luVmFsdWUgPVxuICAgICAgICAgICAgdHlwZW9mIG1hcmdpbiA9PT0gJ29iamVjdCcgJiYgbWFyZ2luW2RpcmVjdGlvbl0gIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gbWFyZ2luW2RpcmVjdGlvbl1cbiAgICAgICAgICAgICAgICA6IC8vIHVzZSB0aGUgbWFyZ2luIHZhbHVlIGlmIGl0J3MgYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBtYXJnaW4gPT09ICdudW1iZXInIHx8IG1hcmdpbiA9PT0gJ2F1dG8nXG4gICAgICAgICAgICAgICAgICA/IG1hcmdpblxuICAgICAgICAgICAgICAgICAgOiAvLyB1c2UgZGlyZWN0aW9uLXNwZWNpZmljIGRlZmF1bHQgdmFsdWUgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnb2JqZWN0JyAmJiBkZWZhdWx0VmFsdWVbZGlyZWN0aW9uXSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlW2RpcmVjdGlvbl1cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnbnVtYmVyJyB8fCBkZWZhdWx0VmFsdWUgPT09ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgOiAnYXV0byc7XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpblZhbHVlID09PSAnYXV0bycgPyBhdXRvTWFyZ2luc1tkaXJlY3Rpb25dIDogbWFyZ2luVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSBzbWFydCBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBwbG90IGJhc2VkIG9uIHRoZSBzY2FsZXMgYW5kIG1hcmtzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc21hcnREZWZhdWx0UGxvdE9wdGlvbnMoe1xuICAgICAgICBleHBsaWNpdFNjYWxlcyxcbiAgICAgICAgZXhwbGljaXREb21haW5zLFxuICAgICAgICBoYXNQcm9qZWN0aW9uLFxuICAgICAgICBtYXJnaW5cbiAgICB9OiBQbG90T3B0aW9uc1BhcmFtZXRlcnMpOiBQbG90T3B0aW9ucyB7XG4gICAgICAgIGNvbnN0IGF1dG9YQXhpcyA9IGV4cGxpY2l0U2NhbGVzLmhhcygneCcpIHx8IGV4cGxpY2l0RG9tYWlucy5oYXMoJ3gnKTtcbiAgICAgICAgY29uc3QgYXV0b1lBeGlzID0gZXhwbGljaXRTY2FsZXMuaGFzKCd5JykgfHwgZXhwbGljaXREb21haW5zLmhhcygneScpO1xuICAgICAgICBjb25zdCBpc09uZURpbWVuc2lvbmFsID0gYXV0b1hBeGlzICE9PSBhdXRvWUF4aXM7XG4gICAgICAgIGNvbnN0IG9uZURpbVggPSBhdXRvWEF4aXMgJiYgIWF1dG9ZQXhpcztcbiAgICAgICAgY29uc3Qgb25lRGltWSA9IGF1dG9ZQXhpcyAmJiAhYXV0b1hBeGlzO1xuXG4gICAgICAgIGNvbnN0IGF1dG9NYXJnaW5zID0ge1xuICAgICAgICAgICAgbGVmdDogaGFzUHJvamVjdGlvbiA/IDAgOiBNYXRoLm1heChtYXhNYXJnaW5MZWZ0ICsgMSwgMSksXG4gICAgICAgICAgICByaWdodDogaGFzUHJvamVjdGlvbiA/IDAgOiBvbmVEaW1ZID8gMCA6IE1hdGgubWF4KG1heE1hcmdpblJpZ2h0ICsgMSwgNCksXG4gICAgICAgICAgICB0b3A6IGhhc1Byb2plY3Rpb24gPyAwIDogb25lRGltWCA/IDAgOiBNYXRoLm1heCg1LCBtYXhNYXJnaW5Ub3ApLFxuICAgICAgICAgICAgYm90dG9tOiBoYXNQcm9qZWN0aW9uID8gMCA6IE1hdGgubWF4KDUsIG1heE1hcmdpbkJvdHRvbSlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGU6ICcnLFxuICAgICAgICAgICAgc3VidGl0bGU6ICcnLFxuICAgICAgICAgICAgY2FwdGlvbjogJycsXG4gICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgIC8vIG1heFdpZHRoOiBvbmVEaW1ZID8gYCR7NjAgKiBlfXB4YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IG1heWJlTWFyZ2luKG1hcmdpbiwgJ2xlZnQnLCBERUZBVUxUUy5tYXJnaW4sIGF1dG9NYXJnaW5zKSxcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBtYXliZU1hcmdpbihtYXJnaW4sICdyaWdodCcsIERFRkFVTFRTLm1hcmdpbiwgYXV0b01hcmdpbnMpLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiBtYXliZU1hcmdpbihtYXJnaW4sICd0b3AnLCBERUZBVUxUUy5tYXJnaW4sIGF1dG9NYXJnaW5zKSxcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogbWF5YmVNYXJnaW4obWFyZ2luLCAnYm90dG9tJywgREVGQVVMVFMubWFyZ2luLCBhdXRvTWFyZ2lucyksXG4gICAgICAgICAgICBpbnNldDogaXNPbmVEaW1lbnNpb25hbCA/IDEwIDogREVGQVVMVFMuaW5zZXQsXG4gICAgICAgICAgICBncmlkOiAoREVGQVVMVFMuZ3JpZFg/LmltcGxpY2l0ID8/IGZhbHNlKSAmJiAoREVGQVVMVFMuZ3JpZFk/LmltcGxpY2l0ID8/IGZhbHNlKSxcbiAgICAgICAgICAgIGF4ZXM6IChERUZBVUxUUy5heGlzWD8uaW1wbGljaXQgPz8gZmFsc2UpICYmIChERUZBVUxUUy5heGlzWT8uaW1wbGljaXQgPz8gZmFsc2UpLFxuICAgICAgICAgICAgZnJhbWU6IERFRkFVTFRTLmZyYW1lPy5pbXBsaWNpdCA/PyBmYWxzZSxcbiAgICAgICAgICAgIHByb2plY3Rpb246IG51bGwsXG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogbnVsbCxcbiAgICAgICAgICAgIGZhY2V0OiB7fSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAuMSxcbiAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgYXhpczogREVGQVVMVFMuYXhpc1guaW1wbGljaXQgJiYgYXV0b1hBeGlzID8gREVGQVVMVFMuYXhpc1guYW5jaG9yIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWxBbmNob3I6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbGFtcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmljZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgemVybzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcm91bmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsaWduOiAwLjUsXG4gICAgICAgICAgICAgICAgdGlja1NwYWNpbmc6IERFRkFVTFRTLmF4aXNYLnRpY2tTcGFjaW5nID8/IDgwLFxuICAgICAgICAgICAgICAgIHRpY2tGb3JtYXQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBncmlkOiBERUZBVUxUUy5ncmlkWC5pbXBsaWNpdCA/PyBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgYXhpczogREVGQVVMVFMuYXhpc1kuaW1wbGljaXQgJiYgYXV0b1lBeGlzID8gREVGQVVMVFMuYXhpc1kuYW5jaG9yIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFiZWxBbmNob3I6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbGFtcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmljZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgemVybzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcm91bmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsaWduOiAwLjUsXG4gICAgICAgICAgICAgICAgdGlja1NwYWNpbmc6IERFRkFVTFRTLmF4aXNZLnRpY2tTcGFjaW5nID8/IDUwLFxuICAgICAgICAgICAgICAgIHRpY2tGb3JtYXQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBncmlkOiBERUZBVUxUUy5ncmlkWS5pbXBsaWNpdCA/PyBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbGFtcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmljZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgemVybzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcm91bmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRpY2tTcGFjaW5nOiAwLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAuMSxcbiAgICAgICAgICAgICAgICBhbGlnbjogMC41XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzcXJ0JyxcbiAgICAgICAgICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbGFtcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmljZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgemVybzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByb3VuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgICAgICBhbGlnbjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiB7IHR5cGU6ICdhdXRvJywgdW5rbm93bjogREVGQVVMVFMudW5rbm93biB9LFxuICAgICAgICAgICAgbGVuZ3RoOiB7IHR5cGU6ICdsaW5lYXInIH0sXG4gICAgICAgICAgICBzeW1ib2w6IHsgdHlwZTogJ29yZGluYWwnIH0sXG4gICAgICAgICAgICBmeDogeyB0eXBlOiAnYmFuZCcsIGF4aXM6ICd0b3AnIH0sXG4gICAgICAgICAgICBmeTogeyB0eXBlOiAnYmFuZCcsIGF4aXM6ICdyaWdodCcgfSxcbiAgICAgICAgICAgIGxvY2FsZTogREVGQVVMVFMubG9jYWxlLFxuICAgICAgICAgICAgY3NzOiBERUZBVUxUUy5jc3NcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXBYWSA9ICRkZXJpdmVkKCh4OiBSYXdWYWx1ZSwgeTogUmF3VmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgW3B4LCBweV0gPSBwcm9qZWN0WFkocGxvdFN0YXRlLnNjYWxlcywgeCwgeSk7XG4gICAgICAgIHJldHVybiB7IHg6IHB4LCB5OiBweSB9O1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxmaWd1cmVcbiAgICBjbGFzcz1cInN2ZWx0ZXBsb3Qge2NsYXNzTmFtZX1cIlxuICAgIGJpbmQ6Y2xpZW50V2lkdGg9e3dpZHRofVxuICAgIHN0eWxlOm1heC13aWR0aD17cGxvdE9wdGlvbnMubWF4V2lkdGh9XG4gICAgZGF0YS10ZXN0aWQ9e3Rlc3RpZH0+XG4gICAgeyNpZiBoZWFkZXJ9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwbG90LWhlYWRlclwiPlxuICAgICAgICAgICAge0ByZW5kZXIgaGVhZGVyPy4oKX1cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cbiAgICA8ZGl2IGNsYXNzPVwicGxvdC1ib2R5XCIgYmluZDp0aGlzPXtwbG90Qm9keX0+XG4gICAgICAgIHsjaWYgdW5kZXJsYXl9PGRpdiBjbGFzcz1cInBsb3QtdW5kZXJsYXlcIj57QHJlbmRlciB1bmRlcmxheShwbG90T3B0aW9ucyl9PC9kaXY+ey9pZn1cbiAgICAgICAgPHN2Z1xuICAgICAgICAgICAgd2lkdGg9e2ZpeGVkV2lkdGggfHwgd2lkdGh9XG4gICAgICAgICAgICB7aGVpZ2h0fVxuICAgICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICB2aWV3Qm94PVwiMCAwIHt3aWR0aH0ge2hlaWdodH1cIj5cbiAgICAgICAgICAgIHtAcmVuZGVyIGZhY2V0QXhlcz8uKCl9XG4gICAgICAgICAgICA8RmFjZXRHcmlkIG1hcmtzPXtleHBsaWNpdE1hcmtzfT5cbiAgICAgICAgICAgICAgICB7I2lmIGNoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICB7QHJlbmRlciBjaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHBsb3RPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVzOiBwbG90U3RhdGUuc2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwWFksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9qZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXhwbGljaXRBeGlzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0V4cGxpY2l0QXhpc1ksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFeHBsaWNpdEdyaWRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXhwbGljaXRHcmlkWVxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9GYWNldEdyaWQ+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICB7I2lmIG92ZXJsYXl9PGRpdiBjbGFzcz1cInBsb3Qtb3ZlcmxheVwiPlxuICAgICAgICAgICAgICAgIHtAcmVuZGVyIG92ZXJsYXk/Lih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHBsb3RPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZXM6IHBsb3RTdGF0ZS5zY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgIG1hcFhZLFxuICAgICAgICAgICAgICAgICAgICBoYXNQcm9qZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoYXNFeHBsaWNpdEF4aXNYLFxuICAgICAgICAgICAgICAgICAgICBoYXNFeHBsaWNpdEF4aXNZLFxuICAgICAgICAgICAgICAgICAgICBoYXNFeHBsaWNpdEdyaWRYLFxuICAgICAgICAgICAgICAgICAgICBoYXNFeHBsaWNpdEdyaWRZXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8L2Rpdj57L2lmfVxuICAgIDwvZGl2PlxuICAgIHsjaWYgZm9vdGVyfVxuICAgICAgICA8ZmlnY2FwdGlvbiBjbGFzcz1cInBsb3QtZm9vdGVyXCI+XG4gICAgICAgICAgICB7QHJlbmRlciBmb290ZXI/LigpfVxuICAgICAgICA8L2ZpZ2NhcHRpb24+XG4gICAgey9pZn1cbjwvZmlndXJlPlxuXG48c3R5bGU+XG4gICAgZmlndXJlIHtcbiAgICAgICAgLS1zdnAtYmc6IHZhcigtLXN2ZWx0ZXBsb3QtYmcsIHdoaXRlKTtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cblxuICAgIC5wbG90LWJvZHkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuXG4gICAgLnBsb3Qtb3ZlcmxheSxcbiAgICAucGxvdC11bmRlcmxheSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAucGxvdC11bmRlcmxheSB7XG4gICAgICAgIHotaW5kZXg6IC0xO1xuICAgIH1cblxuICAgIC5wbG90LWhlYWRlciB7XG4gICAgICAgIG1hcmdpbi10b3A6IDFyZW07XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHJvdy1nYXA6IDAuMzVyZW07XG4gICAgfVxuXG4gICAgLnBsb3QtaGVhZGVyIDpnbG9iYWwoaDIpLFxuICAgIC5wbG90LWhlYWRlciA6Z2xvYmFsKGgzKSB7XG4gICAgICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICAgICAgICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIGJvcmRlcjogMCAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5wbG90LWZvb3RlciB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDJyZW07XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function Plot($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Plot);
  append_styles($$anchor, $$css);
  const $autoMarginLeft = () => (validate_store(autoMarginLeft, "autoMarginLeft"), store_get(autoMarginLeft, "$autoMarginLeft", $$stores));
  const $autoMarginRight = () => (validate_store(autoMarginRight, "autoMarginRight"), store_get(autoMarginRight, "$autoMarginRight", $$stores));
  const $autoMarginBottom = () => (validate_store(autoMarginBottom, "autoMarginBottom"), store_get(autoMarginBottom, "$autoMarginBottom", $$stores));
  const $autoMarginTop = () => (validate_store(autoMarginTop, "autoMarginTop"), store_get(autoMarginTop, "$autoMarginTop", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let autoMarginLeft = writable(new SvelteMap());
  let autoMarginRight = writable(new SvelteMap());
  let autoMarginBottom = writable(new SvelteMap());
  let autoMarginTop = writable(new SvelteMap());
  setContext("svelteplot/autoMargins", {
    autoMarginLeft,
    autoMarginRight,
    autoMarginBottom,
    autoMarginTop
  });
  const maxMarginLeft = tag(user_derived(() => Math.max(...$autoMarginLeft().values())), "maxMarginLeft");
  const maxMarginRight = tag(user_derived(() => Math.max(...$autoMarginRight().values())), "maxMarginRight");
  const maxMarginBottom = tag(user_derived(() => Math.max(...$autoMarginBottom().values())), "maxMarginBottom");
  const maxMarginTop = tag(user_derived(() => Math.max(...$autoMarginTop().values())), "maxMarginTop");
  const USER_DEFAULTS = getPlotDefaults();
  const DEFAULTS = {
    height: 350,
    initialWidth: 500,
    inset: 0,
    margin: "auto",
    colorScheme: "turbo",
    unknown: "#cccccc99",
    sortOrdinalDomains: true,
    categoricalColorScheme: "observable10",
    pointScaleHeight: 20,
    bandScaleHeight: 30,
    locale: "en-US",
    numberFormat: {
      style: "decimal",
      // notation: 'compact',
      useGrouping: "min2",
      compactDisplay: "short"
    },
    markerDotRadius: 3,
    ...USER_DEFAULTS,
    axisX: {
      anchor: "bottom",
      implicit: true,
      ...USER_DEFAULTS.axis,
      ...USER_DEFAULTS.axisX
    },
    axisY: {
      anchor: "left",
      implicit: true,
      ...USER_DEFAULTS.axis,
      ...USER_DEFAULTS.axisY
    },
    gridX: {
      implicit: false,
      ...USER_DEFAULTS.grid,
      ...USER_DEFAULTS.gridX
    },
    gridY: {
      implicit: false,
      ...USER_DEFAULTS.grid,
      ...USER_DEFAULTS.gridY
    }
  };
  let className = prop($$props, "class", 3, ""), css = prop($$props, "css", 19, () => DEFAULTS.css), initialOptions = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "header",
      "footer",
      "overlay",
      "underlay",
      "children",
      "facetAxes",
      "testid",
      "facet",
      "class",
      "css",
      "width"
    ],
    "initialOptions"
  );
  let width = tag(state(proxy(DEFAULTS.initialWidth)), "width");
  setPlotDefaults(DEFAULTS);
  let marks = tag(state([]), "marks");
  const explicitMarks = tag(user_derived(() => get(marks).filter((m) => !m.options.automatic)), "explicitMarks");
  const hasExplicitAxisX = tag(user_derived(() => !!get(explicitMarks).find((m) => strict_equals(m.type, "axisX"))), "hasExplicitAxisX");
  const hasExplicitAxisY = tag(user_derived(() => !!get(explicitMarks).find((m) => strict_equals(m.type, "axisY"))), "hasExplicitAxisY");
  const hasExplicitGridX = tag(user_derived(() => !!get(explicitMarks).find((m) => strict_equals(m.type, "gridX"))), "hasExplicitGridX");
  const hasExplicitGridY = tag(user_derived(() => !!get(explicitMarks).find((m) => strict_equals(m.type, "gridY"))), "hasExplicitGridY");
  const explicitScales = tag(
    user_derived(() => new Set(get(explicitMarks).map((m) => [...m.scales.values()].filter((scale) => {
      const channels = Object.entries(CHANNEL_SCALE).filter(([, scaleName]) => strict_equals(scale, scaleName)).map(([channel]) => channel);
      return channels.find((channel) => equals(m.options[channel], null, false));
    })).flat(1))),
    "explicitScales"
  );
  const explicitDomains = tag(user_derived(() => new Set(SCALES.filter((scale) => !!initialOptions[scale]?.domain))), "explicitDomains");
  const isOneDimensional = tag(user_derived(() => strict_equals(get(explicitScales).has("x"), get(explicitScales).has("y"), false)), "isOneDimensional");
  const plotOptions = tag(
    user_derived(() => extendPlotOptions(initialOptions, {
      explicitScales: get(explicitScales),
      explicitDomains: get(explicitDomains),
      hasProjection: !!$$props.projection,
      margin: $$props.margin,
      inset: $$props.inset
    })),
    "plotOptions"
  );
  const hasFilledDotMarks = tag(user_derived(() => !!get(explicitMarks).find((d) => strict_equals(d.type, "dot") && d.options.fill)), "hasFilledDotMarks");
  const preScales = tag(user_derived(() => computeScales(get(plotOptions), get(width), 400, get(hasFilledDotMarks), get(marks), DEFAULTS)), "preScales");
  const hasProjection = tag(user_derived(() => !!get(preScales).projection), "hasProjection");
  const plotWidth = tag(user_derived(() => ($$props.width || get(width)) - get(plotOptions).marginLeft - get(plotOptions).marginRight), "plotWidth");
  const xFacetCount = tag(user_derived(() => Math.max(1, get(preScales).fx.domain.length)), "xFacetCount");
  const yFacetCount = tag(user_derived(() => Math.max(1, get(preScales).fy.domain.length)), "yFacetCount");
  const yDomainCount = tag(user_derived(() => get(isOneDimensional) && get(explicitScales).has("x") ? 1 : get(preScales).y.domain.length), "yDomainCount");
  const defaultPointScaleHeight = tag(
    user_derived(() => get(explicitScales).has("r") && get(plotOptions).r.range ? get(plotOptions).r.range[1] * 2 : DEFAULTS.pointScaleHeight),
    "defaultPointScaleHeight"
  );
  const height = tag(
    user_derived(() => strict_equals(typeof get(plotOptions).height, "function") ? get(plotOptions).height(get(plotWidth)) : strict_equals(maybeNumber(get(plotOptions).height), null) || strict_equals(get(plotOptions).height, "auto") ? Math.round(get(preScales).projection && get(preScales).projection.aspectRatio ? get(plotWidth) * get(preScales).projection.aspectRatio / get(xFacetCount) * get(yFacetCount) + get(plotOptions).marginTop + get(plotOptions).marginBottom : get(plotOptions).aspectRatio ? heightFromAspect(get(preScales).x, get(preScales).y, get(plotOptions).aspectRatio, get(plotWidth), get(plotOptions).marginTop, get(plotOptions).marginBottom) : (get(isOneDimensional) && get(explicitScales).has("x") || !get(explicitMarks).length ? get(yFacetCount) * DEFAULTS.bandScaleHeight : strict_equals(get(preScales).y.type, "band") ? get(yFacetCount) * get(yDomainCount) * DEFAULTS.bandScaleHeight : strict_equals(get(preScales).y.type, "point") ? get(yFacetCount) * get(yDomainCount) * get(defaultPointScaleHeight) : DEFAULTS.height) + get(plotOptions).marginTop + get(plotOptions).marginBottom) : maybeNumber(get(plotOptions).height)),
    "height"
  );
  const plotHeight = tag(user_derived(() => get(height) - get(plotOptions).marginTop - get(plotOptions).marginBottom), "plotHeight");
  let plotBody = tag(state(null), "plotBody");
  let facetWidth = tag(state(null), "facetWidth");
  let facetHeight = tag(state(null), "facetHeight");
  let plotState = setPlot(computePlotState());
  user_effect(() => {
    plotState.update(computePlotState());
  });
  function computePlotState() {
    const scales = computeScales(get(plotOptions), get(facetWidth) || get(width), get(facetHeight) || get(height), get(hasFilledDotMarks), get(marks), DEFAULTS);
    const colorSymbolRedundant = strict_equals(scales.color.uniqueScaleProps?.size, 1) && strict_equals(scales.symbol.uniqueScaleProps?.size, 1) && strict_equals([...scales.color.uniqueScaleProps?.values()][0], [...scales.symbol.uniqueScaleProps?.values()][0]);
    return {
      options: get(plotOptions),
      width: get(width),
      height: get(height),
      facetWidth: get(facetWidth),
      facetHeight: get(facetHeight),
      plotHeight: get(plotHeight),
      plotWidth: get(plotWidth),
      scales,
      colorSymbolRedundant,
      hasFilledDotMarks: get(hasFilledDotMarks),
      body: get(plotBody),
      css: css()
    };
  }
  setContext("svelteplot", {
    /**
     * used by the Mark component to register new marks to the plot
     */
    addMark(mark) {
      if (get(marks).find((m) => strict_equals(m.id, mark.id))) {
        return;
      }
      set(marks, [...get(marks), mark]);
    },
    /**
     * used by the Mark component to update marks when its props change
     */
    updateMark(mark) {
    },
    /**
     * used by the Mark component to unregister marks when their
     * respective components get removed from the plot
     */
    removeMark(mark) {
      set(marks, get(marks).filter((m) => strict_equals(m.id, mark.id, false)));
    },
    getPlotState() {
      return plotState;
    },
    getTopLevelFacet() {
      return $$props.facet;
    },
    updateDimensions(w, h) {
      if (strict_equals(get(facetWidth), w, false)) set(facetWidth, w, true);
      if (strict_equals(get(facetHeight), h, false)) set(facetHeight, h, true);
    },
    updatePlotState() {
      plotState.update(computePlotState());
    }
  });
  function getWidth() {
    return get(width);
  }
  function heightFromAspect(x2, y2, aspectRatio, plotWidth2, marginTop, marginBottom) {
    const xDomainExtent = strict_equals(x2.type, "band") || strict_equals(x2.type, "point") ? x2.domain.length : Math.abs(x2.domain[1] - x2.domain[0]);
    const yDomainExtent = strict_equals(y2.type, "band") || strict_equals(y2.type, "point") ? y2.domain.length : Math.abs(y2.domain[1] - y2.domain[0]);
    return plotWidth2 / xDomainExtent * yDomainExtent / aspectRatio + marginTop + marginBottom;
  }
  function extendPlotOptions(initialOpts, opts) {
    return mergeDeep({}, { sortOrdinalDomains: DEFAULTS.sortOrdinalDomains }, smartDefaultPlotOptions(opts), initialOptions);
  }
  function maybeMargin(margin, direction, defaultValue, autoMargins) {
    const marginValue = strict_equals(typeof margin, "object") && equals(margin[direction], null, false) ? margin[direction] : (
      // use the margin value if it's a number
      strict_equals(typeof margin, "number") || strict_equals(margin, "auto") ? margin : (
        // use direction-specific default value if defined
        strict_equals(typeof defaultValue, "object") && equals(defaultValue[direction], null, false) ? defaultValue[direction] : strict_equals(typeof defaultValue, "number") || strict_equals(defaultValue, "auto") ? defaultValue : "auto"
      )
    );
    return strict_equals(marginValue, "auto") ? autoMargins[direction] : marginValue;
  }
  function smartDefaultPlotOptions({ explicitScales: explicitScales2, explicitDomains: explicitDomains2, hasProjection: hasProjection2, margin }) {
    const autoXAxis = explicitScales2.has("x") || explicitDomains2.has("x");
    const autoYAxis = explicitScales2.has("y") || explicitDomains2.has("y");
    const isOneDimensional2 = strict_equals(autoXAxis, autoYAxis, false);
    const oneDimX = autoXAxis && !autoYAxis;
    const oneDimY = autoYAxis && !autoXAxis;
    const autoMargins = {
      left: hasProjection2 ? 0 : Math.max(get(maxMarginLeft) + 1, 1),
      right: hasProjection2 ? 0 : oneDimY ? 0 : Math.max(get(maxMarginRight) + 1, 4),
      top: hasProjection2 ? 0 : oneDimX ? 0 : Math.max(5, get(maxMarginTop)),
      bottom: hasProjection2 ? 0 : Math.max(5, get(maxMarginBottom))
    };
    return {
      title: "",
      subtitle: "",
      caption: "",
      height: "auto",
      // maxWidth: oneDimY ? `${60 * e}px` : undefined,
      marginLeft: maybeMargin(margin, "left", DEFAULTS.margin, autoMargins),
      marginRight: maybeMargin(margin, "right", DEFAULTS.margin, autoMargins),
      marginTop: maybeMargin(margin, "top", DEFAULTS.margin, autoMargins),
      marginBottom: maybeMargin(margin, "bottom", DEFAULTS.margin, autoMargins),
      inset: isOneDimensional2 ? 10 : DEFAULTS.inset,
      grid: (DEFAULTS.gridX?.implicit ?? false) && (DEFAULTS.gridY?.implicit ?? false),
      axes: (DEFAULTS.axisX?.implicit ?? false) && (DEFAULTS.axisY?.implicit ?? false),
      frame: DEFAULTS.frame?.implicit ?? false,
      projection: null,
      aspectRatio: null,
      facet: {},
      padding: 0.1,
      x: {
        type: "auto",
        axis: DEFAULTS.axisX.implicit && autoXAxis ? DEFAULTS.axisX.anchor : false,
        labelAnchor: "auto",
        reverse: false,
        clamp: false,
        nice: false,
        zero: false,
        round: false,
        percent: false,
        align: 0.5,
        tickSpacing: DEFAULTS.axisX.tickSpacing ?? 80,
        tickFormat: "auto",
        grid: DEFAULTS.gridX.implicit ?? false
      },
      y: {
        type: "auto",
        axis: DEFAULTS.axisY.implicit && autoYAxis ? DEFAULTS.axisY.anchor : false,
        labelAnchor: "auto",
        reverse: false,
        clamp: false,
        nice: false,
        zero: false,
        round: false,
        percent: false,
        align: 0.5,
        tickSpacing: DEFAULTS.axisY.tickSpacing ?? 50,
        tickFormat: "auto",
        grid: DEFAULTS.gridY.implicit ?? false
      },
      opacity: {
        type: "linear",
        reverse: false,
        clamp: false,
        nice: false,
        zero: false,
        round: false,
        tickSpacing: 0,
        percent: false,
        padding: 0.1,
        align: 0.5
      },
      r: {
        type: "sqrt",
        reverse: false,
        clamp: false,
        nice: false,
        zero: true,
        percent: false,
        round: false,
        padding: 0,
        align: 0
      },
      color: { type: "auto", unknown: DEFAULTS.unknown },
      length: { type: "linear" },
      symbol: { type: "ordinal" },
      fx: { type: "band", axis: "top" },
      fy: { type: "band", axis: "right" },
      locale: DEFAULTS.locale,
      css: DEFAULTS.css
    };
  }
  const mapXY = tag(
    user_derived(() => (x2, y2) => {
      const [px, py] = projectXY(plotState.scales, x2, y2);
      return { x: px, y: py };
    }),
    "mapXY"
  );
  var $$exports = {
    get getWidth() {
      return getWidth;
    },
    ...legacy_api()
  };
  var figure = root();
  let styles;
  var node = child(figure);
  {
    var consequent = ($$anchor2) => {
      var div = root_1();
      var node_1 = child(div);
      add_svelte_meta(() => snippet(node_1, () => $$props.header ?? noop), "render", Plot, 530, 12);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.header) $$render(consequent);
      }),
      "if",
      Plot,
      528,
      4
    );
  }
  var div_1 = sibling(node, 2);
  var node_2 = child(div_1);
  {
    var consequent_1 = ($$anchor2) => {
      var div_2 = root_22();
      var node_3 = child(div_2);
      add_svelte_meta(() => snippet(node_3, () => $$props.underlay, () => get(plotOptions)), "render", Plot, 534, 49);
      reset(div_2);
      append($$anchor2, div_2);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if ($$props.underlay) $$render(consequent_1);
      }),
      "if",
      Plot,
      534,
      8
    );
  }
  var svg = sibling(node_2, 2);
  var node_4 = child(svg);
  add_svelte_meta(() => snippet(node_4, () => $$props.facetAxes ?? noop), "render", Plot, 540, 12);
  var node_5 = sibling(node_4);
  add_svelte_meta(
    () => FacetGrid_default(node_5, {
      get marks() {
        return get(explicitMarks);
      },
      children: wrap_snippet(Plot, ($$anchor2, $$slotProps) => {
        var fragment = comment();
        var node_6 = first_child(fragment);
        {
          var consequent_2 = ($$anchor3) => {
            var fragment_1 = comment();
            var node_7 = first_child(fragment_1);
            add_svelte_meta(
              () => snippet(node_7, () => $$props.children, () => ({
                width: get(width),
                height: get(height),
                options: get(plotOptions),
                scales: plotState.scales,
                mapXY: get(mapXY),
                hasProjection: get(hasProjection),
                hasExplicitAxisX: get(hasExplicitAxisX),
                hasExplicitAxisY: get(hasExplicitAxisY),
                hasExplicitGridX: get(hasExplicitGridX),
                hasExplicitGridY: get(hasExplicitGridY)
              })),
              "render",
              Plot,
              543,
              20
            );
            append($$anchor3, fragment_1);
          };
          add_svelte_meta(
            () => if_block(node_6, ($$render) => {
              if ($$props.children) $$render(consequent_2);
            }),
            "if",
            Plot,
            542,
            16
          );
        }
        append($$anchor2, fragment);
      }),
      $$slots: { default: true }
    }),
    "component",
    Plot,
    541,
    12,
    { componentTag: "FacetGrid" }
  );
  reset(svg);
  var node_8 = sibling(svg, 2);
  {
    var consequent_3 = ($$anchor2) => {
      var div_3 = root_5();
      var node_9 = child(div_3);
      add_svelte_meta(
        () => snippet(node_9, () => $$props.overlay ?? noop, () => ({
          width: get(width),
          height: get(height),
          options: get(plotOptions),
          scales: plotState.scales,
          mapXY: get(mapXY),
          hasProjection: get(hasProjection),
          hasExplicitAxisX: get(hasExplicitAxisX),
          hasExplicitAxisY: get(hasExplicitAxisY),
          hasExplicitGridX: get(hasExplicitGridX),
          hasExplicitGridY: get(hasExplicitGridY)
        })),
        "render",
        Plot,
        559,
        16
      );
      reset(div_3);
      append($$anchor2, div_3);
    };
    add_svelte_meta(
      () => if_block(node_8, ($$render) => {
        if ($$props.overlay) $$render(consequent_3);
      }),
      "if",
      Plot,
      558,
      8
    );
  }
  reset(div_1);
  bind_this(div_1, ($$value) => set(plotBody, $$value), () => get(plotBody));
  var node_10 = sibling(div_1, 2);
  {
    var consequent_4 = ($$anchor2) => {
      var figcaption = root_6();
      var node_11 = child(figcaption);
      add_svelte_meta(() => snippet(node_11, () => $$props.footer ?? noop), "render", Plot, 575, 12);
      reset(figcaption);
      append($$anchor2, figcaption);
    };
    add_svelte_meta(
      () => if_block(node_10, ($$render) => {
        if ($$props.footer) $$render(consequent_4);
      }),
      "if",
      Plot,
      573,
      4
    );
  }
  reset(figure);
  template_effect(() => {
    set_class(figure, 1, `svelteplot ${className() ?? ""}`, "s-W5MRypdQgyoZ");
    set_attribute(figure, "data-testid", $$props.testid);
    styles = set_style(figure, "", styles, { "max-width": get(plotOptions).maxWidth });
    set_attribute(svg, "width", $$props.width || get(width));
    set_attribute(svg, "height", get(height));
    set_attribute(svg, "viewBox", `0 0 ${get(width) ?? ""} ${get(height) ?? ""}`);
  });
  bind_element_size(figure, "clientWidth", function set2($$value) {
    set(width, $$value);
  });
  append($$anchor, figure);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Plot = hmr(Plot);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-W5MRypdQgyoZ");
    Plot[HMR].update(module.default);
  });
}
var Plot_default = Plot;

// node_modules/es-toolkit/dist/function/noop.mjs
function noop3() {
}

// node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  };
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
var placeholderSymbol = /* @__PURE__ */ Symbol("partial.placeholder");
partial.placeholder = placeholderSymbol;

// node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  };
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
var placeholderSymbol2 = /* @__PURE__ */ Symbol("partialRight.placeholder");
partialRight.placeholder = placeholderSymbol2;

// node_modules/es-toolkit/dist/function/retry.mjs
var DEFAULT_RETRIES = Number.POSITIVE_INFINITY;

// node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}

// node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}

// node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}

// node_modules/es-toolkit/dist/object/pick.mjs
function pick(obj, keys) {
  const result = {};
  for (let i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (Object.hasOwn(obj, key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}

// node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// node_modules/es-toolkit/dist/_internal/isEqualsSameValueZero.mjs
function isEqualsSameValueZero(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}

// node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a2, b, areValuesEqual) {
  return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a2, b, property, aParent, bParent, stack, areValuesEqual) {
  const result = areValuesEqual(a2, b, property, aParent, bParent, stack);
  if (result !== void 0) {
    return result;
  }
  if (typeof a2 === typeof b) {
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a2 === b;
      }
      case "number": {
        return a2 === b || Object.is(a2, b);
      }
      case "function": {
        return a2 === b;
      }
      case "object": {
        return areObjectsEqual(a2, b, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a2, b, stack, areValuesEqual);
}
function areObjectsEqual(a2, b, stack, areValuesEqual) {
  if (Object.is(a2, b)) {
    return true;
  }
  let aTag = getTag(a2);
  let bTag = getTag(b);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a2.toString() === b.toString();
    case numberTag: {
      const x2 = a2.valueOf();
      const y2 = b.valueOf();
      return isEqualsSameValueZero(x2, y2);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a2.valueOf(), b.valueOf());
    case regexpTag: {
      return a2.source === b.source && a2.flags === b.flags;
    }
    case functionTag: {
      return a2 === b;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a2);
  const bStack = stack.get(b);
  if (aStack != null && bStack != null) {
    return aStack === b;
  }
  stack.set(a2, b);
  stack.set(b, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const [key2, value] of a2.entries()) {
          if (!b.has(key2) || !isEqualWithImpl(value, b.get(key2), key2, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a2.size !== b.size) {
          return false;
        }
        const aValues = Array.from(a2.values());
        const bValues = Array.from(b.values());
        for (let i = 0; i < aValues.length; i++) {
          const aValue = aValues[i];
          const index3 = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
          });
          if (index3 === -1) {
            return false;
          }
          bValues.splice(index3, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
          return false;
        }
        if (a2.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (!isEqualWithImpl(a2[i], b[i], i, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a2.byteLength !== b.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
      }
      case errorTag: {
        return a2.name === b.name && a2.message === b.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
        const bKeys = [...Object.keys(b), ...getSymbols(b)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i = 0; i < aKeys.length; i++) {
          const propKey = aKeys[i];
          const aProp = a2[propKey];
          if (!Object.hasOwn(b, propKey)) {
            return false;
          }
          const bProp = b[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a2);
    stack.delete(b);
  }
}

// node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual(a2, b) {
  return isEqualWith(a2, b, noop3);
}

// node_modules/svelteplot/dist/transforms/rename.js
var RENAME = "__renamed__";
function renameChannels({ data, ...channels }, options) {
  const newChannels = channels;
  for (const [from, to] of Object.entries(options)) {
    if (newChannels[from] !== void 0) {
      newChannels[to] = newChannels[from];
      newChannels[RENAME] = newChannels[RENAME] || {};
      newChannels[RENAME][to] = from;
      delete newChannels[from];
    }
  }
  return { data, ...newChannels };
}
function replaceChannels({ data, ...channels }, options) {
  const newChannels = { ...channels };
  for (const [from, to] of Object.entries(options)) {
    if (newChannels[from] !== void 0) {
      for (const t of to) {
        newChannels[t] = newChannels[from];
      }
      delete newChannels[from];
    }
  }
  return { data, ...newChannels };
}

// node_modules/svelteplot/dist/transforms/dodge.js
var import_interval_tree_1d = __toESM(require_interval_tree(), 1);

// node_modules/svelteplot/dist/helpers/group.js
function groupFacetsAndZ(items, channels, reduce2) {
  const groupBy2 = ["fx", "fy", "z"].map((groupChannel) => {
    let groupByChannel = null;
    if (groupChannel === "z") {
      if (channels.z)
        groupByChannel = "z";
      else if (channels.fill)
        groupByChannel = "fill";
      else if (channels.stroke)
        groupByChannel = "stroke";
    } else if (channels[groupChannel]) {
      groupByChannel = groupChannel;
    }
    if (groupByChannel) {
      const groupByPropName = typeof channels[groupByChannel] === "string" ? channels[groupByChannel] : `__group_${groupByChannel}`;
      return [
        groupByChannel,
        groupByPropName,
        (d) => resolveChannel(groupByChannel, d, channels)
      ];
    } else {
      return [null, null, () => true];
    }
  });
  const groups2 = groups(items, ...groupBy2.map((d) => d[2]));
  for (const [fxKey, fxGroups] of groups2) {
    const newItemGroupProps = {};
    if (groupBy2[0][0] !== null && groupBy2[0][1])
      newItemGroupProps[groupBy2[0][1]] = fxKey;
    for (const [fyKey, fyGroups] of fxGroups) {
      if (groupBy2[1][0] !== null && groupBy2[1][1])
        newItemGroupProps[groupBy2[1][1]] = fyKey;
      for (const [zKey, zGroups] of fyGroups) {
        if (groupBy2[2][0] !== null && groupBy2[2][1])
          newItemGroupProps[groupBy2[2][1]] = zKey;
        reduce2(zGroups, newItemGroupProps);
      }
    }
  }
  return Object.fromEntries(groupBy2.filter(([groupByChannel]) => groupByChannel !== null).map(([groupByChannel, groupByProp]) => [groupByChannel, groupByProp]));
}

// node_modules/svelteplot/dist/transforms/dodge.js
function dodgeX(args, plotState) {
  if (!args.dodgeX)
    return args.data;
  let { anchor = "left", padding = 1, r = args.dodgeX.r } = maybeAnchor(args.dodgeX);
  let anchorFunction;
  switch (`${anchor}`.toLowerCase()) {
    case "left":
      anchorFunction = anchorXLeft;
      break;
    case "right":
      anchorFunction = anchorXRight;
      break;
    case "middle":
      anchorFunction = anchorXMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("x", "y", anchorFunction, Number(padding), r, args, plotState);
}
function dodgeY(args, plotState) {
  if (!args.dodgeY)
    return args.data;
  let { anchor = "bottom", padding = 1, r = args.dodgeY.r } = maybeAnchor(args.dodgeY);
  let anchorFunction;
  switch (`${anchor}`.toLowerCase()) {
    case "top":
      anchorFunction = anchorYTop;
      break;
    case "bottom":
      anchorFunction = anchorYBottom;
      break;
    case "middle":
      anchorFunction = anchorYMiddle;
      break;
    default:
      throw new Error(`unknown dodge anchor: ${anchor}`);
  }
  return dodge("y", "x", anchorFunction, Number(padding), r, args, plotState);
}
function dodge(y2, x2, anchor, padding, r, { data, ...channels }, plotState) {
  if (r != null && typeof r !== "number") {
  }
  const { fx, fy } = channels;
  let [ky2, ty] = anchor(plotState);
  const compare = ky2 ? compareAscending : compareSymmetric;
  const cr = r !== void 0 ? r : 3;
  groupFacetsAndZ(data, { fx, fy }, (items) => {
    const tree = (0, import_interval_tree_1d.default)();
    const data2 = items.filter((d) => (typeof d.r !== "number" || d.r >= 0) && isFinite(d[x2]) && isFinite(d[y2]));
    const intervals = new Float64Array(2 * data2.length + 2);
    data2.forEach((d, i) => {
      const ri = d.r ?? r ?? 3;
      const y06 = ky2 ? ri + padding : 0;
      const l = d[x2] - ri;
      const h = d[x2] + ri;
      let k2 = 2;
      tree.queryInterval(l - padding, h + padding, ([, , j]) => {
        const yj = data2[j][y2] - y06;
        const dx = d[x2] - data2[j][x2];
        const dr = padding + (channels.r ? d.r + data2[j].r : 2 * cr);
        const dy = Math.sqrt(dr * dr - dx * dx);
        intervals[k2++] = yj - dy;
        intervals[k2++] = yj + dy;
      });
      let candidates = intervals.slice(0, k2);
      if (ky2)
        candidates = candidates.filter((y3) => y3 >= 0);
      out: for (const diff of candidates.sort(compare)) {
        for (let j = 0; j < k2; j += 2) {
          if (intervals[j] + 1e-6 < diff && diff < intervals[j + 1] - 1e-6) {
            continue out;
          }
        }
        d[y2] = diff + y06;
        break;
      }
      tree.insert([l, h, i]);
    });
    if (!ky2)
      ky2 = 1;
    data2.forEach((d) => d[y2] = d[y2] * ky2 + ty);
  });
  return data;
}
function maybeAnchor(anchor) {
  return typeof anchor === "string" ? { anchor } : anchor;
}
function anchorXLeft({ options: { marginLeft } }) {
  return [1, marginLeft];
}
function anchorXRight({ facetWidth: width, options: { marginLeft } }) {
  return [-1, marginLeft + width];
}
function anchorXMiddle({ facetWidth: width, options: { marginLeft } }) {
  return [0, marginLeft + width / 2];
}
function anchorYTop({ options: { marginTop } }) {
  return [1, marginTop];
}
function anchorYBottom({ facetHeight: height }) {
  return [-1, height];
}
function anchorYMiddle({ facetHeight: height, options: { marginTop, marginBottom } }) {
  return [0, (marginTop + height) / 2];
}
function compareSymmetric(a2, b) {
  return Math.abs(a2) - Math.abs(b);
}
function compareAscending(a2, b) {
  return a2 - b;
}

// node_modules/svelteplot/dist/Mark.svelte
Mark_1[FILENAME] = "node_modules/svelteplot/dist/Mark.svelte";
var root_23 = add_locations(from_svg(`<tspan x="0"> </tspan>`), Mark_1[FILENAME], [[315, 12]]);
var root_12 = add_locations(from_svg(`<text transform="translate(10,10)" class="s-QPlHLQ7s6Rt0"></text>`), Mark_1[FILENAME], [[313, 4]]);
var $$css2 = {
  hash: "s-QPlHLQ7s6Rt0",
  code: "\n    text.s-QPlHLQ7s6Rt0 {\n        stroke: var(--svp-bg);\n        fill: crimson;\n        font-size: 11px;\n        stroke-width: 3px;\n        font-weight: bold;\n        paint-order: stroke fill;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFyay5zdmVsdGUiLCJzb3VyY2VzIjpbIk1hcmsuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJEYXR1bSBleHRlbmRzIERhdGFSZWNvcmRcIj5cbiAgICBpbnRlcmZhY2UgTWFya1Byb3BzIGV4dGVuZHMgUGFydGlhbDxCYXNlTWFya1Byb3BzPERhdHVtPj4ge1xuICAgICAgICBkYXRhPzogRGF0dW1bXTtcbiAgICAgICAgYXV0b21hdGljPzogYm9vbGVhbjtcbiAgICAgICAgdHlwZTogTWFya1R5cGU7XG4gICAgICAgIGNoYW5uZWxzPzogU2NhbGVkQ2hhbm5lbE5hbWVbXTtcbiAgICAgICAgcmVxdWlyZWQ/OiBTY2FsZWRDaGFubmVsTmFtZVtdO1xuICAgICAgICByZXF1aXJlZFNjYWxlcz86IFBhcnRpYWw8UmVjb3JkPFNjYWxlTmFtZSwgU2NhbGVUeXBlW10+PjtcbiAgICAgICAgY2hpbGRyZW4/OiBTbmlwcGV0PFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyazogTWFyazxHZW5lcmljTWFya09wdGlvbnM+O1xuICAgICAgICAgICAgICAgICAgICB1c2VkU2NhbGVzOiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRVc2VkU2NhbGVzPjtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVkRGF0YTogU2NhbGVkRGF0YVJlY29yZDxEYXR1bT5bXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgID47XG4gICAgICAgIGRlZmF1bHRzPzogUGFydGlhbDxSZWNvcmQ8U2NhbGVkQ2hhbm5lbE5hbWUsIFJhd1ZhbHVlPj47XG4gICAgfVxuXG4gICAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgdW50cmFjaywgdHlwZSBTbmlwcGV0IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBDSEFOTkVMX1NDQUxFLCBJTkRFWCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbiAgICBpbXBvcnQgdHlwZSB7XG4gICAgICAgIFNjYWxlZENoYW5uZWxOYW1lLFxuICAgICAgICBNYXJrVHlwZSxcbiAgICAgICAgRGF0YVJlY29yZCxcbiAgICAgICAgUGxvdENvbnRleHQsXG4gICAgICAgIENoYW5uZWxOYW1lLFxuICAgICAgICBHZW5lcmljTWFya09wdGlvbnMsXG4gICAgICAgIENoYW5uZWxBY2Nlc3NvcixcbiAgICAgICAgQmFzZU1hcmtQcm9wcyxcbiAgICAgICAgRmFjZXRDb250ZXh0LFxuICAgICAgICBTY2FsZU5hbWUsXG4gICAgICAgIFJhd1ZhbHVlLFxuICAgICAgICBSZXNvbHZlZERhdGFSZWNvcmQsXG4gICAgICAgIFNjYWxlZERhdGFSZWNvcmQsXG4gICAgICAgIFNjYWxlVHlwZVxuICAgIH0gZnJvbSAnLi90eXBlcy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgaXNFcXVhbCB9IGZyb20gJ2VzLXRvb2xraXQnO1xuICAgIGltcG9ydCB7IGdldFVzZWRTY2FsZXMsIHByb2plY3RYWSwgcHJvamVjdFgsIHByb2plY3RZIH0gZnJvbSAnLi9oZWxwZXJzL3NjYWxlcy5qcyc7XG4gICAgaW1wb3J0IHsgdGVzdEZpbHRlciwgaXNWYWxpZCB9IGZyb20gJy4vaGVscGVycy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgcmVzb2x2ZUNoYW5uZWwsIHJlc29sdmVQcm9wIH0gZnJvbSAnLi9oZWxwZXJzL3Jlc29sdmUuanMnO1xuICAgIGltcG9ydCB7IFJFTkFNRSB9IGZyb20gJy4vdHJhbnNmb3Jtcy9yZW5hbWUuanMnO1xuICAgIGltcG9ydCB7IGRvZGdlWCwgZG9kZ2VZIH0gZnJvbSAnLi90cmFuc2Zvcm1zL2RvZGdlLmpzJztcblxuICAgIGxldCB7XG4gICAgICAgIGRhdGEgPSBbXSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoYW5uZWxzID0gW10sXG4gICAgICAgIHJlcXVpcmVkID0gW10sXG4gICAgICAgIHJlcXVpcmVkU2NhbGVzID0ge30sXG4gICAgICAgIGRlZmF1bHRzID0ge30sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9OiBNYXJrUHJvcHMgPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGNoYW5uZWxzV2l0aEZhY2V0czogU2NhbGVkQ2hhbm5lbE5hbWVbXSA9ICRkZXJpdmVkKFsuLi5jaGFubmVscywgJ2Z4JywgJ2Z5J10pO1xuXG4gICAgY29uc3QgeyBhZGRNYXJrLCByZW1vdmVNYXJrLCBnZXRUb3BMZXZlbEZhY2V0LCBnZXRQbG90U3RhdGUgfSA9XG4gICAgICAgIGdldENvbnRleHQ8UGxvdENvbnRleHQ+KCdzdmVsdGVwbG90Jyk7XG5cbiAgICBjb25zdCBwbG90ID0gJGRlcml2ZWQoZ2V0UGxvdFN0YXRlKCkpO1xuICAgIGNvbnN0IGZhY2V0ID0gJGRlcml2ZWQoZ2V0VG9wTGV2ZWxGYWNldCgpKTtcblxuICAgIGNvbnN0IHsgZ2V0RmFjZXRTdGF0ZSB9ID0gZ2V0Q29udGV4dDxGYWNldENvbnRleHQ+KCdzdmVsdGVwbG90L2ZhY2V0Jyk7XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9ICRkZXJpdmVkKGdldEZhY2V0U3RhdGUoKSk7XG5cbiAgICBjbGFzcyBNYXJrIHtcbiAgICAgICAgaWQ7XG4gICAgICAgIHR5cGU7XG4gICAgICAgIGNoYW5uZWxzOiBTY2FsZWRDaGFubmVsTmFtZVtdID0gJHN0YXRlLnJhdyhbXSk7XG4gICAgICAgIHNjYWxlczogU2V0PFNjYWxlTmFtZT4gPSAkc3RhdGUucmF3KG5ldyBTZXQoKSk7XG4gICAgICAgIGRhdGE6IERhdGFSZWNvcmRbXSA9ICRzdGF0ZS5yYXcoW10pO1xuICAgICAgICBvcHRpb25zOiBHZW5lcmljTWFya09wdGlvbnMgPSAkc3RhdGUucmF3KHt9KTtcblxuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlOiBNYXJrVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IFN5bWJvbCgpO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hcmsgPSBuZXcgTWFyayh0eXBlKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlTWFyayhtYXJrKTtcbiAgICAgICAgICAgIGFkZGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBsZXQgbWFyazIgPSAkc3RhdGUobWFyayk7XG4gICAgY29uc3QgZmFjZXRNb2RlID0gJGRlcml2ZWQob3B0aW9ucy5mYWNldCB8fCAnYXV0bycpO1xuXG4gICAgY29uc3Qgb3B0aW9uc1dpdGhBdXRvRmFjZXQgPSAkZGVyaXZlZCh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIF9fZmlyc3RGYWNldDogbGVmdCAmJiB0b3AsXG4gICAgICAgIC4uLihmYWNldCAmJlxuICAgICAgICBmYWNldC5kYXRhICYmXG4gICAgICAgICgoZmFjZXRNb2RlID09PSAnYXV0bycgJiYgZmFjZXQuZGF0YSA9PT0gZGF0YSkgfHwgZmFjZXRNb2RlID09PSAnaW5jbHVkZScpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGZ4OiBmYWNldC54LFxuICAgICAgICAgICAgICAgICAgZnk6IGZhY2V0LnlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSlcbiAgICB9KTtcblxuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZPcHRpb25zID0gdW50cmFjaygoKSA9PiBtYXJrLm9wdGlvbnMpO1xuICAgICAgICBpZiAoIWlzRXF1YWwocHJldk9wdGlvbnMsIG9wdGlvbnNXaXRoQXV0b0ZhY2V0KSkge1xuICAgICAgICAgICAgbWFyay5vcHRpb25zID0gb3B0aW9uc1dpdGhBdXRvRmFjZXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoYWRkZWQpIHJldHVybjtcbiAgICAgICAgLy8gd2l0aG91dCB1c2luZyB1bnRyYWNrKCkgaGVyZSB3ZSBlbmQgdXAgd2l0aCBpbmV4cGxpY2FibGVcbiAgICAgICAgLy8gY2lyY3VsYXIgZGVwZW5kZW5jeSB1cGRhdGVzIHJlc3VsdGluZyBpbiBhIHN0YWNrIG92ZXJmbG93XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gdW50cmFjaygoKSA9PiBjaGFubmVsc1dpdGhGYWNldHMpO1xuICAgICAgICBtYXJrLmNoYW5uZWxzID0gY2hhbm5lbHM7XG4gICAgICAgIG1hcmsuc2NhbGVzID0gbmV3IFNldChcbiAgICAgICAgICAgIGNoYW5uZWxzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoY2hhbm5lbCkgPT4gb3B0aW9uc1tjaGFubmVsXSAhPT0gMClcbiAgICAgICAgICAgICAgICAubWFwKChjaGFubmVsKSA9PiBDSEFOTkVMX1NDQUxFW2NoYW5uZWxdKVxuICAgICAgICApO1xuICAgICAgICBtYXJrLmRhdGEgPSB1bnRyYWNrKCgpID0+IGRhdGEpO1xuICAgICAgICBtYXJrLm9wdGlvbnMgPSB1bnRyYWNrKCgpID0+IG9wdGlvbnNXaXRoQXV0b0ZhY2V0KTtcblxuICAgICAgICBhZGRNYXJrKG1hcmspO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGdldFRlc3RGYWNldCB9ID0gZ2V0Q29udGV4dDxGYWNldENvbnRleHQ+KCdzdmVsdGVwbG90L2ZhY2V0Jyk7XG4gICAgY29uc3QgdGVzdEZhY2V0ID0gJGRlcml2ZWQoZ2V0VGVzdEZhY2V0KCkpO1xuXG4gICAgY29uc3QgcmVzb2x2ZWREYXRhOiBSZXNvbHZlZERhdGFSZWNvcmQ8RGF0dW0+W10gPSAkZGVyaXZlZChcbiAgICAgICAgZGF0YVxuICAgICAgICAgICAgLm1hcCgoZCwgaSkgPT4gKHsgLi4uZCwgW0lOREVYXTogaSB9KSlcbiAgICAgICAgICAgIC5mbGF0TWFwKChyb3csIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBvcHRpb25zIGFzIFJlY29yZDxDaGFubmVsTmFtZSwgQ2hhbm5lbEFjY2Vzc29yPERhdHVtPj47XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0RmFjZXQocm93LCBjaGFubmVscykgfHwgIXRlc3RGaWx0ZXIocm93LCBjaGFubmVscykpIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQ6IFJlc29sdmVkRGF0YVJlY29yZDxEYXR1bT4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdHVtOiByb3csXG4gICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGFubmVsXSBvZiBPYmplY3QuZW50cmllcyhDSEFOTkVMX1NDQUxFKSBhcyBbXG4gICAgICAgICAgICAgICAgICAgIFNjYWxlZENoYW5uZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBTY2FsZU5hbWVcbiAgICAgICAgICAgICAgICBdW10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG1hcmsgaGFzIGRlZmluZWQgYW4gYWNjZXNzb3IgZm9yIHRoaXMgY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8uW2NoYW5uZWxdICE9PSB1bmRlZmluZWQgJiYgb3V0W2NoYW5uZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtjaGFubmVsXSA9IHJlc29sdmVDaGFubmVsKGNoYW5uZWwsIHJvdywgb3B0aW9ucywgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbY2hhbm5lbF0gPT09IElOREVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBwbG90LnNjYWxlc1tDSEFOTkVMX1NDQUxFW2NoYW5uZWxdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gJ2JhbmQnIHx8IHNjYWxlLnR5cGUgPT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2NoYW5uZWxdID0gc2NhbGUuZG9tYWluW291dFtjaGFubmVsXSAlIHNjYWxlLmRvbWFpbi5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW291dF07XG4gICAgICAgICAgICB9KVxuICAgICk7XG5cbiAgICBsZXQgcHJldlJlc29sdmVkRGF0YTogUmVzb2x2ZWREYXRhUmVjb3JkW10gPSBbXTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaXNEaWZmZXJlbnQoZGF0YSwgbWFyay5kYXRhKSB8fCBpc0RpZmZlcmVudChyZXNvbHZlZERhdGEsIHByZXZSZXNvbHZlZERhdGEpKSB7XG4gICAgICAgICAgICBwcmV2UmVzb2x2ZWREYXRhID0gcmVzb2x2ZWREYXRhO1xuICAgICAgICAgICAgLy8gZGF0YSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgbWFyay5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaXNEaWZmZXJlbnQoYXJyYXkxOiBSZXNvbHZlZERhdGFSZWNvcmRbXSwgYXJyYXkyOiBSZXNvbHZlZERhdGFSZWNvcmRbXSkge1xuICAgICAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGFubmVsXSBvZiBPYmplY3QuZW50cmllcyhDSEFOTkVMX1NDQUxFKSBhcyBbXG4gICAgICAgICAgICAgICAgU2NhbGVkQ2hhbm5lbE5hbWUsXG4gICAgICAgICAgICAgICAgU2NhbGVOYW1lXG4gICAgICAgICAgICBdW10pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWwoYXJyYXkxW2ldW2NoYW5uZWxdLCBhcnJheTJbaV1bY2hhbm5lbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JzID0gJGRlcml2ZWQoW1xuICAgICAgICAuLi5yZXF1aXJlZFxuICAgICAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gb3B0aW9uc1tuYW1lXSA9PSBudWxsKVxuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4gYG1pc3NpbmcgY2hhbm5lbCB2YWx1ZSBmb3IgJHttYXJrLnR5cGV9IG1hcms6ICR7bmFtZX1gKSxcbiAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMocmVxdWlyZWRTY2FsZXMpXG4gICAgICAgICAgICAuZmlsdGVyKChbc2NhbGUsIHR5cGVzXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdHlwZXMuaW5jbHVkZXMocGxvdC5zY2FsZXNbc2NhbGVdLnR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICAgKFtzY2FsZSwgdHlwZXNdKSA9PiBgc2NhbGUgdHlwZSBtaXNtYXRjaCBmb3IgJHtzY2FsZX0gKG5lZWRzICR7dHlwZXMuam9pbignIG9yICcpfSlgXG4gICAgICAgICAgICApXG4gICAgXSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHJlcXVpcmVkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgY2hhbm5lbCB2YWx1ZTogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VkU2NhbGVzID0gJGRlcml2ZWQoZ2V0VXNlZFNjYWxlcyhwbG90LCBvcHRpb25zV2l0aEF1dG9GYWNldCwgbWFyaykpO1xuICAgIC8qKlxuICAgICAqIGJhc2VkIG9uIHRoZSBkYXRhIGFuZCB0aGUgZ2xvYmFsIHNjYWxlcyB3ZSBjYW4gbm93IG1hcCB0aGUgZGF0YVxuICAgICAqIGVsZW1lbnRzIHRvIHRoZSBzY2FsZXNcbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZWREYXRhID0gJGRlcml2ZWQoXG4gICAgICAgIGRvZGdlKFxuICAgICAgICAgICAgcmVzb2x2ZWREYXRhLmZsYXRNYXAoKHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dDogU2NhbGVkRGF0YVJlY29yZDxEYXR1bT4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdHVtOiByb3cuZGF0dW0sXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiByb3csXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiByb3dbSU5ERVhdLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBkeC9keVxuICAgICAgICAgICAgICAgIG91dC5keCA9IE51bWJlcihyZXNvbHZlUHJvcDxudW1iZXI+KG9wdGlvbnMuZHgsIG91dC5kYXR1bSwgMCkpO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IE51bWJlcihyZXNvbHZlUHJvcDxudW1iZXI+KG9wdGlvbnMuZHksIG91dC5kYXR1bSwgMCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBpZiB0aGVyZSdzIGEgcHJvamVjdGlvbiwgZS5nLiBhIGxpbmUgbWFya1xuICAgICAgICAgICAgICAgIGlmIChwbG90LnNjYWxlcy5wcm9qZWN0aW9uICYmIG1hcmsudHlwZSAhPT0gJ2dlbycpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWZmaXggb2YgWycnLCAnMScsICcyJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPy5bYHgke3N1ZmZpeH1gXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucz8uW2B5JHtzdWZmaXh9YF0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0d28tZGltZW5zaW9uYWwgYWNjZXNzb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoZSB4IGFuZCB5IGNoYW5uZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3gsIHldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyay50eXBlID09PSAnbGluZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW3Jvdy54LCByb3cueV0gLy8gbGluZSBwYXRocyBhcmUgcHJvamVjdGVkIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb2plY3RYWShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3Quc2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRTY2FsZXMueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRTY2FsZXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2B4JHtzdWZmaXh9YF0gPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtgeSR7c3VmZml4fWBdID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQudmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQudmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZChyb3cueCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZChyb3cueSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCh4KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkKHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBzY2FsZWQgY2hhbm5lbHNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjaGFubmVsLCBzY2FsZV0gb2YgT2JqZWN0LmVudHJpZXMoQ0hBTk5FTF9TQ0FMRSkgYXMgW1xuICAgICAgICAgICAgICAgICAgICBTY2FsZWRDaGFubmVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgU2NhbGVOYW1lXG4gICAgICAgICAgICAgICAgXVtdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBtYXJrIGhhcyBkZWZpbmVkIGFuIGFjY2Vzc29yIGZvciB0aGlzIGNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/LltjaGFubmVsXSAhPSBudWxsICYmIG91dFtjaGFubmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJvd1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgY2hhbm5lbCB3YXMgcmVuYW1lZCwgdXNlIHRoZSBvcmlnaW5hbCBjaGFubmVsIGZvciBzY2FsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnQ2hhbm5lbCA9IG9wdGlvbnM/LltSRU5BTUVdPy5bY2hhbm5lbF0gfHwgY2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlZCA9IHVzZWRTY2FsZXNbY2hhbm5lbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNjYWxlID09PSAneCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9qZWN0WChvcmlnQ2hhbm5lbCBhcyAneCcgfCAneDEnIHwgJ3gyJywgcGxvdC5zY2FsZXMsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNjYWxlID09PSAneSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByb2plY3RZKG9yaWdDaGFubmVsIGFzICd5JyB8ICd5MScgfCAneTInLCBwbG90LnNjYWxlcywgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzY2FsZSA9PT0gJ2NvbG9yJyAmJiAhaXNWYWxpZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGxvdC5vcHRpb25zLmNvbG9yLnVua25vd25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGxvdC5zY2FsZXNbc2NhbGVdLmZuKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC52YWxpZCA9IG91dC52YWxpZCAmJiAoc2NhbGUgPT09ICdjb2xvcicgfHwgaXNWYWxpZCh2YWx1ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBkeC9keSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtjaGFubmVsXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLmlzRmluaXRlKHNjYWxlZCkgJiYgKHNjYWxlID09PSAneCcgfHwgc2NhbGUgPT09ICd5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzY2FsZWQgKyAoc2NhbGUgPT09ICd4JyA/IG91dC5keCA6IG91dC5keSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzY2FsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdHNbY2hhbm5lbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtjaGFubmVsXSA9IGRlZmF1bHRzW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtvdXRdO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gZG9kZ2U8VD4oZGF0YTogU2NhbGVkRGF0YVJlY29yZDxEYXR1bT5bXSwgb3B0aW9uczogQmFzZU1hcmtQcm9wczxUPikge1xuICAgICAgICBpZiAob3B0aW9ucy5kb2RnZVgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2RnZVgoeyBkYXRhLCAuLi5vcHRpb25zIH0sIHBsb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRvZGdlWSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvZGdlWSh7IGRhdGEsIC4uLm9wdGlvbnMgfSwgcGxvdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgZXJyb3JzLmxlbmd0aH1cbiAgICA8dGV4dCB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTAsMTApXCI+XG4gICAgICAgIHsjZWFjaCBlcnJvcnMgYXMgZXJyb3IsIGkgKGkpfVxuICAgICAgICAgICAgPHRzcGFuIHg9XCIwXCIgZHk9e2kgPyAxNCA6IDB9PntlcnJvcn08L3RzcGFuPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC90ZXh0PlxuezplbHNlIGlmIGNoaWxkcmVufVxuICAgIHtAcmVuZGVyIGNoaWxkcmVuKHtcbiAgICAgICAgbWFyayxcbiAgICAgICAgdXNlZFNjYWxlcyxcbiAgICAgICAgc2NhbGVkRGF0YVxuICAgIH0pfVxuey9pZn1cblxuPHN0eWxlPlxuICAgIHRleHQge1xuICAgICAgICBzdHJva2U6IHZhcigtLXN2cC1iZyk7XG4gICAgICAgIGZpbGw6IGNyaW1zb247XG4gICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAzcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBwYWludC1vcmRlcjogc3Ryb2tlIGZpbGw7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function Mark_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mark_1);
  append_styles($$anchor, $$css2);
  let data = prop($$props, "data", 19, () => []), channels = prop($$props, "channels", 19, () => []), required = prop($$props, "required", 19, () => []), requiredScales = prop($$props, "requiredScales", 19, () => ({})), defaults = prop($$props, "defaults", 19, () => ({})), options = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "children",
      "type",
      "channels",
      "required",
      "requiredScales",
      "defaults"
    ],
    "options"
  );
  const channelsWithFacets = tag(user_derived(() => [...channels(), "fx", "fy"]), "channelsWithFacets");
  const { addMark, removeMark, getTopLevelFacet, getPlotState } = getContext("svelteplot");
  const plot = tag(user_derived(getPlotState), "plot");
  const facet = tag(user_derived(getTopLevelFacet), "facet");
  const { getFacetState } = getContext("svelteplot/facet");
  const $$d = user_derived(getFacetState), left = tag(user_derived(() => get($$d).left), "left"), top = tag(user_derived(() => get($$d).top), "top");
  class Mark {
    id;
    type;
    #channels = tag(state([]), "Mark.channels");
    get channels() {
      return get(this.#channels);
    }
    set channels(value) {
      set(this.#channels, value);
    }
    #scales = tag(state(/* @__PURE__ */ new Set()), "Mark.scales");
    get scales() {
      return get(this.#scales);
    }
    set scales(value) {
      set(this.#scales, value);
    }
    #data = tag(state([]), "Mark.data");
    get data() {
      return get(this.#data);
    }
    set data(value) {
      set(this.#data, value);
    }
    #options = tag(state({}), "Mark.options");
    get options() {
      return get(this.#options);
    }
    set options(value) {
      set(this.#options, value);
    }
    constructor(type) {
      this.id = /* @__PURE__ */ Symbol();
      this.type = type;
    }
  }
  const mark = new Mark($$props.type);
  user_effect(() => {
    return () => {
      removeMark(mark);
      added = false;
    };
  });
  const facetMode = tag(user_derived(() => $$props.facet || "auto"), "facetMode");
  const optionsWithAutoFacet = tag(
    user_derived(() => ({
      ...options,
      __firstFacet: get(left) && get(top),
      ...get(facet) && get(facet).data && (strict_equals(get(facetMode), "auto") && strict_equals(get(facet).data, data()) || strict_equals(get(facetMode), "include")) ? { fx: get(facet).x, fy: get(facet).y } : {}
    })),
    "optionsWithAutoFacet"
  );
  let added = false;
  user_effect(() => {
    const prevOptions = untrack(() => mark.options);
    if (!isEqual(prevOptions, get(optionsWithAutoFacet))) {
      mark.options = get(optionsWithAutoFacet);
    }
  });
  user_effect(() => {
    if (added) return;
    const channels2 = untrack(() => get(channelsWithFacets));
    mark.channels = channels2;
    mark.scales = new Set(channels2.filter((channel) => strict_equals(options[channel], 0, false)).map((channel) => CHANNEL_SCALE[channel]));
    mark.data = untrack(() => data());
    mark.options = untrack(() => get(optionsWithAutoFacet));
    addMark(mark);
    added = true;
  });
  const { getTestFacet } = getContext("svelteplot/facet");
  const testFacet = tag(user_derived(getTestFacet), "testFacet");
  const resolvedData = tag(
    user_derived(() => data().map((d, i) => ({ ...d, [INDEX]: i })).flatMap((row, index3) => {
      const channels2 = options;
      if (!get(testFacet)(row, channels2) || !testFilter(row, channels2)) return [];
      const out = { datum: row, index: index3 };
      for (const [channel] of Object.entries(CHANNEL_SCALE)) {
        if (strict_equals(options?.[channel], void 0, false) && strict_equals(out[channel], void 0)) {
          out[channel] = resolveChannel(channel, row, options, index3);
          if (strict_equals(options[channel], INDEX)) {
            const scale = get(plot).scales[CHANNEL_SCALE[channel]];
            if (strict_equals(scale.type, "band") || strict_equals(scale.type, "point")) {
              out[channel] = scale.domain[out[channel] % scale.domain.length];
            }
          }
        }
      }
      return [out];
    })),
    "resolvedData"
  );
  let prevResolvedData = [];
  user_effect(() => {
    if (isDifferent(data(), mark.data) || isDifferent(get(resolvedData), prevResolvedData)) {
      prevResolvedData = get(resolvedData);
      mark.data = data();
    }
  });
  function isDifferent(array1, array2) {
    if (strict_equals(array1.length, array2.length, false)) return true;
    for (let i = 0; i < array1.length; i++) {
      for (const [channel] of Object.entries(CHANNEL_SCALE)) {
        if (!isEqual(array1[i][channel], array2[i][channel])) {
          return true;
        }
      }
    }
    return false;
  }
  const errors = tag(
    user_derived(() => [
      ...required().filter((name) => equals(options[name], null)).map((name) => `missing channel value for ${mark.type} mark: ${name}`),
      ...Object.entries(requiredScales()).filter(([scale, types]) => {
        return !types.includes(get(plot).scales[scale].type);
      }).map(([scale, types]) => `scale type mismatch for ${scale} (needs ${types.join(" or ")})`)
    ]),
    "errors"
  );
  user_effect(() => {
    for (const name of required()) {
      if (equals(options[name], null)) throw new Error(`missing channel value: ${name}`);
    }
  });
  const usedScales = tag(user_derived(() => getUsedScales(get(plot), get(optionsWithAutoFacet), mark)), "usedScales");
  const scaledData = tag(
    user_derived(() => dodge2(
      get(resolvedData).flatMap((row) => {
        const out = {
          datum: row.datum,
          resolved: row,
          index: row[INDEX],
          valid: true
        };
        out.dx = Number(resolveProp($$props.dx, out.datum, 0));
        out.dy = Number(resolveProp($$props.dy, out.datum, 0));
        if (get(plot).scales.projection && strict_equals(mark.type, "geo", false)) {
          for (const suffix of ["", "1", "2"]) {
            if (strict_equals(options?.[`x${suffix}`], void 0, false) && strict_equals(options?.[`y${suffix}`], void 0, false)) {
              const [x2, y2] = strict_equals(mark.type, "line") ? [row.x, row.y] : (
                // line paths are projected later
                projectXY(get(plot).scales, row.x, row.y, get(usedScales).x, get(usedScales).y, suffix)
              );
              out[`x${suffix}`] = x2;
              out[`y${suffix}`] = y2;
              out.valid = out.valid && isValid(row.x) && isValid(row.y) && isValid(x2) && isValid(y2);
            }
          }
        }
        for (const [channel, scale] of Object.entries(CHANNEL_SCALE)) {
          if (equals(options?.[channel], null, false) && strict_equals(out[channel], void 0)) {
            const value = row[channel];
            const origChannel = options?.[RENAME]?.[channel] || channel;
            const scaled = get(usedScales)[channel] ? strict_equals(scale, "x") ? projectX(origChannel, get(plot).scales, value) : strict_equals(scale, "y") ? projectY(origChannel, get(plot).scales, value) : strict_equals(scale, "color") && !isValid(value) ? get(plot).options.color.unknown : get(plot).scales[scale].fn(value) : value;
            out.valid = out.valid && (strict_equals(scale, "color") || isValid(value));
            out[channel] = Number.isFinite(scaled) && (strict_equals(scale, "x") || strict_equals(scale, "y")) ? scaled + (strict_equals(scale, "x") ? out.dx : out.dy) : scaled;
          } else if (defaults()[channel]) {
            out[channel] = defaults()[channel];
          }
        }
        return [out];
      }),
      options
    )),
    "scaledData"
  );
  function dodge2(data2, options2) {
    if (options2.dodgeX) {
      return dodgeX({ data: data2, ...options2 }, get(plot));
    }
    if (options2.dodgeY) {
      return dodgeY({ data: data2, ...options2 }, get(plot));
    }
    return data2;
  }
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var text2 = root_12();
      add_svelte_meta(
        () => each(text2, 21, () => get(errors), index, ($$anchor3, error, i) => {
          var tspan = root_23();
          set_attribute(tspan, "dy", i ? 14 : 0);
          var text_1 = child(tspan, true);
          reset(tspan);
          template_effect(() => set_text(text_1, get(error)));
          append($$anchor3, tspan);
        }),
        "each",
        Mark_1,
        314,
        8
      );
      reset(text2);
      append($$anchor2, text2);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => snippet(node_2, () => $$props.children, () => ({
              mark,
              usedScales: get(usedScales),
              scaledData: get(scaledData)
            })),
            "render",
            Mark_1,
            319,
            4
          );
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(
            node_1,
            ($$render) => {
              if ($$props.children) $$render(consequent_1);
            },
            true
          ),
          "if",
          Mark_1,
          318,
          0
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(errors).length) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Mark_1,
      312,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Mark_1 = hmr(Mark_1);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-QPlHLQ7s6Rt0");
    Mark_1[HMR].update(module.default);
  });
}
var Mark_default = Mark_1;

// node_modules/svelteplot/dist/helpers/removeIdenticalLines.js
function removeIdenticalLines(input) {
  const uniqueTicks = [];
  if (!input.length)
    return input;
  for (let c4 = 0; c4 < input.length; c4++) {
    uniqueTicks.push({
      ...input[c4],
      text: []
    });
  }
  const maxLines = Math.max(...input.map((t) => t.text.length));
  for (let l = 0; l < maxLines; l++) {
    const isIdentical = input.length > 1 && input.every((tick) => input[0].text[l] === tick.text[l]);
    for (let c4 = 0; c4 < input.length; c4++) {
      if (!isIdentical && input[c4].text[l] != null)
        uniqueTicks[c4].text.push(input[c4].text[l]);
    }
  }
  return uniqueTicks;
}

// node_modules/svelteplot/dist/helpers/wordwrap.js
var CHAR_W = {
  A: 7,
  a: 7,
  B: 8,
  b: 7,
  C: 8,
  c: 6,
  D: 9,
  d: 7,
  E: 7,
  e: 7,
  F: 7,
  f: 4,
  G: 9,
  g: 7,
  H: 9,
  h: 7,
  I: 3,
  i: 3,
  J: 5,
  j: 3,
  K: 8,
  k: 6,
  L: 7,
  l: 3,
  M: 11,
  m: 11,
  N: 9,
  n: 7,
  O: 9,
  o: 7,
  P: 8,
  p: 7,
  Q: 9,
  q: 7,
  R: 8,
  r: 4,
  S: 8,
  s: 6,
  T: 7,
  t: 4,
  U: 9,
  u: 7,
  V: 7,
  v: 6,
  W: 11,
  w: 9,
  X: 7,
  x: 6,
  Y: 7,
  y: 6,
  Z: 7,
  z: 5,
  ".": 2,
  ",": 2,
  ":": 2,
  ";": 2
};
function wordwrap(line, options = {}) {
  let { minCharactersPerLine, minLineWidth, maxCharactersPerLine, maxLineWidth, fontSize, monospace } = { fontSize: 12, maxCharactersPerLine: 10, ...options };
  const tokens = [];
  const spaceSeparated = line.split(" ");
  spaceSeparated.forEach((word, wordIndex) => {
    const hyphenParts = word.split("-");
    const trailingWhitespace = wordIndex < spaceSeparated.length - 1 ? " " : "";
    if (hyphenParts.length > 1) {
      hyphenParts.forEach((part, partIndex) => {
        const suffix = partIndex < hyphenParts.length - 1 ? "-" : trailingWhitespace;
        tokens.push(part + suffix);
      });
    } else {
      tokens.push(word + trailingWhitespace);
    }
  });
  if (!maxLineWidth) {
    maxLineWidth = maxCharactersPerLine * CHAR_W.a;
  }
  if (!minLineWidth) {
    const sortedWordLengths = tokens.map((t) => t.length).sort((a2, b) => a2 - b);
    const medianIndex2 = Math.round(tokens.length / 2);
    const medianWordLength = sortedWordLengths[medianIndex2] ?? maxCharactersPerLine;
    const minChars = minCharactersPerLine || Math.max(3, Math.min(maxCharactersPerLine * 0.5, 0.75 * medianWordLength));
    minLineWidth = minChars * CHAR_W.a;
  }
  const lines = [];
  const currentWords = [];
  let currentWidth = 0;
  const charWidth = (char) => fontSize / 12 * (!monospace ? CHAR_W[char] : CHAR_W.a);
  tokens.forEach((token) => {
    const tokenWidth = sum(token.split("").map(charWidth));
    if (currentWidth + tokenWidth > maxLineWidth && currentWidth > minLineWidth) {
      lines.push(currentWords.join(""));
      currentWords.length = 0;
      currentWidth = 0;
    }
    currentWidth += tokenWidth;
    currentWords.push(token);
  });
  if (currentWords.length > 0) {
    lines.push(currentWords.join(""));
  }
  return lines.filter((d) => d !== "");
}

// node_modules/svelteplot/dist/marks/helpers/BaseAxisX.svelte
BaseAxisX[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/BaseAxisX.svelte";
var root_3 = add_locations(from_svg(`<line></line>`), BaseAxisX[FILENAME], [[199, 20]]);
var root_8 = add_locations(from_svg(`<tspan x="0"> </tspan>`), BaseAxisX[FILENAME], [[251, 36]]);
var root_4 = add_locations(from_svg(`<text><!></text>`), BaseAxisX[FILENAME], [[234, 20]]);
var root_24 = add_locations(from_svg(`<g><!><!></g>`), BaseAxisX[FILENAME], [[186, 12]]);
var root2 = add_locations(from_svg(`<g></g>`), BaseAxisX[FILENAME], [[181, 0]]);
var $$css3 = {
  hash: "s-z9wx9Z8OSsGS",
  code: "\n    line.s-z9wx9Z8OSsGS {\n        stroke: currentColor;\n    }\n    text.s-z9wx9Z8OSsGS {\n        opacity: 0.8;\n        fill: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzZUF4aXNYLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQmFzZUF4aXNYLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIC8vIHRoaXMgY29tcG9uZW50IG9ubHkgdGFrZXMgY2FyZSBvZiByZW5kZXJpbmcgdGhlIHggYXhpcyBzbyB3ZSBjYW4gcmUtdXNlIGl0XG4gICAgLy8gZm9yIHRoZSBmYWNldCBsYWJlbHNcbiAgICBpbXBvcnQgeyBnZXRDb250ZXh0LCB1bnRyYWNrIH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgcmVtb3ZlSWRlbnRpY2FsTGluZXMgZnJvbSAnLi4vLi4vaGVscGVycy9yZW1vdmVJZGVudGljYWxMaW5lcy5qcyc7XG4gICAgaW1wb3J0IHR5cGUge1xuICAgICAgICBBdXRvTWFyZ2luU3RvcmVzLFxuICAgICAgICBDaGFubmVsQWNjZXNzb3IsXG4gICAgICAgIENvbnN0YW50QWNjZXNzb3IsXG4gICAgICAgIFBsb3RTdGF0ZSxcbiAgICAgICAgUmF3VmFsdWUsXG4gICAgICAgIFNjYWxlZERhdGFSZWNvcmQsXG4gICAgICAgIFNjYWxlVHlwZVxuICAgIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IHJlc29sdmVQcm9wLCByZXNvbHZlU3R5bGVzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9yZXNvbHZlLmpzJztcbiAgICBpbXBvcnQgeyBtYXggfSBmcm9tICdkMy1hcnJheSc7XG4gICAgaW1wb3J0IHsgcmFuZG9tSWQsIHRlc3RGaWx0ZXIgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbiAgICBpbXBvcnQgeyBJTkRFWCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG4gICAgaW1wb3J0IHsgUkFXX1ZBTFVFIH0gZnJvbSAnLi4vLi4vdHJhbnNmb3Jtcy9yZWNvcmRpemUnO1xuICAgIGltcG9ydCB3b3Jkd3JhcCBmcm9tICcuLi8uLi9oZWxwZXJzL3dvcmR3cmFwJztcblxuICAgIHR5cGUgQmFzZUF4aXNYUHJvcHMgPSB7XG4gICAgICAgIHNjYWxlRm46IChkOiBSYXdWYWx1ZSkgPT4gbnVtYmVyO1xuICAgICAgICBzY2FsZVR5cGU6IFNjYWxlVHlwZTtcbiAgICAgICAgdGlja3M6IFJhd1ZhbHVlW107XG4gICAgICAgIHRpY2tGb3JtYXQ6IChkOiBSYXdWYWx1ZSwgaTogbnVtYmVyLCB0aWNrczogUmF3VmFsdWVbXSkgPT4gc3RyaW5nIHwgc3RyaW5nW107XG4gICAgICAgIGFuY2hvcjogJ3RvcCcgfCAnYm90dG9tJztcbiAgICAgICAgdGlja1NpemU6IG51bWJlcjtcbiAgICAgICAgdGlja1BhZGRpbmc6IG51bWJlcjtcbiAgICAgICAgdGlja0ZvbnRTaXplOiBDb25zdGFudEFjY2Vzc29yPG51bWJlcj47XG4gICAgICAgIHRpY2tDbGFzczogQ29uc3RhbnRBY2Nlc3NvcjxzdHJpbmc+O1xuICAgICAgICBtYXJnaW5Ub3A6IG51bWJlcjtcbiAgICAgICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGR4OiBDb25zdGFudEFjY2Vzc29yPG51bWJlcj47XG4gICAgICAgICAgICBkeTogQ29uc3RhbnRBY2Nlc3NvcjxudW1iZXI+O1xuICAgICAgICAgICAgZmlsdGVyOiBDaGFubmVsQWNjZXNzb3I7XG4gICAgICAgICAgICB3b3Jkd3JhcDogYm9vbGVhbjtcbiAgICAgICAgICAgIHRleHRBbmNob3I6IENvbnN0YW50QWNjZXNzb3I8J3N0YXJ0JyB8ICdtaWRkbGUnIHwgJ2VuZCc+IHwgJ2F1dG8nO1xuICAgICAgICAgICAgcmVtb3ZlRHVwbGljYXRlVGlja3M6IGJvb2xlYW47XG4gICAgICAgIH07XG4gICAgICAgIHRleHQ6IGJvb2xlYW47XG4gICAgICAgIHBsb3Q6IFBsb3RTdGF0ZTtcbiAgICAgICAgY2xhc3M6IHN0cmluZztcbiAgICB9O1xuXG4gICAgbGV0IHtcbiAgICAgICAgc2NhbGVGbixcbiAgICAgICAgc2NhbGVUeXBlLFxuICAgICAgICB0aWNrcyxcbiAgICAgICAgdGlja0Zvcm1hdCxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICB0aWNrU2l6ZSxcbiAgICAgICAgdGlja1BhZGRpbmcsXG4gICAgICAgIHRpY2tGb250U2l6ZSxcbiAgICAgICAgdGlja0NsYXNzLFxuICAgICAgICBtYXJnaW5Ub3AsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcGxvdCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWUgPSAnYXhpcy14JyxcbiAgICAgICAgdGV4dCA9IHRydWVcbiAgICB9OiBCYXNlQXhpc1hQcm9wcyA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgaXNCYW5kU2NhbGUgPSAkZGVyaXZlZChzY2FsZVR5cGUgPT09ICdiYW5kJyk7XG4gICAgY29uc3QgYmFuZFdpZHRoID0gJGRlcml2ZWQoaXNCYW5kU2NhbGUgPyBzY2FsZUZuLmJhbmR3aWR0aCgpIDogMCk7XG5cbiAgICBmdW5jdGlvbiBzcGxpdFRpY2sodGljazogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGljaylcbiAgICAgICAgICAgID8gdGlja1xuICAgICAgICAgICAgOiB0eXBlb2YgdGljayA9PT0gJ3N0cmluZycgJiYgaXNCYW5kU2NhbGUgJiYgb3B0aW9ucy53b3Jkd3JhcCAhPT0gZmFsc2VcbiAgICAgICAgICAgICAgPyB3b3Jkd3JhcCh0aWNrLCB7XG4gICAgICAgICAgICAgICAgICAgIG1heExpbmVXaWR0aDogYmFuZFdpZHRoICogMC45LFxuICAgICAgICAgICAgICAgICAgICBtaW5DaGFyYWN0ZXJzUGVyTGluZTogNCxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICtyZXNvbHZlUHJvcCh0aWNrRm9udFNpemUsIHt9LCAxMSksXG4gICAgICAgICAgICAgICAgICAgIG1vbm9zcGFjZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IFt0aWNrXTtcbiAgICB9XG5cbiAgICBsZXQgdGlja1JvdGF0ZSA9ICRkZXJpdmVkKHBsb3Qub3B0aW9ucy54LnRpY2tSb3RhdGUgfHwgMCk7XG5cbiAgICBsZXQgdGlja1kgPSAkZGVyaXZlZChhbmNob3IgPT09ICdib3R0b20nID8gbWFyZ2luVG9wICsgaGVpZ2h0IDogbWFyZ2luVG9wKTtcblxuICAgIGxldCBpc1F1YW50aXRhdGl2ZSA9ICRkZXJpdmVkKHNjYWxlVHlwZSAhPT0gJ3BvaW50JyAmJiBzY2FsZVR5cGUgIT09ICdiYW5kJyk7XG5cbiAgICAvLyBnZW5lcmF0ZSBpZCB1c2VkIGZvciByZWdpc3RlcmluZyBtYXJnaW5zXG4gICAgY29uc3QgaWQgPSByYW5kb21JZCgpO1xuXG4gICAgY29uc3QgeyBhdXRvTWFyZ2luVG9wLCBhdXRvTWFyZ2luQm90dG9tLCBhdXRvTWFyZ2luTGVmdCwgYXV0b01hcmdpblJpZ2h0IH0gPVxuICAgICAgICBnZXRDb250ZXh0PEF1dG9NYXJnaW5TdG9yZXM+KCdzdmVsdGVwbG90L2F1dG9NYXJnaW5zJyk7XG5cbiAgICBsZXQgdGlja1RleHRFbGVtZW50cyA9ICRzdGF0ZShbXSBhcyBTVkdUZXh0RWxlbWVudFtdKTtcblxuICAgIGNvbnN0IHBvc2l0aW9uZWRUaWNrcyA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICAgICAgbGV0IHRpY2tPYmplY3RzID0gcmVtb3ZlSWRlbnRpY2FsTGluZXMoXG4gICAgICAgICAgICB0aWNrcy5tYXAoKHRpY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXR1bSA9IHsgW1JBV19WQUxVRV06IHRpY2ssIFtJTkRFWF06IGkgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZHg6ICtyZXNvbHZlUHJvcChvcHRpb25zLmR4LCBkYXR1bSwgMCksXG4gICAgICAgICAgICAgICAgICAgIGR5OiArcmVzb2x2ZVByb3Aob3B0aW9ucy5keSwgZGF0dW0sIDApLFxuICAgICAgICAgICAgICAgICAgICB4OiBzY2FsZUZuKHRpY2spICsgKHNjYWxlVHlwZSA9PT0gJ2JhbmQnID8gc2NhbGVGbi5iYW5kd2lkdGgoKSAqIDAuNSA6IDApLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzcGxpdFRpY2sodGlja0Zvcm1hdCh0aWNrLCBpLCB0aWNrcykpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBudWxsIGFzIFNWR1RleHRFbGVtZW50IHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBUID0gdGlja09iamVjdHMubGVuZ3RoO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgcHJlY2VkaW5nIHRpY2sgdGhhdCB3YXMgbm90IGhpZGRlblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGogPj0gMCAmJiB0aWNrT2JqZWN0c1tqXS5oaWRkZW4pO1xuICAgICAgICAgICAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja0xhYmVsU3BhY2UgPSBNYXRoLmFicyh0aWNrT2JqZWN0c1tpXS54IC0gdGlja09iamVjdHNbal0ueCk7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tPYmplY3RzW2ldLmhpZGRlbiA9IHRpY2tMYWJlbFNwYWNlIDwgMTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrT2JqZWN0cyBhcyBTY2FsZWREYXRhUmVjb3JkW107XG4gICAgfSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8ganVzdCBhZGQgc29tZSBtaW5pbWFsIGhvcml6b250YWwgbWFyZ2lucyBmb3IgYXhpcyB0aWNrc1xuICAgICAgICB1bnRyYWNrKCgpID0+ICRhdXRvTWFyZ2luTGVmdCk7XG4gICAgICAgIHVudHJhY2soKCkgPT4gJGF1dG9NYXJnaW5SaWdodCk7XG4gICAgICAgICRhdXRvTWFyZ2luTGVmdC5zZXQoaWQsIDUpO1xuICAgICAgICAkYXV0b01hcmdpblJpZ2h0LnNldChpZCwgMTApO1xuICAgIH0pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHVudHJhY2soKCkgPT4gWyRhdXRvTWFyZ2luVG9wLCAkYXV0b01hcmdpbkJvdHRvbV0pO1xuICAgICAgICBpZiAoIXRleHQpIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3V0c2lkZVRleHRBbmNob3IgPSBhbmNob3IgPT09ICd0b3AnID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgICAvLyBtZWFzdXJlIHRpY2sgbGFiZWwgaGVpZ2h0c1xuICAgICAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9XG4gICAgICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgbWF4KFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbmVkVGlja3MubWFwKCh0aWNrLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb3Aob3B0aW9ucy5hbmNob3IsIHRpY2ssIG91dHNpZGVUZXh0QW5jaG9yKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlVGV4dEFuY2hvclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpY2suaGlkZGVuIHx8ICF0ZXN0RmlsdGVyKHRpY2ssIG9wdGlvbnMpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aWNrVGV4dEVsZW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWNrVGV4dEVsZW1lbnRzW2ldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9KSBhcyBudW1iZXJbXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgTWF0aC5tYXgoMCwgdGlja1BhZGRpbmcgKyB0aWNrU2l6ZSkgK1xuICAgICAgICAgICAgKHRpdGxlID8gMTUgOiAwKTtcblxuICAgICAgICBpZiAoIWlzTmFOKG1heExhYmVsSGVpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA9PT0gJ3RvcCcgJiYgJGF1dG9NYXJnaW5Ub3AuZ2V0KGlkKSAhPT0gbWF4TGFiZWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAkYXV0b01hcmdpblRvcC5zZXQoaWQsIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yID09PSAnYm90dG9tJyAmJiAkYXV0b01hcmdpbkJvdHRvbS5nZXQoaWQpICE9PSBtYXhMYWJlbEhlaWdodCkge1xuICAgICAgICAgICAgICAgICRhdXRvTWFyZ2luQm90dG9tLnNldChpZCwgbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gY2xlYXIgbWFyZ2lucyBvbiBkZXN0cm95XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoJGF1dG9NYXJnaW5Cb3R0b20uaGFzKGlkKSkgJGF1dG9NYXJnaW5Cb3R0b20uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGlmICgkYXV0b01hcmdpblRvcC5oYXMoaWQpKSAkYXV0b01hcmdpblRvcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgaWYgKCRhdXRvTWFyZ2luTGVmdC5oYXMoaWQpKSAkYXV0b01hcmdpbkxlZnQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGlmICgkYXV0b01hcmdpblJpZ2h0LmhhcyhpZCkpICRhdXRvTWFyZ2luUmlnaHQuZGVsZXRlKGlkKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZyBjbGFzcz17Y2xhc3NOYW1lfT5cbiAgICB7I2VhY2ggcG9zaXRpb25lZFRpY2tzIGFzIHRpY2ssIHQgKHRpY2tbUkFXX1ZBTFVFXSl9XG4gICAgICAgIHsjaWYgdGVzdEZpbHRlcih0aWNrLCBvcHRpb25zKSAmJiAhdGljay5oaWRkZW59XG4gICAgICAgICAgICB7QGNvbnN0IHRpY2tDbGFzc18gPSByZXNvbHZlUHJvcCh0aWNrQ2xhc3MsIHRpY2spfVxuICAgICAgICAgICAge0Bjb25zdCB0aWNrRm9udFNpemVfID0gK3Jlc29sdmVQcm9wKHRpY2tGb250U2l6ZSwgdGljaywgMTApfVxuICAgICAgICAgICAgPGdcbiAgICAgICAgICAgICAgICBjbGFzcz1cInRpY2sge3RpY2tDbGFzc18gfHwgJyd9XCJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoe3RpY2sueCArIHRpY2suZHh9LCB7dGlja1kgKyB0aWNrLmR5fSlcIlxuICAgICAgICAgICAgICAgIHRleHQtYW5jaG9yPXt0aWNrUm90YXRlIDwgMCA/ICdlbmQnIDogdGlja1JvdGF0ZSA+IDAgPyAnc3RhcnQnIDogJ21pZGRsZSd9PlxuICAgICAgICAgICAgICAgIHsjaWYgdGlja1NpemV9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgW3RpY2tMaW5lU3R5bGUsIHRpY2tMaW5lQ2xhc3NdID0gcmVzb2x2ZVN0eWxlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGRhdHVtOiB0aWNrIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHg6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt0aWNrTGluZVN0eWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9e3RpY2tMaW5lQ2xhc3N9XG4gICAgICAgICAgICAgICAgICAgICAgICB5Mj17YW5jaG9yID09PSAnYm90dG9tJyA/IHRpY2tTaXplIDogLXRpY2tTaXplfSAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG5cbiAgICAgICAgICAgICAgICB7I2lmIHRleHR9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgdGV4dExpbmVzID0gdGljay50ZXh0fVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHByZXZUZXh0TGluZXMgPSB0ICYmIHBvc2l0aW9uZWRUaWNrc1t0IC0gMV0udGV4dH1cblxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IG1vdmVEb3duID1cbiAgICAgICAgICAgICAgICAgICAgICAgICh0aWNrU2l6ZSArIHRpY2tQYWRkaW5nICsgKHRpY2tSb3RhdGUgIT09IDAgPyB0aWNrRm9udFNpemVfICogMC4zNSA6IDApKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoYW5jaG9yID09PSAnYm90dG9tJyA/IDEgOiAtMSl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgW3RleHRTdHlsZSwgdGV4dENsYXNzXSA9IHJlc29sdmVTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXR1bTogdGljayB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRWYXJpYW50OiBpc1F1YW50aXRhdGl2ZSA/ICd0YWJ1bGFyLW51bXMnIDogJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRleHRBbmNob3IgPT09ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAvLyBhdXRvbWF0aWNhbGx5IGFkanVzdCB0ZXh0IGFuY2hvciBiYXNlZCBvbiByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrUm90YXRlIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VuZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRpY2tSb3RhdGUgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucy50ZXh0QW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiB0aWNrRm9udFNpemVfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgeDogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZDp0aGlzPXt0aWNrVGV4dEVsZW1lbnRzW3RdfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAsIHttb3ZlRG93bn0pICByb3RhdGUoe3RpY2tSb3RhdGV9KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17dGV4dFN0eWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9e3RleHRDbGFzc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHg9ezB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5PXswfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9taW5hbnQtYmFzZWxpbmU9e3RpY2tSb3RhdGUgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdjZW50cmFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYW5jaG9yID09PSAnYm90dG9tJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnaGFuZ2luZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2F1dG8nfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgdGlja3MubGVuZ3RoID4gMCB8fCB0ID09PSAwIHx8IHQgPT09IHRpY2tzLmxlbmd0aCAtIDF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiB0ZXh0TGluZXMubGVuZ3RoID09PSAxfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGV4dExpbmVzWzBdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHRleHRMaW5lcyBhcyBsaW5lLCBpIChpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0c3BhbiB4PVwiMFwiIGR5PXtpID8gMTIgOiAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID57IXByZXZUZXh0TGluZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2VGV4dExpbmVzW2ldICE9PSBsaW5lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZW1vdmVEdXBsaWNhdGVUaWNrcyA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyd9PC90c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG48L2c+XG5cbjxzdHlsZT5cbiAgICBsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiBjdXJyZW50Q29sb3I7XG4gICAgfVxuICAgIHRleHQge1xuICAgICAgICBvcGFjaXR5OiAwLjg7XG4gICAgICAgIGZpbGw6IGN1cnJlbnRDb2xvcjtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function BaseAxisX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BaseAxisX);
  append_styles($$anchor, $$css3);
  const $autoMarginLeft = () => (validate_store(autoMarginLeft, "autoMarginLeft"), store_get(autoMarginLeft, "$autoMarginLeft", $$stores));
  const $autoMarginRight = () => (validate_store(autoMarginRight, "autoMarginRight"), store_get(autoMarginRight, "$autoMarginRight", $$stores));
  const $autoMarginTop = () => (validate_store(autoMarginTop, "autoMarginTop"), store_get(autoMarginTop, "$autoMarginTop", $$stores));
  const $autoMarginBottom = () => (validate_store(autoMarginBottom, "autoMarginBottom"), store_get(autoMarginBottom, "$autoMarginBottom", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let className = prop($$props, "class", 3, "axis-x"), text2 = prop($$props, "text", 3, true);
  const isBandScale = tag(user_derived(() => strict_equals($$props.scaleType, "band")), "isBandScale");
  const bandWidth = tag(user_derived(() => get(isBandScale) ? $$props.scaleFn.bandwidth() : 0), "bandWidth");
  function splitTick(tick) {
    return Array.isArray(tick) ? tick : strict_equals(typeof tick, "string") && get(isBandScale) && strict_equals($$props.options.wordwrap, false, false) ? wordwrap(tick, {
      maxLineWidth: get(bandWidth) * 0.9,
      minCharactersPerLine: 4,
      fontSize: +resolveProp($$props.tickFontSize, {}, 11),
      monospace: false
    }) : [tick];
  }
  let tickRotate = tag(user_derived(() => $$props.plot.options.x.tickRotate || 0), "tickRotate");
  let tickY = tag(
    user_derived(() => strict_equals($$props.anchor, "bottom") ? $$props.marginTop + $$props.height : $$props.marginTop),
    "tickY"
  );
  let isQuantitative = tag(user_derived(() => strict_equals($$props.scaleType, "point", false) && strict_equals($$props.scaleType, "band", false)), "isQuantitative");
  const id = randomId();
  const {
    autoMarginTop,
    autoMarginBottom,
    autoMarginLeft,
    autoMarginRight
  } = getContext("svelteplot/autoMargins");
  let tickTextElements = tag_proxy(proxy([]), "tickTextElements");
  const positionedTicks = tag(
    user_derived(() => {
      let tickObjects = removeIdenticalLines($$props.ticks.map((tick, i) => {
        const datum = { [RAW_VALUE]: tick, [INDEX]: i };
        return {
          ...datum,
          hidden: false,
          dx: +resolveProp($$props.options.dx, datum, 0),
          dy: +resolveProp($$props.options.dy, datum, 0),
          x: $$props.scaleFn(tick) + (strict_equals($$props.scaleType, "band") ? $$props.scaleFn.bandwidth() * 0.5 : 0),
          text: splitTick($$props.tickFormat(tick, i, $$props.ticks)),
          element: null
        };
      }));
      const T = tickObjects.length;
      if (text2()) {
        for (let i = 0; i < T; i++) {
          let j = i;
          do {
            j--;
          } while (j >= 0 && tickObjects[j].hidden);
          if (j >= 0) {
            const tickLabelSpace = Math.abs(tickObjects[i].x - tickObjects[j].x);
            tickObjects[i].hidden = tickLabelSpace < 15;
          }
        }
      }
      return tickObjects;
    }),
    "positionedTicks"
  );
  user_effect(() => {
    untrack(() => $autoMarginLeft());
    untrack(() => $autoMarginRight());
    $autoMarginLeft().set(id, 5);
    $autoMarginRight().set(id, 10);
  });
  user_effect(() => {
    untrack(() => [$autoMarginTop(), $autoMarginBottom()]);
    if (!text2()) return;
    const outsideTextAnchor = strict_equals($$props.anchor, "top") ? "end" : "start";
    const maxLabelHeight = Math.ceil(max(get(positionedTicks).map((tick, i) => {
      if (strict_equals(resolveProp($$props.options.anchor, tick, outsideTextAnchor), outsideTextAnchor, false)) return 0;
      if (tick.hidden || !testFilter(tick, $$props.options)) return 0;
      if (tickTextElements[i]) return tickTextElements[i].getBoundingClientRect().height;
      return 0;
    }))) + Math.max(0, $$props.tickPadding + $$props.tickSize) + ($$props.title ? 15 : 0);
    if (!isNaN(maxLabelHeight)) {
      if (strict_equals($$props.anchor, "top") && strict_equals($autoMarginTop().get(id), maxLabelHeight, false)) {
        $autoMarginTop().set(id, maxLabelHeight);
      } else if (strict_equals($$props.anchor, "bottom") && strict_equals($autoMarginBottom().get(id), maxLabelHeight, false)) {
        $autoMarginBottom().set(id, maxLabelHeight);
      }
    }
  });
  user_effect(() => {
    return () => {
      if ($autoMarginBottom().has(id)) $autoMarginBottom().delete(id);
      if ($autoMarginTop().has(id)) $autoMarginTop().delete(id);
      if ($autoMarginLeft().has(id)) $autoMarginLeft().delete(id);
      if ($autoMarginRight().has(id)) $autoMarginRight().delete(id);
    };
  });
  var $$exports = { ...legacy_api() };
  var g = root2();
  validate_each_keys(() => get(positionedTicks), (tick) => tick[RAW_VALUE]);
  add_svelte_meta(
    () => each(g, 23, () => get(positionedTicks), (tick) => tick[RAW_VALUE], ($$anchor2, tick, t) => {
      var fragment = comment();
      var node = first_child(fragment);
      {
        var consequent_4 = ($$anchor3) => {
          const tickClass_ = tag(user_derived(() => resolveProp($$props.tickClass, get(tick))), "tickClass_");
          get(tickClass_);
          const tickFontSize_ = tag(user_derived(() => +resolveProp($$props.tickFontSize, get(tick), 10)), "tickFontSize_");
          get(tickFontSize_);
          var g_1 = root_24();
          var node_1 = child(g_1);
          {
            var consequent = ($$anchor4) => {
              const computed_const = tag(
                user_derived(() => {
                  const [tickLineStyle, tickLineClass] = resolveStyles($$props.plot, { datum: get(tick) }, $$props.options, "stroke", { x: true }, true);
                  return { tickLineStyle, tickLineClass };
                }),
                "[@const]"
              );
              get(computed_const);
              var line_1 = root_3();
              template_effect(() => {
                set_style(line_1, get(computed_const).tickLineStyle);
                set_class(line_1, 0, clsx(get(computed_const).tickLineClass), "s-z9wx9Z8OSsGS");
                set_attribute(line_1, "y2", strict_equals($$props.anchor, "bottom") ? $$props.tickSize : -$$props.tickSize);
              });
              append($$anchor4, line_1);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.tickSize) $$render(consequent);
              }),
              "if",
              BaseAxisX,
              190,
              16
            );
          }
          var node_2 = sibling(node_1);
          {
            var consequent_3 = ($$anchor4) => {
              const textLines = tag(user_derived(() => get(tick).text), "textLines");
              get(textLines);
              const prevTextLines = tag(user_derived(() => get(t) && get(positionedTicks)[get(t) - 1].text), "prevTextLines");
              get(prevTextLines);
              const moveDown = tag(user_derived(() => ($$props.tickSize + $$props.tickPadding + (strict_equals(get(tickRotate), 0, false) ? get(tickFontSize_) * 0.35 : 0)) * (strict_equals($$props.anchor, "bottom") ? 1 : -1)), "moveDown");
              get(moveDown);
              const computed_const_1 = tag(
                user_derived(() => {
                  const [textStyle, textClass] = resolveStyles(
                    $$props.plot,
                    { datum: get(tick) },
                    {
                      fontVariant: get(isQuantitative) ? "tabular-nums" : "normal",
                      ...$$props.options,
                      textAnchor: strict_equals($$props.options.textAnchor, "auto") ? get(tickRotate) < 0 ? "end" : get(tickRotate) > 0 ? "start" : "middle" : $$props.options.textAnchor,
                      fontSize: get(tickFontSize_),
                      stroke: null
                    },
                    "fill",
                    { x: true },
                    true
                  );
                  return { textStyle, textClass };
                }),
                "[@const]"
              );
              get(computed_const_1);
              var text_1 = root_4();
              set_attribute(text_1, "x", 0);
              set_attribute(text_1, "y", 0);
              var node_3 = child(text_1);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_1 = comment();
                  var node_4 = first_child(fragment_1);
                  {
                    var consequent_1 = ($$anchor6) => {
                      var text_2 = text();
                      template_effect(() => set_text(text_2, get(textLines)[0]));
                      append($$anchor6, text_2);
                    };
                    var alternate = ($$anchor6) => {
                      var fragment_3 = comment();
                      var node_5 = first_child(fragment_3);
                      add_svelte_meta(
                        () => each(node_5, 17, () => get(textLines), index, ($$anchor7, line, i) => {
                          var tspan = root_8();
                          set_attribute(tspan, "dy", i ? 12 : 0);
                          var text_3 = child(tspan, true);
                          reset(tspan);
                          template_effect(() => set_text(text_3, !get(prevTextLines) || strict_equals(get(prevTextLines)[i], get(line), false) || strict_equals($$props.options.removeDuplicateTicks, false) ? get(line) : ""));
                          append($$anchor7, tspan);
                        }),
                        "each",
                        BaseAxisX,
                        250,
                        32
                      );
                      append($$anchor6, fragment_3);
                    };
                    add_svelte_meta(
                      () => if_block(node_4, ($$render) => {
                        if (strict_equals(get(textLines).length, 1)) $$render(consequent_1);
                        else $$render(alternate, false);
                      }),
                      "if",
                      BaseAxisX,
                      247,
                      28
                    );
                  }
                  append($$anchor5, fragment_1);
                };
                add_svelte_meta(
                  () => if_block(node_3, ($$render) => {
                    if ($$props.ticks.length > 0 || strict_equals(get(t), 0) || strict_equals(get(t), $$props.ticks.length - 1)) $$render(consequent_2);
                  }),
                  "if",
                  BaseAxisX,
                  246,
                  24
                );
              }
              reset(text_1);
              validate_binding("bind:this={tickTextElements[t]}", [], () => tickTextElements, () => get(t), 235, 24);
              bind_this(text_1, ($$value, t4) => tickTextElements[t4] = $$value, (t4) => tickTextElements?.[t4], () => [get(t)]);
              template_effect(() => {
                set_attribute(text_1, "transform", `translate(0, ${get(moveDown) ?? ""})  rotate(${get(tickRotate) ?? ""})`);
                set_style(text_1, get(computed_const_1).textStyle);
                set_class(text_1, 0, clsx(get(computed_const_1).textClass), "s-z9wx9Z8OSsGS");
                set_attribute(text_1, "dominant-baseline", strict_equals(get(tickRotate), 0, false) ? "central" : strict_equals($$props.anchor, "bottom") ? "hanging" : "auto");
              });
              append($$anchor4, text_1);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (text2()) $$render(consequent_3);
              }),
              "if",
              BaseAxisX,
              205,
              16
            );
          }
          reset(g_1);
          template_effect(() => {
            set_class(g_1, 0, `tick ${(get(tickClass_) || "") ?? ""}`);
            set_attribute(g_1, "transform", `translate(${get(tick).x + get(tick).dx}, ${get(tickY) + get(tick).dy})`);
            set_attribute(g_1, "text-anchor", get(tickRotate) < 0 ? "end" : get(tickRotate) > 0 ? "start" : "middle");
          });
          append($$anchor3, g_1);
        };
        add_svelte_meta(
          () => if_block(node, ($$render) => {
            if (testFilter(get(tick), $$props.options) && !get(tick).hidden) $$render(consequent_4);
          }),
          "if",
          BaseAxisX,
          183,
          8
        );
      }
      append($$anchor2, fragment);
    }),
    "each",
    BaseAxisX,
    182,
    4
  );
  reset(g);
  template_effect(() => set_class(g, 0, clsx(className())));
  append($$anchor, g);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  BaseAxisX = hmr(BaseAxisX);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-z9wx9Z8OSsGS");
    BaseAxisX[HMR].update(module.default);
  });
}
var BaseAxisX_default = BaseAxisX;

// node_modules/svelteplot/dist/helpers/autoTimeFormat.js
var DATE_TIME = {
  hour: "numeric",
  minute: "numeric",
  month: "short",
  day: "numeric"
};
var autoFormatDateTime = (locale3) => {
  const format2 = new Intl.DateTimeFormat(locale3, DATE_TIME).format;
  return (date2) => format2(date2).replace(", ", "\n");
};
var DAY_MONTH = {
  month: "short",
  day: "numeric"
};
var autoFormatDayMonth = (locale3) => {
  const format2 = new Intl.DateTimeFormat(locale3, DAY_MONTH).format;
  return (date2) => format2(date2).replace(" ", "\n");
};
var MONTH_YEAR = {
  month: "short",
  year: "numeric"
};
var autoFormatMonthYear = (locale3) => {
  const format2 = new Intl.DateTimeFormat(locale3, MONTH_YEAR).format;
  return (date2) => format2(date2).replace(" ", "\n");
};
function autoTimeFormat(x2, plotWidth, plotLocale) {
  const daysPer100Px = (toNumber2(x2.domain[1]) - toNumber2(x2.domain[0])) / plotWidth / 864e5 * 100;
  const format2 = daysPer100Px < 1 ? autoFormatDateTime(plotLocale) : daysPer100Px < 30 ? autoFormatDayMonth(plotLocale) : autoFormatMonthYear(plotLocale);
  return (date2) => format2(date2).split("\n");
}
function toNumber2(d) {
  return isDate(d) ? d.getTime() : +d;
}

// node_modules/svelteplot/dist/marks/AxisX.svelte
AxisX[FILENAME] = "node_modules/svelteplot/dist/marks/AxisX.svelte";
var root_25 = add_locations(from_svg(`<text class="axis-x-title s-0ehf4o43eJsC"> </text>`), AxisX[FILENAME], [[214, 8]]);
var root_13 = add_locations(from_svg(`<!><!>`, 1), AxisX[FILENAME], []);
var $$css4 = {
  hash: "s-0ehf4o43eJsC",
  code: "\n    text.s-0ehf4o43eJsC {\n        fill: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXhpc1guc3ZlbHRlIiwic291cmNlcyI6WyJBeGlzWC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBAY29tcG9uZW50XG4gICAgUmVuZGVycyBhIGhvcml6b250YWwgYXhpcyB3aXRoIGxhYmVscyBhbmQgdGljayBtYXJrc1xuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiIGdlbmVyaWNzPVwiRGF0dW0gZXh0ZW5kcyBSYXdWYWx1ZVwiPlxuICAgIGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCBNYXJrIGZyb20gJy4uL01hcmsuc3ZlbHRlJztcbiAgICBpbXBvcnQgQmFzZUF4aXNYIGZyb20gJy4vaGVscGVycy9CYXNlQXhpc1guc3ZlbHRlJztcbiAgICBpbXBvcnQgdHlwZSB7XG4gICAgICAgIEJhc2VNYXJrUHJvcHMsXG4gICAgICAgIFJhd1ZhbHVlLFxuICAgICAgICBDb25zdGFudEFjY2Vzc29yLFxuICAgICAgICBGYWNldENvbnRleHQsXG4gICAgICAgIENoYW5uZWxOYW1lXG4gICAgfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHR5cGUgKiBhcyBDU1MgZnJvbSAnY3NzdHlwZSc7XG4gICAgaW1wb3J0IGF1dG9UaW1lRm9ybWF0IGZyb20gJy4uL2hlbHBlcnMvYXV0b1RpbWVGb3JtYXQuanMnO1xuICAgIGltcG9ydCB7IGF1dG9UaWNrcyB9IGZyb20gJy4uL2hlbHBlcnMvYXV0b1RpY2tzLmpzJztcbiAgICBpbXBvcnQgeyByZXNvbHZlU2NhbGVkU3R5bGVzIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlLmpzJztcbiAgICBpbXBvcnQgeyBnZXRQbG90RGVmYXVsdHMgfSBmcm9tICcuLi9ob29rcy9wbG90RGVmYXVsdHMuanMnO1xuICAgIGltcG9ydCB7IGV4dGVudCB9IGZyb20gJ2QzLWFycmF5JztcbiAgICBpbXBvcnQgeyB1c2VQbG90IH0gZnJvbSAnLi4vaG9va3MvdXNlUGxvdC5zdmVsdGUuanMnO1xuXG4gICAgaW50ZXJmYWNlIEF4aXNYTWFya1Byb3BzIGV4dGVuZHMgT21pdDxcbiAgICAgICAgQmFzZU1hcmtQcm9wczxEYXR1bT4sXG4gICAgICAgICdmaWxsT3BhY2l0eScgfCAncGFpbnRPcmRlcicgfCAndGl0bGUnIHwgJ2hyZWYnIHwgJ3RhcmdldCdcbiAgICA+IHtcbiAgICAgICAgZGF0YT86IERhdHVtW107XG4gICAgICAgIGF1dG9tYXRpYz86IGJvb2xlYW47XG4gICAgICAgIHRpdGxlPzogc3RyaW5nIHwgZmFsc2UgfCBudWxsO1xuICAgICAgICBhbmNob3I/OiAndG9wJyB8ICdib3R0b20nO1xuICAgICAgICBpbnRlcnZhbD86IHN0cmluZyB8IG51bWJlcjtcbiAgICAgICAgZmFjZXRBbmNob3I/OiAnYXV0bycgfCAndG9wLWVtcHR5JyB8ICdib3R0b20tZW1wdHknIHwgJ3RvcCcgfCAnYm90dG9tJztcbiAgICAgICAgbGFiZWxBbmNob3I/OiAnYXV0bycgfCAnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCc7XG4gICAgICAgIHRpY2tTaXplPzogbnVtYmVyO1xuICAgICAgICB0aWNrRm9udFNpemU/OiBDb25zdGFudEFjY2Vzc29yPG51bWJlciwgRGF0dW0+O1xuICAgICAgICB0aXRsZUZvbnRTaXplPzogbnVtYmVyO1xuICAgICAgICB0aWNrUGFkZGluZz86IG51bWJlcjtcbiAgICAgICAgdGlja0Zvcm1hdD86XG4gICAgICAgICAgICB8ICdhdXRvJ1xuICAgICAgICAgICAgfCBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc1xuICAgICAgICAgICAgfCBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnNcbiAgICAgICAgICAgIHwgKChkOiBSYXdWYWx1ZSwgaTogbnVtYmVyKSA9PiBzdHJpbmcpO1xuICAgICAgICB0aWNrQ2xhc3M/OiBDb25zdGFudEFjY2Vzc29yPHN0cmluZywgRGF0dW0+O1xuICAgICAgICAvKiogdGlja3MgaXMgYSBzaG9ydGhhbmQgZm9yIGRlZmluaW5nIGRhdGEsIHRpY2tDb3VudCBvciBpbnRlcnZhbCAqL1xuICAgICAgICB0aWNrcz86IG51bWJlciB8IHN0cmluZyB8IERhdHVtW107XG4gICAgICAgIC8qKiBzZXQgdG8gZmFsc2Ugb3IgbnVsbCB0byBkaXNhYmxlIHRpY2sgbGFiZWxzICovXG4gICAgICAgIHRleHQ/OiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgLyoqIGFwcHJveGltYXRlIG51bWJlciBvZiB0aWNrcyB0byBiZSBnZW5lcmF0ZWQgKi9cbiAgICAgICAgdGlja0NvdW50PzogbnVtYmVyO1xuICAgICAgICAvKiogYXBwcm94aW1hdGUgbnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIGdlbmVyYXRlZCB0aWNrcyAqL1xuICAgICAgICB0aWNrU3BhY2luZz86IG51bWJlcjtcbiAgICAgICAgLyoqIHRleHQgYW5jaG9yIGZvciBheGlzIGxhYmVscyAqL1xuICAgICAgICB0ZXh0QW5jaG9yPzogQ29uc3RhbnRBY2Nlc3NvcjxDU1MuUHJvcGVydHkuVGV4dEFuY2hvciB8ICdhdXRvJywgRGF0dW0+O1xuICAgICAgICByZW1vdmVEdXBsaWNhdGVUaWNrczogYm9vbGVhbjtcbiAgICB9XG5cbiAgICBsZXQgbWFya1Byb3BzOiBBeGlzWE1hcmtQcm9wcyA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgREVGQVVMVFM6IE9taXQ8QXhpc1hNYXJrUHJvcHMsICdkYXRhJyB8IENoYW5uZWxOYW1lPiA9IHtcbiAgICAgICAgdGlja1NpemU6IDYsXG4gICAgICAgIHRpY2tQYWRkaW5nOiAzLFxuICAgICAgICB0aWNrRm9udFNpemU6IDExLFxuICAgICAgICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgICAgICAgdGV4dEFuY2hvcjogJ2F1dG8nLFxuICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgIGFuY2hvcjogJ2JvdHRvbScsXG4gICAgICAgIC4uLmdldFBsb3REZWZhdWx0cygpLmF4aXMsXG4gICAgICAgIC4uLmdldFBsb3REZWZhdWx0cygpLmF4aXNYXG4gICAgfTtcblxuICAgIGNvbnN0IHsgdGlja3M6IG1hZ2ljVGlja3MgfSA9ICRkZXJpdmVkKHsgLi4uREVGQVVMVFMsIC4uLm1hcmtQcm9wcyB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgYXV0b21hdGljID0gZmFsc2UsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZhY2V0QW5jaG9yID0gJ2F1dG8nLFxuICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgdGlja1NpemUsXG4gICAgICAgIHRpY2tGb250U2l6ZSxcbiAgICAgICAgdGlja1BhZGRpbmcsXG4gICAgICAgIGxhYmVsQW5jaG9yLFxuICAgICAgICB0aWNrRm9ybWF0LFxuICAgICAgICB0aWNrQ2xhc3MsXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWUsXG4gICAgICAgIHRpY2tDb3VudCxcbiAgICAgICAgdGlja1NwYWNpbmcsXG4gICAgICAgIHRleHQgPSB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfTogQXhpc1hNYXJrUHJvcHMgPSAkZGVyaXZlZCh7XG4gICAgICAgIGRhdGE6IEFycmF5LmlzQXJyYXkobWFnaWNUaWNrcykgPyBtYWdpY1RpY2tzIDogW10sXG4gICAgICAgIHRpY2tDb3VudDogdHlwZW9mIG1hZ2ljVGlja3MgPT09ICdudW1iZXInID8gbWFnaWNUaWNrcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgaW50ZXJ2YWw6IHR5cGVvZiBtYWdpY1RpY2tzID09PSAnc3RyaW5nJyA/IG1hZ2ljVGlja3MgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLkRFRkFVTFRTLFxuICAgICAgICAuLi5tYXJrUHJvcHNcbiAgICB9KTtcblxuICAgIGNvbnN0IHBsb3QgPSB1c2VQbG90KCk7XG5cbiAgICBjb25zdCBhdXRvVGlja0NvdW50ID0gJGRlcml2ZWQoXG4gICAgICAgIHRpY2tDb3VudCAhPSBudWxsXG4gICAgICAgICAgICA/IHRpY2tDb3VudFxuICAgICAgICAgICAgOiB0aWNrU3BhY2luZyAhPSBudWxsXG4gICAgICAgICAgICAgID8gTWF0aC5tYXgoMywgTWF0aC5yb3VuZChwbG90LmZhY2V0V2lkdGggLyB0aWNrU3BhY2luZykpXG4gICAgICAgICAgICAgIDogTWF0aC5tYXgoMywgTWF0aC5yb3VuZChwbG90LmZhY2V0V2lkdGggLyBwbG90Lm9wdGlvbnMueC50aWNrU3BhY2luZykpXG4gICAgKTtcblxuICAgIGNvbnN0IHRpY2tzOiBSYXdWYWx1ZVtdID0gJGRlcml2ZWQoXG4gICAgICAgIGRhdGEubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAvLyB1c2UgY3VzdG9tIHRpY2sgdmFsdWVzIGlmIHVzZXIgcGFzc2VkIGFueSBhcyBwcm9wXG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmV3IFNldChkYXRhKSlcbiAgICAgICAgICAgIDogLy8gdXNlIGN1c3RvbSBzY2FsZSB0aWNrIHZhbHVlcyBpZiB1c2VyIHBhc3NlZCBhbnkgYXMgcGxvdCBzY2FsZSBvcHRpb25cbiAgICAgICAgICAgICAgYXV0b1RpY2tzKFxuICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueC50eXBlLFxuICAgICAgICAgICAgICAgICAgcGxvdC5vcHRpb25zLngudGlja3MsXG4gICAgICAgICAgICAgICAgICBpbnRlcnZhbCB8fCBwbG90Lm9wdGlvbnMueC5pbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgIHBsb3Quc2NhbGVzLnguZG9tYWluLFxuICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueC5mbixcbiAgICAgICAgICAgICAgICAgIGF1dG9UaWNrQ291bnRcbiAgICAgICAgICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCB1c2VDb21wYWN0Tm90YXRpb24gPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlID1cbiAgICAgICAgICAgIGV4dGVudChwbG90LnNjYWxlcy54LmRvbWFpbikuZmlsdGVyKFxuICAgICAgICAgICAgICAgIChkKTogZCBpcyBudW1iZXIgPT4gdHlwZW9mIGQgPT09ICdudW1iZXInICYmIE51bWJlci5pc0Zpbml0ZShkKVxuICAgICAgICAgICAgKSA/PyBbXTtcblxuICAgICAgICBpZiAocmFuZ2VbMF0gPT09IHVuZGVmaW5lZCB8fCByYW5nZVsxXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNyb3NzZXNaZXJvID0gcmFuZ2VbMF0gPD0gMCAmJiByYW5nZVsxXSA+PSAwO1xuICAgICAgICBpZiAoY3Jvc3Nlc1plcm8pIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBtYWduaXR1ZGVzID0gcmFuZ2UubWFwKChkKSA9PlxuICAgICAgICAgICAgZCA9PT0gMCA/IC1JbmZpbml0eSA6IE1hdGguZmxvb3IoTWF0aC5sb2cxMChNYXRoLmFicyhkKSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBtYWduaXR1ZGVzWzBdICE9PSBtYWduaXR1ZGVzWzFdO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdGlja0ZtdCA9ICRkZXJpdmVkKHRpY2tGb3JtYXQgfHwgcGxvdC5vcHRpb25zLngudGlja0Zvcm1hdCk7XG5cbiAgICBjb25zdCB1c2VUaWNrRm9ybWF0ID0gJGRlcml2ZWQoXG4gICAgICAgIHR5cGVvZiB0aWNrRm10ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRpY2tGbXRcbiAgICAgICAgICAgIDogcGxvdC5zY2FsZXMueC50eXBlID09PSAnYmFuZCcgfHwgcGxvdC5zY2FsZXMueC50eXBlID09PSAncG9pbnQnXG4gICAgICAgICAgICAgID8gKGQpID0+IGRcbiAgICAgICAgICAgICAgOiBwbG90LnNjYWxlcy54LnR5cGUgPT09ICd0aW1lJ1xuICAgICAgICAgICAgICAgID8gLy8gdGltZSBzY2FsZVxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHRpY2tGbXQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gKGQ6IERhdGUpID0+IEludGwuRGF0ZVRpbWVGb3JtYXQocGxvdC5vcHRpb25zLmxvY2FsZSwgdGlja0ZtdCkuZm9ybWF0KGQpXG4gICAgICAgICAgICAgICAgICAgIDogYXV0b1RpbWVGb3JtYXQocGxvdC5zY2FsZXMueCwgcGxvdC5wbG90V2lkdGgsIHBsb3Qub3B0aW9ucy5sb2NhbGUpXG4gICAgICAgICAgICAgICAgOiAvLyBudW1lcmljIHNjYWxlXG4gICAgICAgICAgICAgICAgICB0eXBlb2YgdGlja0ZtdCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgID8gKGQ6IG51bWJlcikgPT4gSW50bC5OdW1iZXJGb3JtYXQocGxvdC5vcHRpb25zLmxvY2FsZSwgdGlja0ZtdCkuZm9ybWF0KGQpXG4gICAgICAgICAgICAgICAgICA6IC8vIGF1dG9cbiAgICAgICAgICAgICAgICAgICAgKGQ6IFJhd1ZhbHVlKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgSW50bC5OdW1iZXJGb3JtYXQocGxvdC5vcHRpb25zLmxvY2FsZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBjb21wYWN0IG5vdGF0aW9uIGlmIHJhbmdlIGNvdmVycyBtdWx0aXBsZSBtYWduaXR1ZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHVzZUNvbXBhY3ROb3RhdGlvbiA/IHsgbm90YXRpb246ICdjb21wYWN0JyB9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLkRFRkFVTFRTLm51bWJlckZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogcGxvdC5vcHRpb25zLngucGVyY2VudCA/ICdwZXJjZW50JyA6ICdkZWNpbWFsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuZm9ybWF0KGQpXG4gICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnNMYWJlbCA9ICRkZXJpdmVkKHBsb3Qub3B0aW9ucz8ueD8ubGFiZWwpO1xuICAgIGNvbnN0IHNjYWxlVHlwZSA9ICRkZXJpdmVkKHBsb3Quc2NhbGVzLngudHlwZSk7XG4gICAgY29uc3QgaXNRdWFudGl0YXRpdmUgPSAkZGVyaXZlZChzY2FsZVR5cGUgIT09ICdwb2ludCcgJiYgc2NhbGVUeXBlICE9PSAnYmFuZCcpO1xuXG4gICAgY29uc3QgdXNlVGl0bGUgPSAkZGVyaXZlZChcbiAgICAgICAgdGl0bGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aXRsZSB8fCAnJ1xuICAgICAgICAgICAgOiBvcHRpb25zTGFiZWwgPT09IG51bGxcbiAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgIDogb3B0aW9uc0xhYmVsICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnNMYWJlbFxuICAgICAgICAgICAgICAgIDogcGxvdC5zY2FsZXMueC5hdXRvVGl0bGVcbiAgICAgICAgICAgICAgICAgID8gaXNRdWFudGl0YXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICA/IHBsb3Qub3B0aW9ucy54Py5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gYOKGkCAke3Bsb3Quc2NhbGVzLnguYXV0b1RpdGxlfSR7cGxvdC5vcHRpb25zLngucGVyY2VudCA/ICcgKCUpJyA6ICcnfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgJHtwbG90LnNjYWxlcy54LmF1dG9UaXRsZX0ke3Bsb3Qub3B0aW9ucy54LnBlcmNlbnQgPyAnICglKScgOiAnJ30g4oaSYFxuICAgICAgICAgICAgICAgICAgICAgIDogcGxvdC5zY2FsZXMueC5hdXRvVGl0bGVcbiAgICAgICAgICAgICAgICAgIDogJydcbiAgICApO1xuXG4gICAgY29uc3QgdXNlTGFiZWxBbmNob3IgPSAkZGVyaXZlZChsYWJlbEFuY2hvciB8fCBwbG90Lm9wdGlvbnM/Lng/LmxhYmVsQW5jaG9yIHx8ICdhdXRvJyk7XG4gICAgY29uc3QgdGl0bGVBbGlnbiA9ICRkZXJpdmVkKFxuICAgICAgICB1c2VMYWJlbEFuY2hvciA9PT0gJ2F1dG8nID8gKGlzUXVhbnRpdGF0aXZlID8gJ3JpZ2h0JyA6ICdjZW50ZXInKSA6IHVzZUxhYmVsQW5jaG9yXG4gICAgKTtcblxuICAgIGNvbnN0IHsgZ2V0RmFjZXRTdGF0ZSB9ID0gZ2V0Q29udGV4dDxGYWNldENvbnRleHQ+KCdzdmVsdGVwbG90L2ZhY2V0Jyk7XG4gICAgY29uc3QgeyBsZWZ0LCB0b3AsIGJvdHRvbSwgYm90dG9tRW1wdHksIHRvcEVtcHR5IH0gPSAkZGVyaXZlZChnZXRGYWNldFN0YXRlKCkpO1xuXG4gICAgY29uc3QgdXNlRmFjZXRBbmNob3IgPSAkZGVyaXZlZChcbiAgICAgICAgZmFjZXRBbmNob3IgIT09ICdhdXRvJyA/IGZhY2V0QW5jaG9yIDogYW5jaG9yID09PSAnYm90dG9tJyA/ICdib3R0b20tZW1wdHknIDogJ3RvcC1lbXB0eSdcbiAgICApO1xuICAgIGNvbnN0IHNob3dBeGlzID0gJGRlcml2ZWQoXG4gICAgICAgIHVzZUZhY2V0QW5jaG9yID09PSAndG9wJ1xuICAgICAgICAgICAgPyB0b3BcbiAgICAgICAgICAgIDogdXNlRmFjZXRBbmNob3IgPT09ICdib3R0b20nXG4gICAgICAgICAgICAgID8gYm90dG9tXG4gICAgICAgICAgICAgIDogdXNlRmFjZXRBbmNob3IgPT09ICd0b3AtZW1wdHknXG4gICAgICAgICAgICAgICAgPyB0b3BFbXB0eVxuICAgICAgICAgICAgICAgIDogYm90dG9tRW1wdHlcbiAgICApO1xuPC9zY3JpcHQ+XG5cbjxNYXJrXG4gICAgdHlwZT1cImF4aXNYXCJcbiAgICBkYXRhPXtkYXRhLmxlbmd0aCA/IGRhdGEubWFwKCh0aWNrKSA9PiAoeyBfX3g6IHRpY2sgfSkpIDogW119XG4gICAgY2hhbm5lbHM9e1sneCddfVxuICAgIHsuLi5vcHRpb25zfVxuICAgIHg9XCJfX3hcIlxuICAgIHthdXRvbWF0aWN9PlxuICAgIHsjaWYgbGVmdCAmJiB0b3AgJiYgdXNlVGl0bGV9XG4gICAgICAgIDx0ZXh0XG4gICAgICAgICAgICBzdHlsZT17cmVzb2x2ZVNjYWxlZFN0eWxlcyhcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBvcHRpb25zLnRpdGxlRm9udFNpemUgfHwgMTEsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZUFsaWduID09PSAncmlnaHQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGl0bGVBbGlnbiA9PT0gJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YXJ0J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgcGxvdCxcbiAgICAgICAgICAgICAgICAnZmlsbCdcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB4PXtwbG90Lm9wdGlvbnMubWFyZ2luTGVmdCArXG4gICAgICAgICAgICAgICAgcGxvdC5wbG90V2lkdGggKiAodGl0bGVBbGlnbiA9PT0gJ3JpZ2h0JyA/IDEgOiB0aXRsZUFsaWduID09PSAnY2VudGVyJyA/IDAuNSA6IDApfVxuICAgICAgICAgICAgeT17YW5jaG9yID09PSAndG9wJ1xuICAgICAgICAgICAgICAgID8gKG9wdGlvbnMudGl0bGVGb250U2l6ZSB8fCAxMSkgKyA1XG4gICAgICAgICAgICAgICAgOiBwbG90LmhlaWdodCAtIChvcHRpb25zLnRpdGxlRm9udFNpemUgfHwgMTEpIC0gNX1cbiAgICAgICAgICAgIGNsYXNzPVwiYXhpcy14LXRpdGxlXCJcbiAgICAgICAgICAgIGRvbWluYW50LWJhc2VsaW5lPXthbmNob3IgPT09ICd0b3AnID8gJ2F1dG8nIDogJ2hhbmdpbmcnfT57dXNlVGl0bGV9PC90ZXh0PlxuICAgIHsvaWZ9XG4gICAgeyNpZiBzaG93QXhpc31cbiAgICAgICAgPEJhc2VBeGlzWFxuICAgICAgICAgICAge2FuY2hvcn1cbiAgICAgICAgICAgIHtjbGFzc05hbWV9XG4gICAgICAgICAgICB7bGFiZWxBbmNob3J9XG4gICAgICAgICAgICBvcHRpb25zPXt7IC4uLm9wdGlvbnMsIC4uLnBsb3Qub3B0aW9ucy54IH19XG4gICAgICAgICAgICB7cGxvdH1cbiAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAge3RpY2tDbGFzc31cbiAgICAgICAgICAgIHt0aWNrRm9udFNpemV9XG4gICAgICAgICAgICB7dGlja1BhZGRpbmd9XG4gICAgICAgICAgICB7dGlja3N9XG4gICAgICAgICAgICB7dGlja1NpemV9XG4gICAgICAgICAgICBoZWlnaHQ9e3Bsb3QuZmFjZXRIZWlnaHR9XG4gICAgICAgICAgICBtYXJnaW5Ub3A9e3Bsb3Qub3B0aW9ucy5tYXJnaW5Ub3B9XG4gICAgICAgICAgICBzY2FsZUZuPXtwbG90LnNjYWxlcy54LmZufVxuICAgICAgICAgICAgc2NhbGVUeXBlPXtwbG90LnNjYWxlcy54LnR5cGV9XG4gICAgICAgICAgICB0aWNrRm9ybWF0PXt1c2VUaWNrRm9ybWF0fVxuICAgICAgICAgICAgdGl0bGU9e3VzZVRpdGxlfSAvPlxuICAgIHsvaWZ9XG48L01hcms+XG5cbjxzdHlsZT5cbiAgICB0ZXh0IHtcbiAgICAgICAgZmlsbDogY3VycmVudENvbG9yO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function AxisX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AxisX);
  append_styles($$anchor, $$css4);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    tickSize: 6,
    tickPadding: 3,
    tickFontSize: 11,
    titleFontSize: 11,
    textAnchor: "auto",
    opacity: 0.8,
    anchor: "bottom",
    ...getPlotDefaults().axis,
    ...getPlotDefaults().axisX
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), magicTicks = tag(user_derived(() => get($$d).ticks), "magicTicks");
  const $$d_1 = user_derived(() => ({
    data: Array.isArray(get(magicTicks)) ? get(magicTicks) : [],
    tickCount: strict_equals(typeof get(magicTicks), "number") ? get(magicTicks) : void 0,
    interval: strict_equals(typeof get(magicTicks), "string") ? get(magicTicks) : void 0,
    ...DEFAULTS,
    ...markProps
  })), data = tag(user_derived(() => get($$d_1).data), "data"), automatic = tag(user_derived(() => fallback(get($$d_1).automatic, false)), "automatic"), title = tag(user_derived(() => get($$d_1).title), "title"), anchor = tag(user_derived(() => get($$d_1).anchor), "anchor"), facetAnchor = tag(user_derived(() => fallback(get($$d_1).facetAnchor, "auto")), "facetAnchor"), interval2 = tag(user_derived(() => get($$d_1).interval), "interval"), tickSize = tag(user_derived(() => get($$d_1).tickSize), "tickSize"), tickFontSize = tag(user_derived(() => get($$d_1).tickFontSize), "tickFontSize"), tickPadding = tag(user_derived(() => get($$d_1).tickPadding), "tickPadding"), labelAnchor = tag(user_derived(() => get($$d_1).labelAnchor), "labelAnchor"), tickFormat2 = tag(user_derived(() => get($$d_1).tickFormat), "tickFormat"), tickClass = tag(user_derived(() => get($$d_1).tickClass), "tickClass"), className = tag(user_derived(() => get($$d_1).class), "className"), tickCount = tag(user_derived(() => get($$d_1).tickCount), "tickCount"), tickSpacing = tag(user_derived(() => get($$d_1).tickSpacing), "tickSpacing"), text2 = tag(user_derived(() => fallback(get($$d_1).text, true)), "text"), options = tag(
    user_derived(() => exclude_from_object(get($$d_1), [
      "data",
      "automatic",
      "title",
      "anchor",
      "facetAnchor",
      "interval",
      "tickSize",
      "tickFontSize",
      "tickPadding",
      "labelAnchor",
      "tickFormat",
      "tickClass",
      "class",
      "tickCount",
      "tickSpacing",
      "text"
    ])),
    "options"
  );
  const plot = usePlot();
  const autoTickCount = tag(
    user_derived(() => equals(get(tickCount), null, false) ? get(tickCount) : equals(get(tickSpacing), null, false) ? Math.max(3, Math.round(plot.facetWidth / get(tickSpacing))) : Math.max(3, Math.round(plot.facetWidth / plot.options.x.tickSpacing))),
    "autoTickCount"
  );
  const ticks2 = tag(
    user_derived(() => get(data).length > 0 ? (
      // use custom tick values if user passed any as prop
      Array.from(new Set(get(data)))
    ) : (
      // use custom scale tick values if user passed any as plot scale option
      autoTicks(plot.scales.x.type, plot.options.x.ticks, get(interval2) || plot.options.x.interval, plot.scales.x.domain, plot.scales.x.fn, get(autoTickCount))
    )),
    "ticks"
  );
  const useCompactNotation = tag(
    user_derived(() => {
      const range3 = extent(plot.scales.x.domain).filter((d) => strict_equals(typeof d, "number") && Number.isFinite(d)) ?? [];
      if (strict_equals(range3[0], void 0) || strict_equals(range3[1], void 0)) return false;
      const crossesZero = range3[0] <= 0 && range3[1] >= 0;
      if (crossesZero) return true;
      const magnitudes = range3.map((d) => strict_equals(d, 0) ? -Infinity : Math.floor(Math.log10(Math.abs(d))));
      return strict_equals(magnitudes[0], magnitudes[1], false);
    }),
    "useCompactNotation"
  );
  const tickFmt = tag(user_derived(() => get(tickFormat2) || plot.options.x.tickFormat), "tickFmt");
  const useTickFormat = tag(
    user_derived(() => strict_equals(typeof get(tickFmt), "function") ? get(tickFmt) : strict_equals(plot.scales.x.type, "band") || strict_equals(plot.scales.x.type, "point") ? (d) => d : strict_equals(plot.scales.x.type, "time") ? (
      // time scale
      strict_equals(typeof get(tickFmt), "object") ? (d) => Intl.DateTimeFormat(plot.options.locale, get(tickFmt)).format(d) : autoTimeFormat(plot.scales.x, plot.plotWidth, plot.options.locale)
    ) : (
      // numeric scale
      strict_equals(typeof get(tickFmt), "object") ? (d) => Intl.NumberFormat(plot.options.locale, get(tickFmt)).format(d) : (
        // auto
        (d) => Intl.NumberFormat(plot.options.locale, {
          // use compact notation if range covers multiple magnitudes
          ...get(useCompactNotation) ? { notation: "compact" } : {},
          ...DEFAULTS.numberFormat,
          style: plot.options.x.percent ? "percent" : "decimal"
        }).format(d)
      )
    )),
    "useTickFormat"
  );
  const optionsLabel = tag(user_derived(() => plot.options?.x?.label), "optionsLabel");
  const scaleType = tag(user_derived(() => plot.scales.x.type), "scaleType");
  const isQuantitative = tag(user_derived(() => strict_equals(get(scaleType), "point", false) && strict_equals(get(scaleType), "band", false)), "isQuantitative");
  const useTitle = tag(
    user_derived(() => strict_equals(get(title), void 0, false) ? get(title) || "" : strict_equals(get(optionsLabel), null) ? null : strict_equals(get(optionsLabel), void 0, false) ? get(optionsLabel) : plot.scales.x.autoTitle ? get(isQuantitative) ? plot.options.x?.reverse ? ` ${plot.scales.x.autoTitle}${plot.options.x.percent ? " (%)" : ""}` : `${plot.scales.x.autoTitle}${plot.options.x.percent ? " (%)" : ""} ` : plot.scales.x.autoTitle : ""),
    "useTitle"
  );
  const useLabelAnchor = tag(user_derived(() => get(labelAnchor) || plot.options?.x?.labelAnchor || "auto"), "useLabelAnchor");
  const titleAlign = tag(
    user_derived(() => strict_equals(get(useLabelAnchor), "auto") ? get(isQuantitative) ? "right" : "center" : get(useLabelAnchor)),
    "titleAlign"
  );
  const { getFacetState } = getContext("svelteplot/facet");
  const $$d_2 = user_derived(getFacetState), left = tag(user_derived(() => get($$d_2).left), "left"), top = tag(user_derived(() => get($$d_2).top), "top"), bottom = tag(user_derived(() => get($$d_2).bottom), "bottom"), bottomEmpty = tag(user_derived(() => get($$d_2).bottomEmpty), "bottomEmpty"), topEmpty = tag(user_derived(() => get($$d_2).topEmpty), "topEmpty");
  const useFacetAnchor = tag(
    user_derived(() => strict_equals(get(facetAnchor), "auto", false) ? get(facetAnchor) : strict_equals(get(anchor), "bottom") ? "bottom-empty" : "top-empty"),
    "useFacetAnchor"
  );
  const showAxis = tag(
    user_derived(() => strict_equals(get(useFacetAnchor), "top") ? get(top) : strict_equals(get(useFacetAnchor), "bottom") ? get(bottom) : strict_equals(get(useFacetAnchor), "top-empty") ? get(topEmpty) : get(bottomEmpty)),
    "showAxis"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => get(data).length ? get(data).map((tick) => ({ __x: tick })) : []);
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "axisX",
          get data() {
            return get($0);
          },
          channels: ["x"]
        },
        () => get(options),
        {
          x: "__x",
          get automatic() {
            return get(automatic);
          },
          children: wrap_snippet(AxisX, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_13();
            var node_1 = first_child(fragment_1);
            {
              var consequent = ($$anchor3) => {
                var text_1 = root_25();
                var text_2 = child(text_1, true);
                reset(text_1);
                template_effect(
                  ($02) => {
                    set_style(text_1, $02);
                    set_attribute(text_1, "x", plot.options.marginLeft + plot.plotWidth * (strict_equals(get(titleAlign), "right") ? 1 : strict_equals(get(titleAlign), "center") ? 0.5 : 0));
                    set_attribute(text_1, "y", strict_equals(get(anchor), "top") ? (get(options).titleFontSize || 11) + 5 : plot.height - (get(options).titleFontSize || 11) - 5);
                    set_attribute(text_1, "dominant-baseline", strict_equals(get(anchor), "top") ? "auto" : "hanging");
                    set_text(text_2, get(useTitle));
                  },
                  [
                    () => resolveScaledStyles(
                      null,
                      {
                        opacity: 0.8,
                        ...get(options),
                        stroke: null,
                        fontSize: get(options).titleFontSize || 11,
                        textAnchor: strict_equals(get(titleAlign), "right") ? "end" : strict_equals(get(titleAlign), "center") ? "middle" : "start"
                      },
                      {},
                      plot,
                      "fill"
                    )
                  ]
                );
                append($$anchor3, text_1);
              };
              add_svelte_meta(
                () => if_block(node_1, ($$render) => {
                  if (get(left) && get(top) && get(useTitle)) $$render(consequent);
                }),
                "if",
                AxisX,
                213,
                4
              );
            }
            var node_2 = sibling(node_1);
            {
              var consequent_1 = ($$anchor3) => {
                var fragment_2 = comment();
                var node_3 = first_child(fragment_2);
                {
                  let $02 = user_derived(() => ({ ...get(options), ...plot.options.x }));
                  add_svelte_meta(
                    () => BaseAxisX_default(node_3, {
                      get anchor() {
                        return get(anchor);
                      },
                      get className() {
                        return get(className);
                      },
                      get labelAnchor() {
                        return get(labelAnchor);
                      },
                      get options() {
                        return get($02);
                      },
                      get plot() {
                        return plot;
                      },
                      get text() {
                        return get(text2);
                      },
                      get tickClass() {
                        return get(tickClass);
                      },
                      get tickFontSize() {
                        return get(tickFontSize);
                      },
                      get tickPadding() {
                        return get(tickPadding);
                      },
                      get ticks() {
                        return get(ticks2);
                      },
                      get tickSize() {
                        return get(tickSize);
                      },
                      get height() {
                        return plot.facetHeight;
                      },
                      get marginTop() {
                        return plot.options.marginTop;
                      },
                      get scaleFn() {
                        return plot.scales.x.fn;
                      },
                      get scaleType() {
                        return plot.scales.x.type;
                      },
                      get tickFormat() {
                        return get(useTickFormat);
                      },
                      get title() {
                        return get(useTitle);
                      }
                    }),
                    "component",
                    AxisX,
                    242,
                    8,
                    { componentTag: "BaseAxisX" }
                  );
                }
                append($$anchor3, fragment_2);
              };
              add_svelte_meta(
                () => if_block(node_2, ($$render) => {
                  if (get(showAxis)) $$render(consequent_1);
                }),
                "if",
                AxisX,
                241,
                4
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      AxisX,
      206,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  AxisX = hmr(AxisX);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-0ehf4o43eJsC");
    AxisX[HMR].update(module.default);
  });
}
var AxisX_default = AxisX;

// node_modules/svelteplot/dist/marks/helpers/BaseAxisY.svelte
BaseAxisY[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/BaseAxisY.svelte";
var root_32 = add_locations(from_svg(`<line></line>`), BaseAxisY[FILENAME], [[189, 20]]);
var root_42 = add_locations(from_svg(`<text> </text>`), BaseAxisY[FILENAME], [[195, 20]]);
var root_26 = add_locations(from_svg(`<g><!><!></g>`), BaseAxisY[FILENAME], [[175, 12]]);
var root3 = add_locations(from_svg(`<g></g>`), BaseAxisY[FILENAME], [[158, 0]]);
var $$css5 = {
  hash: "s-aQLKlrG7cGGX",
  code: "\n    line.s-aQLKlrG7cGGX {\n        stroke: currentColor;\n    }\n    text.s-aQLKlrG7cGGX {\n        fill: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFzZUF4aXNZLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQmFzZUF4aXNZLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIGltcG9ydCB7IGdldENvbnRleHQsIHVudHJhY2sgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IHJhbmRvbUlkLCB0ZXN0RmlsdGVyIH0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgcmVzb2x2ZVByb3AsIHJlc29sdmVTdHlsZXMgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Jlc29sdmUuanMnO1xuICAgIGltcG9ydCB7IG1heCB9IGZyb20gJ2QzLWFycmF5JztcbiAgICBpbXBvcnQgdHlwZSB7XG4gICAgICAgIEF1dG9NYXJnaW5TdG9yZXMsXG4gICAgICAgIENvbnN0YW50QWNjZXNzb3IsXG4gICAgICAgIERhdGFSZWNvcmQsXG4gICAgICAgIFBsb3RTdGF0ZSxcbiAgICAgICAgUmF3VmFsdWUsXG4gICAgICAgIFNjYWxlZERhdGFSZWNvcmQsXG4gICAgICAgIFNjYWxlVHlwZVxuICAgIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IFJBV19WQUxVRSB9IGZyb20gJy4uLy4uL3RyYW5zZm9ybXMvcmVjb3JkaXplJztcbiAgICBpbXBvcnQgeyBJTkRFWCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5cbiAgICB0eXBlIEJhc2VBeGlzWVByb3BzID0ge1xuICAgICAgICBzY2FsZUZuOiAoZDogUmF3VmFsdWUpID0+IG51bWJlcjtcbiAgICAgICAgc2NhbGVUeXBlOiBTY2FsZVR5cGU7XG4gICAgICAgIHRpY2tzOiBSYXdWYWx1ZVtdO1xuICAgICAgICB0aWNrRm9ybWF0OiAoZDogUmF3VmFsdWUsIGk6IG51bWJlciwgdGlja3M6IFJhd1ZhbHVlW10pID0+IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgICAgICBhbmNob3I6ICdsZWZ0JyB8ICdyaWdodCc7XG4gICAgICAgIGxpbmVBbmNob3I6ICd0b3AnIHwgJ2NlbnRlcicgfCAnYm90dG9tJztcbiAgICAgICAgdGlja1NpemU6IG51bWJlcjtcbiAgICAgICAgdGlja1BhZGRpbmc6IG51bWJlcjtcbiAgICAgICAgdGlja0ZvbnRTaXplOiBDb25zdGFudEFjY2Vzc29yPG51bWJlcj47XG4gICAgICAgIHRpY2tDbGFzczogQ29uc3RhbnRBY2Nlc3NvcjxudW1iZXI+O1xuICAgICAgICBtYXJnaW5MZWZ0OiBudW1iZXI7XG4gICAgICAgIHdpZHRoOiBudW1iZXI7XG4gICAgICAgIHRpdGxlOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBkeDogQ29uc3RhbnRBY2Nlc3NvcjxudW1iZXI+O1xuICAgICAgICAgICAgZHk6IENvbnN0YW50QWNjZXNzb3I8bnVtYmVyPjtcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnO1xuICAgICAgICB9O1xuICAgICAgICBwbG90OiBQbG90U3RhdGU7XG4gICAgICAgIHRleHQ6IGJvb2xlYW4gfCBudWxsO1xuICAgICAgICBjbGFzczogc3RyaW5nO1xuICAgIH07XG5cbiAgICBsZXQge1xuICAgICAgICBzY2FsZUZuLFxuICAgICAgICBzY2FsZVR5cGUsXG4gICAgICAgIHRpY2tzLFxuICAgICAgICB0aWNrRm9ybWF0LFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGxpbmVBbmNob3IsXG4gICAgICAgIHRpY2tTaXplLFxuICAgICAgICB0aWNrUGFkZGluZyxcbiAgICAgICAgdGlja0ZvbnRTaXplLFxuICAgICAgICB0aWNrQ2xhc3MsXG4gICAgICAgIG1hcmdpbkxlZnQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgcGxvdCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGV4dCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWUgPSAnYXhpcy15J1xuICAgIH06IEJhc2VBeGlzWVByb3BzID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBMSU5FX0FOQ0hPUiA9IHtcbiAgICAgICAgdG9wOiAnaGFuZ2luZycsXG4gICAgICAgIGNlbnRlcjogJ21pZGRsZScsXG4gICAgICAgIGJvdHRvbTogJ2F1dG8nXG4gICAgfTtcblxuICAgIGNvbnN0IHBvc2l0aW9uZWRUaWNrcyA9ICRkZXJpdmVkLmJ5KCgpID0+IHtcbiAgICAgICAgbGV0IHRpY2tPYmplY3RzID0gdGlja3MubWFwKCh0aWNrLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXR1bSA9IHsgW1JBV19WQUxVRV06IHRpY2ssIFtJTkRFWF06IGkgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkeDogK3Jlc29sdmVQcm9wKG9wdGlvbnMuZHgsIGRhdHVtLCAwKSxcbiAgICAgICAgICAgICAgICBkeTogK3Jlc29sdmVQcm9wKG9wdGlvbnMuZHksIGRhdHVtLCAwKSxcbiAgICAgICAgICAgICAgICB5OiBzY2FsZUZuKHRpY2spICsgKHNjYWxlVHlwZSA9PT0gJ2JhbmQnID8gc2NhbGVGbi5iYW5kd2lkdGgoKSAqIDAuNSA6IDApLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRpY2tGb3JtYXQodGljaywgaSwgdGlja3MpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwgYXMgU1ZHVGV4dEVsZW1lbnQgfCBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IFQgPSB0aWNrT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBqID0gaTtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBwcmVjZWRpbmcgdGljayB0aGF0IHdhcyBub3QgaGlkZGVuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaiA+PSAwICYmIHRpY2tPYmplY3RzW2pdLmhpZGRlbik7XG4gICAgICAgICAgICAgICAgaWYgKGogPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrTGFiZWxTcGFjZSA9IE1hdGguYWJzKHRpY2tPYmplY3RzW2ldLnkgLSB0aWNrT2JqZWN0c1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgdGlja09iamVjdHNbaV0uaGlkZGVuID0gdGlja0xhYmVsU3BhY2UgPCAxNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tPYmplY3RzO1xuICAgIH0pO1xuXG4gICAgbGV0IHRpY2tUZXh0cyA9ICRzdGF0ZShbXSBhcyBTVkdUZXh0RWxlbWVudFtdKTtcblxuICAgIGNvbnN0IGlzUXVhbnRpdGF0aXZlID0gJGRlcml2ZWQoc2NhbGVUeXBlICE9PSAncG9pbnQnICYmIHNjYWxlVHlwZSAhPT0gJ2JhbmQnKTtcblxuICAgIC8vIGdlbmVyYXRlIGlkIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIG1hcmdpbnNcbiAgICBjb25zdCBpZCA9IHJhbmRvbUlkKCk7XG5cbiAgICBjb25zdCB7IGF1dG9NYXJnaW5MZWZ0LCBhdXRvTWFyZ2luUmlnaHQsIGF1dG9NYXJnaW5Ub3AgfSA9XG4gICAgICAgIGdldENvbnRleHQ8QXV0b01hcmdpblN0b3Jlcz4oJ3N2ZWx0ZXBsb3QvYXV0b01hcmdpbnMnKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICB1bnRyYWNrKCgpID0+IFskYXV0b01hcmdpbkxlZnQsICRhdXRvTWFyZ2luUmlnaHRdKTtcbiAgICAgICAgY29uc3Qgb3V0c2lkZVRleHRBbmNob3IgPSBhbmNob3IgPT09ICdsZWZ0JyA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgICAgLy8gbWVhc3VyZSB0aWNrIGxhYmVsIHdpZHRoc1xuICAgICAgICBjb25zdCBtYXhMYWJlbFdpZHRoID1cbiAgICAgICAgICAgIE1hdGguY2VpbChcbiAgICAgICAgICAgICAgICBtYXgoXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRUaWNrcy5tYXAoKHRpY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlUHJvcChvcHRpb25zLnRleHRBbmNob3IsIHRpY2ssIG91dHNpZGVUZXh0QW5jaG9yKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlVGV4dEFuY2hvclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpY2suaGlkZGVuIHx8ICF0ZXN0RmlsdGVyKHRpY2ssIG9wdGlvbnMpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aWNrVGV4dHNbaV0pIHJldHVybiB0aWNrVGV4dHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfSkgYXMgbnVtYmVyW11cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApICsgTWF0aC5tYXgoMCwgdGlja1BhZGRpbmcgKyB0aWNrU2l6ZSk7XG5cbiAgICAgICAgaWYgKCFpc05hTihtYXhMYWJlbFdpZHRoKSkge1xuICAgICAgICAgICAgaWYgKGFuY2hvciA9PT0gJ2xlZnQnICYmICRhdXRvTWFyZ2luTGVmdC5nZXQoaWQpICE9PSBtYXhMYWJlbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgJGF1dG9NYXJnaW5MZWZ0LnNldChpZCwgbWF4TGFiZWxXaWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvciA9PT0gJ3JpZ2h0JyAmJiAkYXV0b01hcmdpblJpZ2h0LmdldChpZCkgIT09IG1heExhYmVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAkYXV0b01hcmdpblJpZ2h0LnNldChpZCwgbWF4TGFiZWxXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICB1bnRyYWNrKCgpID0+IFskYXV0b01hcmdpblRvcF0pO1xuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgIC8vIGFkZCBtYXJnaW4gdG9wIHRvIG1ha2Ugc29tZSBzcGFjZSBmb3IgdGl0bGVcbiAgICAgICAgICAgICRhdXRvTWFyZ2luVG9wLnNldChpZCwgMjcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gbmVlZCBmb3IgZXh0cmEgbWFyZ2luIHRvcFxuICAgICAgICAgICAgJGF1dG9NYXJnaW5Ub3AuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIGNsZWFyIG1hcmdpbnMgb24gZGVzdHJveVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCRhdXRvTWFyZ2luTGVmdC5oYXMoaWQpKSAkYXV0b01hcmdpbkxlZnQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGlmICgkYXV0b01hcmdpblJpZ2h0LmhhcyhpZCkpICRhdXRvTWFyZ2luUmlnaHQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGlmICgkYXV0b01hcmdpblRvcC5oYXMoaWQpKSAkYXV0b01hcmdpblRvcC5kZWxldGUoaWQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxnIGNsYXNzPXtjbGFzc05hbWV9PlxuICAgIHsjZWFjaCBwb3NpdGlvbmVkVGlja3MgYXMgdGljaywgdCAodGlja1tSQVdfVkFMVUVdKX1cbiAgICAgICAgeyNpZiB0ZXN0RmlsdGVyKHRpY2ssIG9wdGlvbnMpICYmICF0aWNrLmhpZGRlbn1cbiAgICAgICAgICAgIHtAY29uc3QgdGlja0NsYXNzXyA9IHJlc29sdmVQcm9wKHRpY2tDbGFzcywgdGljayl9XG4gICAgICAgICAgICB7QGNvbnN0IFt0ZXh0U3R5bGUsIHRleHRDbGFzc10gPSByZXNvbHZlU3R5bGVzKFxuICAgICAgICAgICAgICAgIHBsb3QsXG4gICAgICAgICAgICAgICAgeyBkYXR1bTogdGljayB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udFZhcmlhbnQ6IGlzUXVhbnRpdGF0aXZlID8gJ3RhYnVsYXItbnVtcycgOiAnbm9ybWFsJyxcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHRpY2tGb250U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgICAgICAgeyB5OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxnXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0aWNrIHt0aWNrQ2xhc3NfIHx8ICcnfVwiXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHt0aWNrLmR4ICtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdCArXG4gICAgICAgICAgICAgICAgICAgIChhbmNob3IgPT09ICdsZWZ0JyA/IDAgOiB3aWR0aCl9LHt0aWNrLnkgKyB0aWNrLmR5fSlcIj5cbiAgICAgICAgICAgICAgICB7I2lmIHRpY2tTaXplfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFt0aWNrTGluZVN0eWxlLCB0aWNrTGluZUNsYXNzXSA9IHJlc29sdmVTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXR1bTogdGljayB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB5OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17dGlja0xpbmVTdHlsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPXt0aWNrTGluZUNsYXNzfVxuICAgICAgICAgICAgICAgICAgICAgICAgeDI9e2FuY2hvciA9PT0gJ2xlZnQnID8gLXRpY2tTaXplIDogdGlja1NpemV9IC8+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7I2lmIHRleHR9XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kOnRoaXM9e3RpY2tUZXh0c1t0XX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPXtbdGV4dENsYXNzLCB7ICdpcy1sZWZ0JzogYW5jaG9yID09PSAnbGVmdCcgfV19XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17dGV4dFN0eWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgeD17KHRpY2tTaXplICsgdGlja1BhZGRpbmcpICogKGFuY2hvciA9PT0gJ2xlZnQnID8gLTEgOiAxKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWluYW50LWJhc2VsaW5lPXtMSU5FX0FOQ0hPUltsaW5lQW5jaG9yXX1cbiAgICAgICAgICAgICAgICAgICAgICAgID57QXJyYXkuaXNBcnJheSh0aWNrLnRleHQpID8gdGljay50ZXh0LmpvaW4oJyAnKSA6IHRpY2sudGV4dH08L3RleHQ+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG48L2c+XG5cbjxzdHlsZT5cbiAgICBsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiBjdXJyZW50Q29sb3I7XG4gICAgfVxuICAgIHRleHQge1xuICAgICAgICBmaWxsOiBjdXJyZW50Q29sb3I7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function BaseAxisY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BaseAxisY);
  append_styles($$anchor, $$css5);
  const $autoMarginLeft = () => (validate_store(autoMarginLeft, "autoMarginLeft"), store_get(autoMarginLeft, "$autoMarginLeft", $$stores));
  const $autoMarginRight = () => (validate_store(autoMarginRight, "autoMarginRight"), store_get(autoMarginRight, "$autoMarginRight", $$stores));
  const $autoMarginTop = () => (validate_store(autoMarginTop, "autoMarginTop"), store_get(autoMarginTop, "$autoMarginTop", $$stores));
  const [$$stores, $$cleanup] = setup_stores();
  let text2 = prop($$props, "text", 3, true), className = prop($$props, "class", 3, "axis-y");
  const LINE_ANCHOR = { top: "hanging", center: "middle", bottom: "auto" };
  const positionedTicks = tag(
    user_derived(() => {
      let tickObjects = $$props.ticks.map((tick, i) => {
        const datum = { [RAW_VALUE]: tick, [INDEX]: i };
        return {
          ...datum,
          hidden: false,
          dx: +resolveProp($$props.options.dx, datum, 0),
          dy: +resolveProp($$props.options.dy, datum, 0),
          y: $$props.scaleFn(tick) + (strict_equals($$props.scaleType, "band") ? $$props.scaleFn.bandwidth() * 0.5 : 0),
          text: $$props.tickFormat(tick, i, $$props.ticks),
          element: null
        };
      });
      if (text2()) {
        const T = tickObjects.length;
        for (let i = 0; i < T; i++) {
          let j = i;
          do {
            j--;
          } while (j >= 0 && tickObjects[j].hidden);
          if (j >= 0) {
            const tickLabelSpace = Math.abs(tickObjects[i].y - tickObjects[j].y);
            tickObjects[i].hidden = tickLabelSpace < 15;
          }
        }
      }
      return tickObjects;
    }),
    "positionedTicks"
  );
  let tickTexts = tag_proxy(proxy([]), "tickTexts");
  const isQuantitative = tag(user_derived(() => strict_equals($$props.scaleType, "point", false) && strict_equals($$props.scaleType, "band", false)), "isQuantitative");
  const id = randomId();
  const { autoMarginLeft, autoMarginRight, autoMarginTop } = getContext("svelteplot/autoMargins");
  user_effect(() => {
    untrack(() => [$autoMarginLeft(), $autoMarginRight()]);
    const outsideTextAnchor = strict_equals($$props.anchor, "left") ? "end" : "start";
    const maxLabelWidth = Math.ceil(max(get(positionedTicks).map((tick, i) => {
      if (strict_equals(resolveProp($$props.options.textAnchor, tick, outsideTextAnchor), outsideTextAnchor, false)) return 0;
      if (tick.hidden || !testFilter(tick, $$props.options)) return 0;
      if (tickTexts[i]) return tickTexts[i].getBoundingClientRect().width;
      return 0;
    }))) + Math.max(0, $$props.tickPadding + $$props.tickSize);
    if (!isNaN(maxLabelWidth)) {
      if (strict_equals($$props.anchor, "left") && strict_equals($autoMarginLeft().get(id), maxLabelWidth, false)) {
        $autoMarginLeft().set(id, maxLabelWidth);
      } else if (strict_equals($$props.anchor, "right") && strict_equals($autoMarginRight().get(id), maxLabelWidth, false)) {
        $autoMarginRight().set(id, maxLabelWidth);
      }
    }
  });
  user_effect(() => {
    untrack(() => [$autoMarginTop()]);
    if ($$props.title) {
      $autoMarginTop().set(id, 27);
    } else {
      $autoMarginTop().delete(id);
    }
  });
  user_effect(() => {
    return () => {
      if ($autoMarginLeft().has(id)) $autoMarginLeft().delete(id);
      if ($autoMarginRight().has(id)) $autoMarginRight().delete(id);
      if ($autoMarginTop().has(id)) $autoMarginTop().delete(id);
    };
  });
  var $$exports = { ...legacy_api() };
  var g = root3();
  validate_each_keys(() => get(positionedTicks), (tick) => tick[RAW_VALUE]);
  add_svelte_meta(
    () => each(g, 23, () => get(positionedTicks), (tick) => tick[RAW_VALUE], ($$anchor2, tick, t) => {
      var fragment = comment();
      var node = first_child(fragment);
      {
        var consequent_2 = ($$anchor3) => {
          const tickClass_ = tag(user_derived(() => resolveProp($$props.tickClass, get(tick))), "tickClass_");
          get(tickClass_);
          const computed_const = tag(
            user_derived(() => {
              const [textStyle, textClass] = resolveStyles(
                $$props.plot,
                { datum: get(tick) },
                {
                  fontVariant: get(isQuantitative) ? "tabular-nums" : "normal",
                  ...$$props.options,
                  fontSize: $$props.tickFontSize,
                  stroke: null
                },
                "fill",
                { y: true },
                true
              );
              return { textStyle, textClass };
            }),
            "[@const]"
          );
          get(computed_const);
          var g_1 = root_26();
          var node_1 = child(g_1);
          {
            var consequent = ($$anchor4) => {
              const computed_const_1 = tag(
                user_derived(() => {
                  const [tickLineStyle, tickLineClass] = resolveStyles($$props.plot, { datum: get(tick) }, $$props.options, "stroke", { y: true }, true);
                  return { tickLineStyle, tickLineClass };
                }),
                "[@const]"
              );
              get(computed_const_1);
              var line = root_32();
              template_effect(() => {
                set_style(line, get(computed_const_1).tickLineStyle);
                set_class(line, 0, clsx(get(computed_const_1).tickLineClass), "s-aQLKlrG7cGGX");
                set_attribute(line, "x2", strict_equals($$props.anchor, "left") ? -$$props.tickSize : $$props.tickSize);
              });
              append($$anchor4, line);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.tickSize) $$render(consequent);
              }),
              "if",
              BaseAxisY,
              180,
              16
            );
          }
          var node_2 = sibling(node_1);
          {
            var consequent_1 = ($$anchor4) => {
              var text_1 = root_42();
              var text_2 = child(text_1, true);
              reset(text_1);
              validate_binding("bind:this={tickTexts[t]}", [], () => tickTexts, () => get(t), 196, 24);
              bind_this(text_1, ($$value, t4) => tickTexts[t4] = $$value, (t4) => tickTexts?.[t4], () => [get(t)]);
              template_effect(
                ($0) => {
                  set_class(
                    text_1,
                    0,
                    clsx([
                      get(computed_const).textClass,
                      { "is-left": strict_equals($$props.anchor, "left") }
                    ]),
                    "s-aQLKlrG7cGGX"
                  );
                  set_style(text_1, get(computed_const).textStyle);
                  set_attribute(text_1, "x", ($$props.tickSize + $$props.tickPadding) * (strict_equals($$props.anchor, "left") ? -1 : 1));
                  set_attribute(text_1, "dominant-baseline", LINE_ANCHOR[$$props.lineAnchor]);
                  set_text(text_2, $0);
                },
                [
                  () => Array.isArray(get(tick).text) ? get(tick).text.join(" ") : get(tick).text
                ]
              );
              append($$anchor4, text_1);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (text2()) $$render(consequent_1);
              }),
              "if",
              BaseAxisY,
              194,
              16
            );
          }
          reset(g_1);
          template_effect(() => {
            set_class(g_1, 0, `tick ${(get(tickClass_) || "") ?? ""}`);
            set_attribute(g_1, "transform", `translate(${get(tick).dx + $$props.marginLeft + (strict_equals($$props.anchor, "left") ? 0 : $$props.width)},${get(tick).y + get(tick).dy})`);
          });
          append($$anchor3, g_1);
        };
        add_svelte_meta(
          () => if_block(node, ($$render) => {
            if (testFilter(get(tick), $$props.options) && !get(tick).hidden) $$render(consequent_2);
          }),
          "if",
          BaseAxisY,
          160,
          8
        );
      }
      append($$anchor2, fragment);
    }),
    "each",
    BaseAxisY,
    159,
    4
  );
  reset(g);
  template_effect(() => set_class(g, 0, clsx(className())));
  append($$anchor, g);
  var $$pop = pop($$exports);
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  BaseAxisY = hmr(BaseAxisY);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-aQLKlrG7cGGX");
    BaseAxisY[HMR].update(module.default);
  });
}
var BaseAxisY_default = BaseAxisY;

// node_modules/svelteplot/dist/marks/AxisY.svelte
AxisY[FILENAME] = "node_modules/svelteplot/dist/marks/AxisY.svelte";
var root_27 = add_locations(from_svg(`<text class="axis-y-title s-6WxmHkk60WpN" dominant-baseline="hanging"> </text>`), AxisY[FILENAME], [[201, 8]]);
var root_14 = add_locations(from_svg(`<!><!>`, 1), AxisY[FILENAME], []);
var $$css6 = {
  hash: "s-6WxmHkk60WpN",
  code: "\n    text.s-6WxmHkk60WpN {\n        fill: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXhpc1kuc3ZlbHRlIiwic291cmNlcyI6WyJBeGlzWS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBAY29tcG9uZW50XG4gICAgUmVuZGVycyBhIHZlcnRpY2FsIGF4aXMgd2l0aCBsYWJlbHMgYW5kIHRpY2sgbWFya3Ncbi0tPlxuPHNjcmlwdCBsYW5nPVwidHNcIiBnZW5lcmljcz1cIkRhdHVtIGV4dGVuZHMgUmF3VmFsdWVcIj5cbiAgICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgICBpbXBvcnQgQmFzZUF4aXNZIGZyb20gJy4vaGVscGVycy9CYXNlQXhpc1kuc3ZlbHRlJztcbiAgICBpbXBvcnQgTWFyayBmcm9tICcuLi9NYXJrLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IHR5cGUge1xuICAgICAgICBCYXNlTWFya1Byb3BzLFxuICAgICAgICBSYXdWYWx1ZSxcbiAgICAgICAgRmFjZXRDb250ZXh0LFxuICAgICAgICBDaGFubmVsTmFtZSxcbiAgICAgICAgQ29uc3RhbnRBY2Nlc3NvclxuICAgIH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuICAgIGltcG9ydCBhdXRvVGltZUZvcm1hdCBmcm9tICcuLi9oZWxwZXJzL2F1dG9UaW1lRm9ybWF0LmpzJztcbiAgICBpbXBvcnQgeyBhdXRvVGlja3MgfSBmcm9tICcuLi9oZWxwZXJzL2F1dG9UaWNrcy5qcyc7XG4gICAgaW1wb3J0IHsgcmVzb2x2ZVNjYWxlZFN0eWxlcyB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZS5qcyc7XG4gICAgaW1wb3J0IHsgZ2V0UGxvdERlZmF1bHRzIH0gZnJvbSAnLi4vaG9va3MvcGxvdERlZmF1bHRzLmpzJztcbiAgICBpbXBvcnQgeyBleHRlbnQgfSBmcm9tICdkMy1hcnJheSc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIGludGVyZmFjZSBBeGlzWU1hcmtQcm9wcyBleHRlbmRzIE9taXQ8XG4gICAgICAgIEJhc2VNYXJrUHJvcHM8RGF0dW0+LFxuICAgICAgICAnZmlsbE9wYWNpdHknIHwgJ3BhaW50T3JkZXInIHwgJ3RpdGxlJyB8ICdocmVmJyB8ICd0YXJnZXQnXG4gICAgPiB7XG4gICAgICAgIGRhdGE/OiBEYXR1bVtdO1xuICAgICAgICBhdXRvbWF0aWM/OiBib29sZWFuO1xuICAgICAgICB0aXRsZT86IHN0cmluZyB8IGZhbHNlIHwgbnVsbDtcbiAgICAgICAgYW5jaG9yPzogJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgICAgICAgZmFjZXRBbmNob3I/OiAnYXV0bycgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ2xlZnQtZW1wdHknIHwgJ3JpZ2h0LWVtcHR5JztcbiAgICAgICAgbGluZUFuY2hvcj86ICd0b3AnIHwgJ2NlbnRlcicgfCAnYm90dG9tJztcbiAgICAgICAgaW50ZXJ2YWw/OiBzdHJpbmcgfCBudW1iZXI7XG4gICAgICAgIGxhYmVsQW5jaG9yPzogJ2F1dG8nIHwgJ2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnO1xuICAgICAgICB0ZXh0QW5jaG9yPzogJ2F1dG8nIHwgJ3N0YXJ0JyB8ICdtaWRkbGUnIHwgJ2VuZCc7XG4gICAgICAgIHRpY2tTaXplPzogbnVtYmVyO1xuICAgICAgICB0aWNrRm9udFNpemU/OiBDb25zdGFudEFjY2Vzc29yPG51bWJlciwgRGF0dW0+O1xuICAgICAgICB0aXRsZUZvbnRTaXplPzogbnVtYmVyO1xuICAgICAgICB0aWNrUGFkZGluZz86IG51bWJlcjtcbiAgICAgICAgdGlja0Zvcm1hdD86XG4gICAgICAgICAgICB8ICdhdXRvJ1xuICAgICAgICAgICAgfCBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc1xuICAgICAgICAgICAgfCBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnNcbiAgICAgICAgICAgIHwgKChkOiBSYXdWYWx1ZSkgPT4gc3RyaW5nKTtcbiAgICAgICAgdGlja0NsYXNzPzogQ29uc3RhbnRBY2Nlc3NvcjxzdHJpbmcsIERhdHVtPjtcbiAgICAgICAgLyoqIHRpY2tzIGlzIGEgc2hvcnRoYW5kIGZvciBkZWZpbmluZyBkYXRhLCB0aWNrQ291bnQgb3IgaW50ZXJ2YWwgKi9cbiAgICAgICAgdGlja3M/OiBudW1iZXIgfCBzdHJpbmcgfCBEYXR1bVtdO1xuICAgICAgICAvKiogc2V0IHRvIGZhbHNlIG9yIG51bGwgdG8gZGlzYWJsZSB0aWNrIGxhYmVscyAqL1xuICAgICAgICB0ZXh0PzogYm9vbGVhbiB8IG51bGw7XG4gICAgICAgIC8qKiBhcHByb3hpbWF0ZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgZ2VuZXJhdGVkICovXG4gICAgICAgIHRpY2tDb3VudD86IG51bWJlcjtcbiAgICAgICAgLyoqIGFwcHJveGltYXRlIG51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiBnZW5lcmF0ZWQgdGlja3MgKi9cbiAgICAgICAgdGlja1NwYWNpbmc/OiBudW1iZXI7XG4gICAgfVxuXG4gICAgbGV0IG1hcmtQcm9wczogQXhpc1lNYXJrUHJvcHMgPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IERFRkFVTFRTOiBPbWl0PEF4aXNZTWFya1Byb3BzLCAnZGF0YScgfCBDaGFubmVsTmFtZT4gPSB7XG4gICAgICAgIHRpY2tTaXplOiA2LFxuICAgICAgICB0aWNrUGFkZGluZzogMyxcbiAgICAgICAgdGlja0ZvbnRTaXplOiAxMSxcbiAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICBhbmNob3I6ICdsZWZ0JyxcbiAgICAgICAgdGV4dEFuY2hvcjogJ2F1dG8nLFxuICAgICAgICAuLi5nZXRQbG90RGVmYXVsdHMoKS5heGlzLFxuICAgICAgICAuLi5nZXRQbG90RGVmYXVsdHMoKS5heGlzWVxuICAgIH07XG5cbiAgICBjb25zdCB7IHRpY2tzOiBtYWdpY1RpY2tzIH0gPSAkZGVyaXZlZCh7IC4uLkRFRkFVTFRTLCAuLi5tYXJrUHJvcHMgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIGF1dG9tYXRpYyA9IGZhbHNlLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgYW5jaG9yID0gJ2xlZnQnLFxuICAgICAgICBjbGFzczogY2xhc3NOYW1lLFxuICAgICAgICBmYWNldEFuY2hvciA9ICdhdXRvJyxcbiAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIGxpbmVBbmNob3IgPSAnY2VudGVyJyxcbiAgICAgICAgdGV4dEFuY2hvcixcbiAgICAgICAgdGlja1NpemUsXG4gICAgICAgIHRpY2tGb250U2l6ZSxcbiAgICAgICAgdGlja1BhZGRpbmcsXG4gICAgICAgIHRpY2tGb3JtYXQsXG4gICAgICAgIHRpY2tDbGFzcyxcbiAgICAgICAgdGlja0NvdW50LFxuICAgICAgICB0aWNrU3BhY2luZyxcbiAgICAgICAgdGV4dCA9IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9OiBBeGlzWU1hcmtQcm9wcyA9ICRkZXJpdmVkKHtcbiAgICAgICAgZGF0YTogQXJyYXkuaXNBcnJheShtYWdpY1RpY2tzKSA/IG1hZ2ljVGlja3MgOiBbXSxcbiAgICAgICAgdGlja0NvdW50OiB0eXBlb2YgbWFnaWNUaWNrcyA9PT0gJ251bWJlcicgPyBtYWdpY1RpY2tzIDogdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcnZhbDogdHlwZW9mIG1hZ2ljVGlja3MgPT09ICdzdHJpbmcnID8gbWFnaWNUaWNrcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgLi4uREVGQVVMVFMsXG4gICAgICAgIC4uLm1hcmtQcm9wc1xuICAgIH0pO1xuXG4gICAgY29uc3QgcGxvdCA9IHVzZVBsb3QoKTtcblxuICAgIGNvbnN0IGF1dG9UaWNrQ291bnQgPSAkZGVyaXZlZChcbiAgICAgICAgdGlja0NvdW50ICE9IG51bGxcbiAgICAgICAgICAgID8gdGlja0NvdW50XG4gICAgICAgICAgICA6IHRpY2tTcGFjaW5nICE9IG51bGxcbiAgICAgICAgICAgICAgPyBNYXRoLm1heCgzLCBNYXRoLnJvdW5kKHBsb3QuZmFjZXRIZWlnaHQgLyB0aWNrU3BhY2luZykpXG4gICAgICAgICAgICAgIDogTWF0aC5tYXgoMiwgTWF0aC5yb3VuZChwbG90LmZhY2V0SGVpZ2h0IC8gcGxvdC5vcHRpb25zLnkudGlja1NwYWNpbmcpKVxuICAgICk7XG5cbiAgICBjb25zdCB0aWNrczogUmF3VmFsdWVbXSA9ICRkZXJpdmVkKFxuICAgICAgICBkYXRhLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gLy8gdXNlIGN1c3RvbSB0aWNrIHZhbHVlcyBpZiB1c2VyIHBhc3NlZCBhbnkgYXMgcHJvcFxuICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICA6IC8vIHVzZSBjdXN0b20gc2NhbGUgdGljayB2YWx1ZXMgaWYgdXNlciBwYXNzZWQgYW55IGFzIHBsb3Qgc2NhbGUgb3B0aW9uXG4gICAgICAgICAgICAgIGF1dG9UaWNrcyhcbiAgICAgICAgICAgICAgICAgIHBsb3Quc2NhbGVzLnkudHlwZSxcbiAgICAgICAgICAgICAgICAgIHBsb3Qub3B0aW9ucy55LnRpY2tzLFxuICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgfHwgcGxvdC5vcHRpb25zLnkuaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICBwbG90LnNjYWxlcy55LmRvbWFpbixcbiAgICAgICAgICAgICAgICAgIHBsb3Quc2NhbGVzLnkuZm4sXG4gICAgICAgICAgICAgICAgICBhdXRvVGlja0NvdW50XG4gICAgICAgICAgICAgIClcbiAgICApO1xuXG4gICAgY29uc3QgdXNlQ29tcGFjdE5vdGF0aW9uID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZSA9XG4gICAgICAgICAgICBleHRlbnQocGxvdC5zY2FsZXMueS5kb21haW4pLmZpbHRlcihcbiAgICAgICAgICAgICAgICAoZCk6IGQgaXMgbnVtYmVyID0+IHR5cGVvZiBkID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoZClcbiAgICAgICAgICAgICkgPz8gW107XG5cbiAgICAgICAgaWYgKHJhbmdlWzBdID09PSB1bmRlZmluZWQgfHwgcmFuZ2VbMV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBjcm9zc2VzWmVybyA9IHJhbmdlWzBdIDw9IDAgJiYgcmFuZ2VbMV0gPj0gMDtcbiAgICAgICAgaWYgKGNyb3NzZXNaZXJvKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWFnbml0dWRlcyA9IHJhbmdlLm1hcCgoZCkgPT5cbiAgICAgICAgICAgIGQgPT09IDAgPyAtSW5maW5pdHkgOiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTWF0aC5hYnMoZCkpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWFnbml0dWRlc1swXSAhPT0gbWFnbml0dWRlc1sxXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRpY2tGbXQgPSAkZGVyaXZlZCh0aWNrRm9ybWF0IHx8IHBsb3Qub3B0aW9ucy55LnRpY2tGb3JtYXQpO1xuXG4gICAgY29uc3QgdXNlVGlja0Zvcm1hdCA9ICRkZXJpdmVkKFxuICAgICAgICB0eXBlb2YgdGlja0ZtdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB0aWNrRm10XG4gICAgICAgICAgICA6IHBsb3Quc2NhbGVzLnkudHlwZSA9PT0gJ2JhbmQnIHx8IHBsb3Quc2NhbGVzLnkudHlwZSA9PT0gJ3BvaW50J1xuICAgICAgICAgICAgICA/IChkKSA9PiBkXG4gICAgICAgICAgICAgIDogcGxvdC5zY2FsZXMueS50eXBlID09PSAndGltZSdcbiAgICAgICAgICAgICAgICA/IC8vIHRpbWUgc2NhbGVcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aWNrRm10ID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/IChkOiBEYXRlKSA9PiBJbnRsLkRhdGVUaW1lRm9ybWF0KHBsb3Qub3B0aW9ucy5sb2NhbGUsIHRpY2tGbXQpLmZvcm1hdChkKVxuICAgICAgICAgICAgICAgICAgICA6IGF1dG9UaW1lRm9ybWF0KHBsb3Quc2NhbGVzLnksIHBsb3QucGxvdFdpZHRoLCBwbG90Lm9wdGlvbnMubG9jYWxlKVxuICAgICAgICAgICAgICAgIDogLy8gbnVtZXJpYyBzY2FsZVxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHRpY2tGbXQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICA/IChkOiBudW1iZXIpID0+IEludGwuTnVtYmVyRm9ybWF0KHBsb3Qub3B0aW9ucy5sb2NhbGUsIHRpY2tGbXQpLmZvcm1hdChkKVxuICAgICAgICAgICAgICAgICAgOiAvLyBhdXRvXG4gICAgICAgICAgICAgICAgICAgIChkOiBSYXdWYWx1ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIEludGwuTnVtYmVyRm9ybWF0KHBsb3Qub3B0aW9ucy5sb2NhbGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgY29tcGFjdCBub3RhdGlvbiBpZiByYW5nZSBjb3ZlcnMgbXVsdGlwbGUgbWFnbml0dWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLih1c2VDb21wYWN0Tm90YXRpb24gPyB7IG5vdGF0aW9uOiAnY29tcGFjdCcgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ERUZBVUxUUy5udW1iZXJGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHBsb3Qub3B0aW9ucy55LnBlcmNlbnQgPyAncGVyY2VudCcgOiAnZGVjaW1hbCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZvcm1hdChkKVxuICAgICk7XG5cbiAgICBjb25zdCBvcHRpb25zTGFiZWwgPSAkZGVyaXZlZChwbG90Lm9wdGlvbnMueS5sYWJlbCk7XG5cbiAgICBjb25zdCB1c2VUaXRsZSA9ICRkZXJpdmVkKFxuICAgICAgICB0aXRsZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRpdGxlIHx8ICcnXG4gICAgICAgICAgICA6IG9wdGlvbnNMYWJlbCA9PT0gbnVsbFxuICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgOiBvcHRpb25zTGFiZWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9uc0xhYmVsXG4gICAgICAgICAgICAgICAgOiBwbG90LnNjYWxlcy55LmF1dG9UaXRsZVxuICAgICAgICAgICAgICAgICAgPyBgJHshcGxvdC5vcHRpb25zLnkucmV2ZXJzZSA/ICfihpEnIDogJ+KGkyd9ICR7cGxvdC5zY2FsZXMueS5hdXRvVGl0bGV9JHtwbG90Lm9wdGlvbnMueS5wZXJjZW50ID8gJyAoJSknIDogJyd9YFxuICAgICAgICAgICAgICAgICAgOiAnJ1xuICAgICk7XG5cbiAgICBjb25zdCB7IGdldEZhY2V0U3RhdGUgfSA9IGdldENvbnRleHQ8RmFjZXRDb250ZXh0Pignc3ZlbHRlcGxvdC9mYWNldCcpO1xuICAgIGNvbnN0IHsgbGVmdCwgbGVmdEVtcHR5LCByaWdodCwgcmlnaHRFbXB0eSwgdG9wIH0gPSAkZGVyaXZlZChnZXRGYWNldFN0YXRlKCkpO1xuXG4gICAgY29uc3QgdXNlRmFjZXRBbmNob3IgPSAkZGVyaXZlZChcbiAgICAgICAgZmFjZXRBbmNob3IgIT09ICdhdXRvJyA/IGZhY2V0QW5jaG9yIDogYW5jaG9yID09PSAnbGVmdCcgPyAnbGVmdC1lbXB0eScgOiAncmlnaHQtZW1wdHknXG4gICAgKTtcblxuICAgIGNvbnN0IHNob3dBeGlzID0gJGRlcml2ZWQoXG4gICAgICAgIHVzZUZhY2V0QW5jaG9yID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gbGVmdFxuICAgICAgICAgICAgOiB1c2VGYWNldEFuY2hvciA9PT0gJ3JpZ2h0J1xuICAgICAgICAgICAgICA/IHJpZ2h0XG4gICAgICAgICAgICAgIDogdXNlRmFjZXRBbmNob3IgPT09ICdsZWZ0LWVtcHR5J1xuICAgICAgICAgICAgICAgID8gbGVmdEVtcHR5XG4gICAgICAgICAgICAgICAgOiByaWdodEVtcHR5XG4gICAgKTtcbjwvc2NyaXB0PlxuXG48TWFya1xuICAgIHR5cGU9XCJheGlzWVwiXG4gICAgZGF0YT17ZGF0YS5sZW5ndGggPyBkYXRhLm1hcCgodGljaykgPT4gKHsgX195OiB0aWNrIH0pKSA6IFtdfVxuICAgIGNoYW5uZWxzPXtbJ3knXX1cbiAgICB7Li4ueyAuLi5vcHRpb25zLCB5OiAnX195JyB9fVxuICAgIHthdXRvbWF0aWN9PlxuICAgIHsjaWYgbGVmdCAmJiB0b3AgJiYgdXNlVGl0bGV9XG4gICAgICAgIDx0ZXh0XG4gICAgICAgICAgICBzdHlsZT17cmVzb2x2ZVNjYWxlZFN0eWxlcyhcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogb3B0aW9ucy50aXRsZUZvbnRTaXplID8/IDExLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnY3VycmVudENvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiBhbmNob3IgPT09ICdsZWZ0JyA/ICdzdGFydCcgOiAnZW5kJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgcGxvdCxcbiAgICAgICAgICAgICAgICAnZmlsbCdcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB4PXthbmNob3IgPT09ICdsZWZ0JyA/IDAgOiBwbG90LndpZHRofVxuICAgICAgICAgICAgeT17NX1cbiAgICAgICAgICAgIGNsYXNzPVwiYXhpcy15LXRpdGxlXCJcbiAgICAgICAgICAgIGRvbWluYW50LWJhc2VsaW5lPVwiaGFuZ2luZ1wiPnt1c2VUaXRsZX08L3RleHQ+XG4gICAgey9pZn1cbiAgICB7I2lmIHNob3dBeGlzfVxuICAgICAgICA8QmFzZUF4aXNZXG4gICAgICAgICAgICB7YW5jaG9yfVxuICAgICAgICAgICAge2NsYXNzTmFtZX1cbiAgICAgICAgICAgIHtsaW5lQW5jaG9yfVxuICAgICAgICAgICAgb3B0aW9ucz17e1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGV4dEFuY2hvcjpcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvciA9PSBudWxsIHx8IHRleHRBbmNob3IgPT09ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBhbmNob3IgPT09ICdsZWZ0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VuZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGV4dEFuY2hvclxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHtwbG90fVxuICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICB7dGlja0NsYXNzfVxuICAgICAgICAgICAge3RpY2tGb250U2l6ZX1cbiAgICAgICAgICAgIHt0aWNrUGFkZGluZ31cbiAgICAgICAgICAgIHt0aWNrc31cbiAgICAgICAgICAgIHt0aWNrU2l6ZX1cbiAgICAgICAgICAgIG1hcmdpbkxlZnQ9e3Bsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0fVxuICAgICAgICAgICAgc2NhbGVGbj17cGxvdC5zY2FsZXMueS5mbn1cbiAgICAgICAgICAgIHNjYWxlVHlwZT17cGxvdC5zY2FsZXMueS50eXBlfVxuICAgICAgICAgICAgdGlja0Zvcm1hdD17dXNlVGlja0Zvcm1hdH1cbiAgICAgICAgICAgIHRpdGxlPXt1c2VUaXRsZX1cbiAgICAgICAgICAgIHdpZHRoPXtwbG90LmZhY2V0V2lkdGh9IC8+XG4gICAgey9pZn1cbjwvTWFyaz5cblxuPHN0eWxlPlxuICAgIHRleHQge1xuICAgICAgICBmaWxsOiBjdXJyZW50Q29sb3I7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function AxisY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AxisY);
  append_styles($$anchor, $$css6);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    tickSize: 6,
    tickPadding: 3,
    tickFontSize: 11,
    opacity: 0.8,
    anchor: "left",
    textAnchor: "auto",
    ...getPlotDefaults().axis,
    ...getPlotDefaults().axisY
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), magicTicks = tag(user_derived(() => get($$d).ticks), "magicTicks");
  const $$d_1 = user_derived(() => ({
    data: Array.isArray(get(magicTicks)) ? get(magicTicks) : [],
    tickCount: strict_equals(typeof get(magicTicks), "number") ? get(magicTicks) : void 0,
    interval: strict_equals(typeof get(magicTicks), "string") ? get(magicTicks) : void 0,
    ...DEFAULTS,
    ...markProps
  })), data = tag(user_derived(() => get($$d_1).data), "data"), automatic = tag(user_derived(() => fallback(get($$d_1).automatic, false)), "automatic"), title = tag(user_derived(() => get($$d_1).title), "title"), anchor = tag(user_derived(() => fallback(get($$d_1).anchor, "left")), "anchor"), className = tag(user_derived(() => get($$d_1).class), "className"), facetAnchor = tag(user_derived(() => fallback(get($$d_1).facetAnchor, "auto")), "facetAnchor"), interval2 = tag(user_derived(() => get($$d_1).interval), "interval"), lineAnchor = tag(user_derived(() => fallback(get($$d_1).lineAnchor, "center")), "lineAnchor"), textAnchor = tag(user_derived(() => get($$d_1).textAnchor), "textAnchor"), tickSize = tag(user_derived(() => get($$d_1).tickSize), "tickSize"), tickFontSize = tag(user_derived(() => get($$d_1).tickFontSize), "tickFontSize"), tickPadding = tag(user_derived(() => get($$d_1).tickPadding), "tickPadding"), tickFormat2 = tag(user_derived(() => get($$d_1).tickFormat), "tickFormat"), tickClass = tag(user_derived(() => get($$d_1).tickClass), "tickClass"), tickCount = tag(user_derived(() => get($$d_1).tickCount), "tickCount"), tickSpacing = tag(user_derived(() => get($$d_1).tickSpacing), "tickSpacing"), text2 = tag(user_derived(() => fallback(get($$d_1).text, true)), "text"), options = tag(
    user_derived(() => exclude_from_object(get($$d_1), [
      "data",
      "automatic",
      "title",
      "anchor",
      "class",
      "facetAnchor",
      "interval",
      "lineAnchor",
      "textAnchor",
      "tickSize",
      "tickFontSize",
      "tickPadding",
      "tickFormat",
      "tickClass",
      "tickCount",
      "tickSpacing",
      "text"
    ])),
    "options"
  );
  const plot = usePlot();
  const autoTickCount = tag(
    user_derived(() => equals(get(tickCount), null, false) ? get(tickCount) : equals(get(tickSpacing), null, false) ? Math.max(3, Math.round(plot.facetHeight / get(tickSpacing))) : Math.max(2, Math.round(plot.facetHeight / plot.options.y.tickSpacing))),
    "autoTickCount"
  );
  const ticks2 = tag(
    user_derived(() => get(data).length > 0 ? get(
      // use custom tick values if user passed any as prop
      data
    ) : (
      // use custom scale tick values if user passed any as plot scale option
      autoTicks(plot.scales.y.type, plot.options.y.ticks, get(interval2) || plot.options.y.interval, plot.scales.y.domain, plot.scales.y.fn, get(autoTickCount))
    )),
    "ticks"
  );
  const useCompactNotation = tag(
    user_derived(() => {
      const range3 = extent(plot.scales.y.domain).filter((d) => strict_equals(typeof d, "number") && Number.isFinite(d)) ?? [];
      if (strict_equals(range3[0], void 0) || strict_equals(range3[1], void 0)) return false;
      const crossesZero = range3[0] <= 0 && range3[1] >= 0;
      if (crossesZero) return true;
      const magnitudes = range3.map((d) => strict_equals(d, 0) ? -Infinity : Math.floor(Math.log10(Math.abs(d))));
      return strict_equals(magnitudes[0], magnitudes[1], false);
    }),
    "useCompactNotation"
  );
  const tickFmt = tag(user_derived(() => get(tickFormat2) || plot.options.y.tickFormat), "tickFmt");
  const useTickFormat = tag(
    user_derived(() => strict_equals(typeof get(tickFmt), "function") ? get(tickFmt) : strict_equals(plot.scales.y.type, "band") || strict_equals(plot.scales.y.type, "point") ? (d) => d : strict_equals(plot.scales.y.type, "time") ? (
      // time scale
      strict_equals(typeof get(tickFmt), "object") ? (d) => Intl.DateTimeFormat(plot.options.locale, get(tickFmt)).format(d) : autoTimeFormat(plot.scales.y, plot.plotWidth, plot.options.locale)
    ) : (
      // numeric scale
      strict_equals(typeof get(tickFmt), "object") ? (d) => Intl.NumberFormat(plot.options.locale, get(tickFmt)).format(d) : (
        // auto
        (d) => Intl.NumberFormat(plot.options.locale, {
          // use compact notation if range covers multiple magnitudes
          ...get(useCompactNotation) ? { notation: "compact" } : {},
          ...DEFAULTS.numberFormat,
          style: plot.options.y.percent ? "percent" : "decimal"
        }).format(d)
      )
    )),
    "useTickFormat"
  );
  const optionsLabel = tag(user_derived(() => plot.options.y.label), "optionsLabel");
  const useTitle = tag(
    user_derived(() => strict_equals(get(title), void 0, false) ? get(title) || "" : strict_equals(get(optionsLabel), null) ? null : strict_equals(get(optionsLabel), void 0, false) ? get(optionsLabel) : plot.scales.y.autoTitle ? `${!plot.options.y.reverse ? "" : ""} ${plot.scales.y.autoTitle}${plot.options.y.percent ? " (%)" : ""}` : ""),
    "useTitle"
  );
  const { getFacetState } = getContext("svelteplot/facet");
  const $$d_2 = user_derived(getFacetState), left = tag(user_derived(() => get($$d_2).left), "left"), leftEmpty = tag(user_derived(() => get($$d_2).leftEmpty), "leftEmpty"), right = tag(user_derived(() => get($$d_2).right), "right"), rightEmpty = tag(user_derived(() => get($$d_2).rightEmpty), "rightEmpty"), top = tag(user_derived(() => get($$d_2).top), "top");
  const useFacetAnchor = tag(
    user_derived(() => strict_equals(get(facetAnchor), "auto", false) ? get(facetAnchor) : strict_equals(get(anchor), "left") ? "left-empty" : "right-empty"),
    "useFacetAnchor"
  );
  const showAxis = tag(
    user_derived(() => strict_equals(get(useFacetAnchor), "left") ? get(left) : strict_equals(get(useFacetAnchor), "right") ? get(right) : strict_equals(get(useFacetAnchor), "left-empty") ? get(leftEmpty) : get(rightEmpty)),
    "showAxis"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => get(data).length ? get(data).map((tick) => ({ __y: tick })) : []);
    let $1 = user_derived(() => ({ ...get(options), y: "__y" }));
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "axisY",
          get data() {
            return get($0);
          },
          channels: ["y"]
        },
        () => get($1),
        {
          get automatic() {
            return get(automatic);
          },
          children: wrap_snippet(AxisY, ($$anchor2, $$slotProps) => {
            var fragment_1 = root_14();
            var node_1 = first_child(fragment_1);
            {
              var consequent = ($$anchor3) => {
                var text_1 = root_27();
                set_attribute(text_1, "y", 5);
                var text_2 = child(text_1, true);
                reset(text_1);
                template_effect(
                  ($02) => {
                    set_style(text_1, $02);
                    set_attribute(text_1, "x", strict_equals(get(anchor), "left") ? 0 : plot.width);
                    set_text(text_2, get(useTitle));
                  },
                  [
                    () => resolveScaledStyles(
                      null,
                      {
                        opacity: 0.8,
                        ...get(options),
                        fontSize: get(options).titleFontSize ?? 11,
                        fill: "currentColor",
                        stroke: null,
                        textAnchor: strict_equals(get(anchor), "left") ? "start" : "end"
                      },
                      {},
                      plot,
                      "fill"
                    )
                  ]
                );
                append($$anchor3, text_1);
              };
              add_svelte_meta(
                () => if_block(node_1, ($$render) => {
                  if (get(left) && get(top) && get(useTitle)) $$render(consequent);
                }),
                "if",
                AxisY,
                200,
                4
              );
            }
            var node_2 = sibling(node_1);
            {
              var consequent_1 = ($$anchor3) => {
                var fragment_2 = comment();
                var node_3 = first_child(fragment_2);
                {
                  let $02 = user_derived(() => ({
                    ...get(options),
                    textAnchor: equals(get(textAnchor), null) || strict_equals(get(textAnchor), "auto") ? strict_equals(get(anchor), "left") ? "end" : "start" : get(textAnchor)
                  }));
                  add_svelte_meta(
                    () => BaseAxisY_default(node_3, {
                      get anchor() {
                        return get(anchor);
                      },
                      get className() {
                        return get(className);
                      },
                      get lineAnchor() {
                        return get(lineAnchor);
                      },
                      get options() {
                        return get($02);
                      },
                      get plot() {
                        return plot;
                      },
                      get text() {
                        return get(text2);
                      },
                      get tickClass() {
                        return get(tickClass);
                      },
                      get tickFontSize() {
                        return get(tickFontSize);
                      },
                      get tickPadding() {
                        return get(tickPadding);
                      },
                      get ticks() {
                        return get(ticks2);
                      },
                      get tickSize() {
                        return get(tickSize);
                      },
                      get marginLeft() {
                        return plot.options.marginLeft;
                      },
                      get scaleFn() {
                        return plot.scales.y.fn;
                      },
                      get scaleType() {
                        return plot.scales.y.type;
                      },
                      get tickFormat() {
                        return get(useTickFormat);
                      },
                      get title() {
                        return get(useTitle);
                      },
                      get width() {
                        return plot.facetWidth;
                      }
                    }),
                    "component",
                    AxisY,
                    222,
                    8,
                    { componentTag: "BaseAxisY" }
                  );
                }
                append($$anchor3, fragment_2);
              };
              add_svelte_meta(
                () => if_block(node_2, ($$render) => {
                  if (get(showAxis)) $$render(consequent_1);
                }),
                "if",
                AxisY,
                221,
                4
              );
            }
            append($$anchor2, fragment_1);
          }),
          $$slots: { default: true }
        }
      )),
      "component",
      AxisY,
      194,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  AxisY = hmr(AxisY);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-6WxmHkk60WpN");
    AxisY[HMR].update(module.default);
  });
}
var AxisY_default = AxisY;

// node_modules/svelteplot/dist/helpers/roundedRect.js
function roundedRect(x2, y2, width, height, borderRadius = {
  topLeft: 0,
  topRight: 0,
  bottomLeft: 0,
  bottomRight: 0
}) {
  const maxRadius = Math.min(width, height) / 2;
  const [tl, tr, bl, br] = (typeof borderRadius === "number" ? new Array(4).fill(borderRadius) : [
    borderRadius?.topLeft || 0,
    borderRadius?.topRight || 0,
    borderRadius?.bottomLeft || 0,
    borderRadius?.bottomRight || 0
  ]).map((r) => Math.min(r, maxRadius));
  return `
    M ${x2 + tl} ${y2}
    H ${x2 + width - tr}
    ${tr ? `A ${tr} ${tr} 0 0 1 ${x2 + width} ${y2 + tr}` : ""}
    V ${y2 + height - br}
    ${br ? `A ${br} ${br} 0 0 1 ${x2 + width - br} ${y2 + height}` : ""}
    H ${x2 + bl}
    ${bl ? `A ${bl} ${bl} 0 0 1 ${x2} ${y2 + height - bl}` : ""}
    V ${y2 + tl}
    ${tl ? `A ${tl} ${tl} 0 0 1 ${x2 + tl} ${y2}` : ""}
    Z
  `;
}

// node_modules/svelteplot/dist/marks/helpers/events.js
function clientToLayerCoordinates(event, plotBody) {
  if (!plotBody)
    return [0, 0];
  const plotBodyRect = plotBody.getBoundingClientRect();
  return [event.clientX - plotBodyRect.left, event.clientY - plotBodyRect.top];
}
function addEventHandlers({ options, datum, plot }) {
  const events = pick(options, [
    "onclick",
    "oncontextmenu",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onpointercancel",
    "onpointerdown",
    "onpointerenter",
    "onpointerleave",
    "onpointermove",
    "onpointerout",
    "onpointerover",
    "onpointerup",
    "ontouchcancel",
    "ontouchend",
    "ontouchmove",
    "onwheel"
  ]);
  return (node) => {
    const listeners = /* @__PURE__ */ new Map();
    for (const [eventName, eventHandler] of Object.entries(events)) {
      if (eventHandler) {
        const wrappedHandler = (origEvent) => {
          const { scales, body, options: plotOptions } = plot;
          if (origEvent instanceof MouseEvent || origEvent instanceof PointerEvent) {
            let facetEl = origEvent.target;
            while (facetEl && !facetEl.classList.contains("facet") && facetEl.parentElement) {
              if (!(facetEl.parentElement instanceof SVGElement))
                break;
              facetEl = facetEl.parentElement;
            }
            const facetRect = (facetEl?.firstElementChild ?? body).getBoundingClientRect();
            const relativeX = origEvent.clientX - facetRect.left + (plotOptions.marginLeft ?? 0);
            const relativeY = origEvent.clientY - facetRect.top + (plotOptions.marginTop ?? 0);
            if (scales.projection) {
              const [x2, y2] = scales.projection.invert([relativeX, relativeY]);
              origEvent.dataX = x2;
              origEvent.dataY = y2;
            } else {
              origEvent.dataX = invertScale(scales.x, relativeX);
              origEvent.dataY = invertScale(scales.y, relativeY);
            }
          }
          eventHandler(origEvent, datum.hasOwnProperty(RAW_VALUE) ? datum[RAW_VALUE] : datum, datum[INDEX]);
        };
        listeners.set(eventName, wrappedHandler);
        node.addEventListener(eventName.substring(2), wrappedHandler);
      }
    }
    if (events.onclick || events.onmousedown || events.onmouseup) {
      node.setAttribute("role", "button");
    }
    return () => {
      for (const [eventName, handler] of listeners.entries()) {
        node.removeEventListener(eventName.substring(2), handler);
      }
    };
  };
}
function invertScale(scale, position) {
  if (scale.type === "band") {
    const range3 = scale.fn.range();
    const domain = scale.fn.domain();
    const eachBand = scale.fn.step();
    const extent2 = range3[1] - range3[0];
    const posInRange = (position - range3[0]) * Math.sign(extent2);
    const index3 = Math.floor(posInRange / eachBand);
    return domain[index3];
  }
  return scale.fn.invert ? scale.fn.invert(position) : void 0;
}

// node_modules/svelteplot/dist/marks/helpers/Anchor.svelte
Anchor[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/Anchor.svelte";
function Anchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Anchor);
  let datum = prop($$props, "datum", 19, () => ({})), options = prop($$props, "options", 19, () => ({}));
  const href = tag(user_derived(() => resolveProp(options().href, datum(), null)), "href");
  const target = tag(user_derived(() => resolveProp(options().target, datum(), null)), "target");
  const rel = tag(user_derived(() => resolveProp(options().rel, datum(), null)), "rel");
  const type = tag(user_derived(() => resolveProp(options().type, datum(), null)), "type");
  const download = tag(user_derived(() => resolveProp(options().download, datum(), null)), "download");
  const dataAttributes = tag(user_derived(() => Object.fromEntries(Object.entries(options()).filter(([key2]) => key2.startsWith("data-sveltekit-")))), "dataAttributes");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        validate_void_dynamic_element(() => "a");
        validate_dynamic_element_tag(() => "a");
        element(
          node_1,
          () => "a",
          true,
          ($$element, $$anchor3) => {
            attribute_effect($$element, () => ({
              href: get(href),
              target: get(target),
              rel: get(rel),
              type: get(type),
              download: get(download),
              ...get(dataAttributes),
              "aria-label": "link",
              xmlns: "http://www.w3.org/2000/svg"
            }));
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Anchor, 47, 8);
            append($$anchor3, fragment_2);
          },
          void 0,
          [37, 4]
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Anchor, 50, 4);
      append($$anchor2, fragment_3);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(href)) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Anchor,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Anchor = hmr(Anchor);
  import.meta.hot.accept((module) => {
    Anchor[HMR].update(module.default);
  });
}
var Anchor_default = Anchor;

// node_modules/svelteplot/dist/marks/helpers/RectPath.svelte
RectPath[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/RectPath.svelte";
var root_28 = add_locations(from_svg(`<path></path>`), RectPath[FILENAME], [[109, 8]]);
var root_33 = add_locations(from_svg(`<rect></rect>`), RectPath[FILENAME], [[126, 8]]);
function RectPath($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RectPath);
  let className = prop($$props, "class", 3, null), useInsetAsFallbackVertically = prop($$props, "useInsetAsFallbackVertically", 3, true), useInsetAsFallbackHorizontally = prop($$props, "useInsetAsFallbackHorizontally", 3, true);
  const plot = usePlot();
  const inset = tag(user_derived(() => +resolveProp($$props.options.inset, $$props.datum?.datum, 0)), "inset");
  const insetLeft = tag(user_derived(() => +resolveProp($$props.options.insetLeft, $$props.datum?.datum, useInsetAsFallbackHorizontally() ? get(inset) : 0)), "insetLeft");
  const insetRight = tag(user_derived(() => +resolveProp($$props.options.insetRight, $$props.datum?.datum, useInsetAsFallbackHorizontally() ? get(inset) : 0)), "insetRight");
  const insetTop = tag(user_derived(() => +resolveProp($$props.options.insetTop, $$props.datum?.datum, useInsetAsFallbackVertically() ? get(inset) : 0)), "insetTop");
  const insetBottom = tag(user_derived(() => +resolveProp($$props.options.insetBottom, $$props.datum?.datum, useInsetAsFallbackVertically() ? get(inset) : 0)), "insetBottom");
  const borderRadius = tag(user_derived(() => resolveProp($$props.options.borderRadius, $$props.datum?.datum, 0)), "borderRadius");
  const hasBorderRadius = tag(user_derived(() => strict_equals(typeof get(borderRadius), "number") && get(borderRadius) > 0 || strict_equals(typeof get(borderRadius), "object") && Math.max(get(borderRadius).topRight ?? 0, get(borderRadius).bottomRight ?? 0, get(borderRadius).topLeft ?? 0, get(borderRadius).bottomLeft ?? 0) > 0), "hasBorderRadius");
  const $$d = user_derived(() => resolveStyles(
    plot,
    $$props.datum,
    $$props.options,
    !$$props.fallbackStyle ? $$props.options.stroke && !$$props.options.fill ? "stroke" : "fill" : $$props.fallbackStyle,
    $$props.usedScales
  )), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), style = tag(user_derived(() => get($$array)[0]), "style"), styleClass = tag(user_derived(() => get($$array)[1]), "styleClass");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => $$props.datum?.datum);
    add_svelte_meta(
      () => Anchor_default(node, {
        get options() {
          return $$props.options;
        },
        get datum() {
          return get($0);
        },
        children: wrap_snippet(RectPath, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor3) => {
              var path2 = root_28();
              attach(path2, () => addEventHandlers({ plot, options: $$props.options, datum: $$props.datum?.datum }));
              template_effect(
                ($02) => {
                  set_attribute(path2, "transform", `translate(${$$props.x + get(insetLeft)},${$$props.y + get(insetBottom)})`);
                  set_attribute(path2, "d", $02);
                  set_class(path2, 0, clsx([get(styleClass), className()]));
                  set_style(path2, get(style));
                },
                [
                  () => roundedRect(0, 0, $$props.width - get(insetLeft) - get(insetRight), $$props.height - get(insetTop) - get(insetBottom), get(borderRadius))
                ]
              );
              append($$anchor3, path2);
            };
            var alternate = ($$anchor3) => {
              var rect = root_33();
              attach(rect, () => addEventHandlers({ plot, options: $$props.options, datum: $$props.datum?.datum }));
              template_effect(() => {
                set_attribute(rect, "transform", `translate(${$$props.x + get(insetLeft)},${$$props.y + get(insetBottom)})`);
                set_attribute(rect, "width", $$props.width - get(insetLeft) - get(insetRight));
                set_attribute(rect, "height", $$props.height - get(insetTop) - get(insetBottom));
                set_class(rect, 0, clsx([get(styleClass), className()]));
                set_style(rect, get(style));
              });
              append($$anchor3, rect);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (get(hasBorderRadius)) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              RectPath,
              108,
              4
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      RectPath,
      107,
      0,
      { componentTag: "Anchor" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RectPath = hmr(RectPath);
  import.meta.hot.accept((module) => {
    RectPath[HMR].update(module.default);
  });
}
var RectPath_default = RectPath;

// node_modules/svelteplot/dist/marks/Frame.svelte
Frame[FILENAME] = "node_modules/svelteplot/dist/marks/Frame.svelte";
function Frame($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Frame);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    fill: void 0,
    class: "frame",
    stroke: void 0,
    fillOpacity: 1,
    strokeOpacity: 1,
    ...getPlotDefaults().frame
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), automatic = tag(user_derived(() => get($$d).automatic), "automatic"), className = tag(user_derived(() => get($$d).class), "className"), fill2 = tag(user_derived(() => get($$d).fill), "fill"), stroke = tag(user_derived(() => get($$d).stroke), "stroke"), opacity = tag(user_derived(() => get($$d).opacity), "opacity"), fillOpacity = tag(user_derived(() => get($$d).fillOpacity), "fillOpacity"), strokeOpacity = tag(user_derived(() => get($$d).strokeOpacity), "strokeOpacity"), options = tag(
    user_derived(() => exclude_from_object(get($$d), [
      "automatic",
      "class",
      "fill",
      "stroke",
      "opacity",
      "fillOpacity",
      "strokeOpacity"
    ])),
    "options"
  );
  const dx = tag(user_derived(() => resolveProp(get(options).dx, null, 0) || 0), "dx");
  const dy = tag(user_derived(() => resolveProp(get(options).dy, null, 0) || 0), "dy");
  const plot = usePlot();
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Frame, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({
          fill: get(fill2),
          stroke: get(stroke),
          fillOpacity: get(fillOpacity),
          strokeOpacity: get(strokeOpacity),
          opacity: get(opacity),
          datum: {},
          valid: true
        }));
        let $1 = user_derived(() => plot.options.marginLeft + get(dx));
        let $2 = user_derived(() => plot.options.marginTop + get(dy));
        let $3 = user_derived(() => equals(get(fill2), null) || strict_equals(get(fill2), "none") ? "stroke" : "fill");
        let $4 = user_derived(() => ({
          ...get(options),
          fill: get(fill2),
          stroke: get(stroke),
          fillOpacity: get(fillOpacity),
          opacity: get(opacity),
          strokeOpacity: get(strokeOpacity)
        }));
        add_svelte_meta(
          () => RectPath_default(node_1, {
            get class() {
              return get(className);
            },
            get datum() {
              return get($0);
            },
            get x() {
              return get($1);
            },
            get y() {
              return get($2);
            },
            get width() {
              return plot.facetWidth;
            },
            get height() {
              return plot.facetHeight;
            },
            get usedScales() {
              return usedScales();
            },
            get fallbackStyle() {
              return get($3);
            },
            get options() {
              return get($4);
            }
          }),
          "component",
          Frame,
          64,
          8,
          { componentTag: "RectPath" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, {
        type: "frame",
        get automatic() {
          return get(automatic);
        },
        children,
        $$slots: { default: true }
      }),
      "component",
      Frame,
      62,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Frame = hmr(Frame);
  import.meta.hot.accept((module) => {
    Frame[HMR].update(module.default);
  });
}
var Frame_default = Frame;

// node_modules/svelteplot/dist/marks/ColorLegend.svelte
ColorLegend[FILENAME] = "node_modules/svelteplot/dist/marks/ColorLegend.svelte";
var root_29 = add_locations(from_html(`<div class="title s-NHtpI6QzmIs6"><!></div>`), ColorLegend[FILENAME], [[45, 12]]);
var root_52 = add_locations(from_svg(`<path transform="translate(7.5,7.5)" class="s-NHtpI6QzmIs6"></path>`), ColorLegend[FILENAME], [[55, 32]]);
var root_62 = add_locations(from_svg(`<rect width="15" height="15"></rect>`), ColorLegend[FILENAME], [[65, 32]]);
var root_43 = add_locations(from_html(`<div class="item s-NHtpI6QzmIs6"><div class="swatch s-NHtpI6QzmIs6"><svg width="15" height="15"><!></svg></div> <span class="item-label s-NHtpI6QzmIs6"> </span></div>`), ColorLegend[FILENAME], [[51, 16, [[52, 20, [[53, 24]]], [71, 20]]]]);
var root_10 = add_locations(from_svg(`<stop></stop><stop></stop>`, 1), ColorLegend[FILENAME], [[103, 28], [106, 28]]);
var root_9 = add_locations(from_svg(`<defs><linearGradient x2="1"><stop offset="0%"></stop><!><stop offset="100%"></stop></linearGradient></defs><!><!>`, 1), ColorLegend[FILENAME], [[98, 16, [[99, 20, [[100, 24], [110, 24]]]]]]);
var root_132 = add_locations(from_svg(`<stop></stop>`), ColorLegend[FILENAME], [[134, 28]]);
var root_122 = add_locations(from_svg(`<defs><linearGradient x2="1"></linearGradient></defs><!><!>`, 1), ColorLegend[FILENAME], [[131, 16, [[132, 20]]]]);
var root_15 = add_locations(from_html(`<div><!> <!></div>`), ColorLegend[FILENAME], [[42, 4]]);
var $$css7 = {
  hash: "s-NHtpI6QzmIs6",
  code: "\n    .color-legend.s-NHtpI6QzmIs6 {\n        text-align: left;\n        font-size: 12px;\n        display: inline-block;\n        margin-right: 2em;\n    }\n    .title.s-NHtpI6QzmIs6 {\n        font-weight: 500;\n    }\n    .item.s-NHtpI6QzmIs6 {\n        margin: 0 1em 0.5ex 0;\n    }\n    path.s-NHtpI6QzmIs6 {\n        stroke-width: 1.5;\n    }\n    .item.s-NHtpI6QzmIs6,\n    .item-label.s-NHtpI6QzmIs6,\n    .swatch.s-NHtpI6QzmIs6 {\n        display: inline-flex;\n        align-items: center;\n        column-gap: 0.3rem;\n    }\n    .item-label.s-NHtpI6QzmIs6 {\n        vertical-align: super;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29sb3JMZWdlbmQuc3ZlbHRlIiwic291cmNlcyI6WyJDb2xvckxlZ2VuZC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbnRlcmZhY2UgQ29sb3JMZWdlbmRNYXJrUHJvcHMge1xuICAgICAgICBjbGFzczogc3RyaW5nIHwgbnVsbDtcbiAgICB9XG4gICAgaW1wb3J0IFBsb3QgZnJvbSAnLi4vUGxvdC5zdmVsdGUnO1xuICAgIGltcG9ydCBBeGlzWCBmcm9tICcuL0F4aXNYLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IEZyYW1lIGZyb20gJy4vRnJhbWUuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBzeW1ib2wgYXMgZDNTeW1ib2wgfSBmcm9tICdkMy1zaGFwZSc7XG4gICAgaW1wb3J0IHsgcmFuZ2UgYXMgZDNSYW5nZSwgZXh0ZW50IH0gZnJvbSAnZDMtYXJyYXknO1xuICAgIGltcG9ydCB7IG1heWJlU3ltYm9sIH0gZnJvbSAnLi4vaGVscGVycy9zeW1ib2xzLmpzJztcblxuICAgIGltcG9ydCB7IGdldFBsb3REZWZhdWx0cyB9IGZyb20gJy4uL2hvb2tzL3Bsb3REZWZhdWx0cyc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIGxldCB7IGNsYXNzOiBjbGFzc05hbWUgPSBudWxsIH06IENvbG9yTGVnZW5kTWFya1Byb3BzID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBwbG90ID0gdXNlUGxvdCgpO1xuXG4gICAgY29uc3QgREVGQVVMVFMgPSBnZXRQbG90RGVmYXVsdHMoKTtcblxuICAgIGNvbnN0IGxlZ2VuZFRpdGxlID0gJGRlcml2ZWQocGxvdC5vcHRpb25zLmNvbG9yLmxhYmVsKTtcbiAgICBjb25zdCBzY2FsZVR5cGUgPSAkZGVyaXZlZChwbG90LnNjYWxlcy5jb2xvci50eXBlKTtcbiAgICBjb25zdCB0aWNrRm9ybWF0ID0gJGRlcml2ZWQoXG4gICAgICAgIHR5cGVvZiBwbG90Lm9wdGlvbnMuY29sb3I/LnRpY2tGb3JtYXQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcGxvdC5vcHRpb25zLmNvbG9yLnRpY2tGb3JtYXRcbiAgICAgICAgICAgIDogSW50bC5OdW1iZXJGb3JtYXQoXG4gICAgICAgICAgICAgICAgICBwbG90Lm9wdGlvbnMubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgcGxvdC5vcHRpb25zLmNvbG9yLnRpY2tGb3JtYXQgfHwgeyAuLi5ERUZBVUxUUy5udW1iZXJGb3JtYXQsIG5vdGF0aW9uOiAnY29tcGFjdCcgfVxuICAgICAgICAgICAgICApLmZvcm1hdFxuICAgICk7XG4gICAgY29uc3QgcmFuZElkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWU2KS50b0ZpeGVkKDMyKTtcbjwvc2NyaXB0PlxuXG48IS0tXG4gICAgQGNvbXBvbmVudFxuICAgIFRoZSBDb2xvckxlZ2VuZCBpcyBhbiBIVE1MIG1hcmsgdGhhdCBjYW4gYmUgcGxhY2VkIGluIHRoZSBoZWFkZXIsIGZvb3RlciBhbmQgb3ZlcmxheVxuICAgIHNuaXBwZXRzLiBZb3UgY2FuIGFjdGl2YXRlIGFuIGltcGxpY2l0IENvbG9yTGVnZW5kIGFib3ZlIHRoZSBjaGFydCB1c2luZyB0aGUgZ2xvYmFsXG4gICAgY29sb3IubGVnZW5kIHNjYWxlIG9wdGlvbi5cbi0tPlxuXG57I2lmIHBsb3Quc2NhbGVzLmNvbG9yLm1hbnVhbEFjdGl2ZU1hcmtzID4gMH1cbiAgICA8ZGl2IGNsYXNzPVwiY29sb3ItbGVnZW5kIHtjbGFzc05hbWUgfHwgJyd9XCI+XG4gICAgICAgIHsjaWYgbGVnZW5kVGl0bGV9XG4gICAgICAgICAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdmVsdGUvbm8tYXQtaHRtbC10YWdzIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+e0BodG1sIGxlZ2VuZFRpdGxlfTwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnIHx8IHNjYWxlVHlwZSA9PT0gJ2NhdGVnb3JpY2FsJ31cbiAgICAgICAgICAgIHsjZWFjaCBwbG90LnNjYWxlcy5jb2xvci5kb21haW4gYXMgdmFsdWUgKHZhbHVlKX1cbiAgICAgICAgICAgICAgICB7QGNvbnN0IHN5bWJvbFYgPSBwbG90LnNjYWxlcy5zeW1ib2wuZm4odmFsdWUpfVxuICAgICAgICAgICAgICAgIHtAY29uc3Qgc3ltYm9sVHlwZSA9IG1heWJlU3ltYm9sKHN5bWJvbFYpfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2F0Y2hcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+eyNpZiBwbG90LmNvbG9yU3ltYm9sUmVkdW5kYW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDcuNSw3LjUpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOmZpbGw9e3Bsb3QuaGFzRmlsbGVkRG90TWFya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBsb3Quc2NhbGVzLmNvbG9yLmZuKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ25vbmUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6c3Ryb2tlPXtwbG90Lmhhc0ZpbGxlZERvdE1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwbG90LnNjYWxlcy5jb2xvci5mbih2YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPXtkM1N5bWJvbChzeW1ib2xUeXBlLCA0MCkoKX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTpmaWxsPXtwbG90LnNjYWxlcy5jb2xvci5mbih2YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjE1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIjE1XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfTwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpdGVtLWxhYmVsXCI+e3ZhbHVlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgezplbHNlIGlmIHNjYWxlVHlwZSA9PT0gJ3F1YW50aWxlJyB8fCBzY2FsZVR5cGUgPT09ICdxdWFudGl6ZScgfHwgc2NhbGVUeXBlID09PSAndGhyZXNob2xkJ31cbiAgICAgICAgICAgIHtAY29uc3QgZG9tYWluID0gZXh0ZW50KHBsb3Quc2NhbGVzLmNvbG9yLmZuLmRvbWFpbigpKX1cbiAgICAgICAgICAgIHtAY29uc3QgcmFuZ2UgPSBwbG90LnNjYWxlcy5jb2xvci5yYW5nZX1cbiAgICAgICAgICAgIHtAY29uc3QgdGlja0xhYmVscyA9XG4gICAgICAgICAgICAgICAgc2NhbGVUeXBlID09PSAncXVhbnRpbGUnXG4gICAgICAgICAgICAgICAgICAgID8gcGxvdC5zY2FsZXMuY29sb3IuZm4ucXVhbnRpbGVzKClcbiAgICAgICAgICAgICAgICAgICAgOiBzY2FsZVR5cGUgPT09ICdxdWFudGl6ZSdcbiAgICAgICAgICAgICAgICAgICAgICA/IHBsb3Quc2NhbGVzLmNvbG9yLmZuLnRocmVzaG9sZHMoKVxuICAgICAgICAgICAgICAgICAgICAgIDogcGxvdC5zY2FsZXMuY29sb3IuZm4uZG9tYWluKCl9XG4gICAgICAgICAgICB7QGNvbnN0IHRpY2tzID0gZDNSYW5nZShcbiAgICAgICAgICAgICAgICBkb21haW5bMF0sXG4gICAgICAgICAgICAgICAgZG9tYWluWzFdLFxuICAgICAgICAgICAgICAgIChkb21haW5bMV0gLSBkb21haW5bMF0pIC8gcmFuZ2UubGVuZ3RoXG4gICAgICAgICAgICApLnNsaWNlKDEpfVxuICAgICAgICAgICAgPFBsb3RcbiAgICAgICAgICAgICAgICBtYXhXaWR0aD1cIjI0MHB4XCJcbiAgICAgICAgICAgICAgICBtYXJnaW49ezF9XG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdD17MX1cbiAgICAgICAgICAgICAgICBtYXJnaW5SaWdodD17MX1cbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A9ezZ9XG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tPXsyMH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezM4fVxuICAgICAgICAgICAgICAgIGluc2V0PXswfVxuICAgICAgICAgICAgICAgIHg9e3sgZG9tYWluLCB0aWNrcyB9fT5cbiAgICAgICAgICAgICAgICA8ZGVmcz5cbiAgICAgICAgICAgICAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPVwiZ3JhZGllbnQte3JhbmRJZH1cIiB4Mj1cIjFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj17cmFuZ2VbMF19IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggdGlja3MgYXMgdCwgaSAoaSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge0Bjb25zdCBvZmZzZXQgPSAoMTAwICogKHQgLSBkb21haW5bMF0pKSAvIChkb21haW5bMV0gLSBkb21haW5bMF0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldD1cIntvZmZzZXQgLSAwLjAwMX0lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcC1jb2xvcj17cGxvdC5zY2FsZXMuY29sb3IuZm4odGlja0xhYmVsc1tpXSAtIDAuMSl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0PVwie29mZnNldH0lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcC1jb2xvcj17cGxvdC5zY2FsZXMuY29sb3IuZm4odGlja0xhYmVsc1tpXSl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj17cmFuZ2UuYXQoLTEpfSAvPlxuICAgICAgICAgICAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICAgICAgICAgIDwvZGVmcz5cbiAgICAgICAgICAgICAgICA8RnJhbWUgZHk9ey01fSBzdHJva2U9e251bGx9IGZpbGw9XCJ1cmwoI2dyYWRpZW50LXtyYW5kSWR9KVwiIC8+XG4gICAgICAgICAgICAgICAgPEF4aXNYIHRpY2tTaXplPXsxOH0gZHk9ey0xN30gdGlja0Zvcm1hdD17KGQsIGkpID0+IHRpY2tGb3JtYXQodGlja0xhYmVsc1tpXSl9IC8+XG4gICAgICAgICAgICA8L1Bsb3Q+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDwhLS0tIGNvbnRpbnVvdXMgLS0+XG4gICAgICAgICAgICB7QGNvbnN0IGRvbWFpbiA9IGV4dGVudChwbG90LnNjYWxlcy5jb2xvci5kb21haW4pfVxuICAgICAgICAgICAge0Bjb25zdCB0aWNrcyA9IGQzUmFuZ2UoZG9tYWluWzBdLCBkb21haW5bMV0sIChkb21haW5bMV0gLSBkb21haW5bMF0pIC8gNykuc2xpY2UoMSl9XG5cbiAgICAgICAgICAgIDxQbG90XG4gICAgICAgICAgICAgICAgbWF4V2lkdGg9XCIyNDBweFwiXG4gICAgICAgICAgICAgICAgbWFyZ2luPXsxfVxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ9ezEwfVxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0PXsxMH1cbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A9ezZ9XG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tPXsyMH1cbiAgICAgICAgICAgICAgICBoZWlnaHQ9ezM4fVxuICAgICAgICAgICAgICAgIGluc2V0PXswfVxuICAgICAgICAgICAgICAgIHg9e3sgZG9tYWluLCB0aWNrU3BhY2luZzogMzAsIHRpY2tGb3JtYXQgfX0+XG4gICAgICAgICAgICAgICAgPGRlZnM+XG4gICAgICAgICAgICAgICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD1cImdyYWRpZW50LXtyYW5kSWR9XCIgeDI9XCIxXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggdGlja3MgYXMgdCAodCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0PVwieygxMDAgKiAodCAtIGRvbWFpblswXSkpIC8gKGRvbWFpblsxXSAtIGRvbWFpblswXSl9JVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AtY29sb3I9e3Bsb3Quc2NhbGVzLmNvbG9yLmZuKHQpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICAgICAgICAgIDwvZGVmcz5cbiAgICAgICAgICAgICAgICA8RnJhbWUgZHk9ey01fSBzdHJva2U9e251bGx9IGZpbGw9XCJ1cmwoI2dyYWRpZW50LXtyYW5kSWR9KVwiIC8+XG4gICAgICAgICAgICAgICAgPEF4aXNYIHRpY2tTaXplPXsxOH0gZHk9ey0xN30gLz5cbiAgICAgICAgICAgIDwvUGxvdD5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAuY29sb3ItbGVnZW5kIHtcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMmVtO1xuICAgIH1cbiAgICAudGl0bGUge1xuICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgIH1cbiAgICAuaXRlbSB7XG4gICAgICAgIG1hcmdpbjogMCAxZW0gMC41ZXggMDtcbiAgICB9XG4gICAgcGF0aCB7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMS41O1xuICAgIH1cbiAgICAuaXRlbSxcbiAgICAuaXRlbS1sYWJlbCxcbiAgICAuc3dhdGNoIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGNvbHVtbi1nYXA6IDAuM3JlbTtcbiAgICB9XG4gICAgLml0ZW0tbGFiZWwge1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogc3VwZXI7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function ColorLegend($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ColorLegend);
  append_styles($$anchor, $$css7);
  let className = prop($$props, "class", 3, null);
  const plot = usePlot();
  const DEFAULTS = getPlotDefaults();
  const legendTitle = tag(user_derived(() => plot.options.color.label), "legendTitle");
  const scaleType = tag(user_derived(() => plot.scales.color.type), "scaleType");
  const tickFormat2 = tag(
    user_derived(() => strict_equals(typeof plot.options.color?.tickFormat, "function") ? plot.options.color.tickFormat : Intl.NumberFormat(plot.options.locale, plot.options.color.tickFormat || { ...DEFAULTS.numberFormat, notation: "compact" }).format),
    "tickFormat"
  );
  const randId = Math.round(Math.random() * 1e6).toFixed(32);
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_4 = ($$anchor2) => {
      var div = root_15();
      var node_1 = child(div);
      {
        var consequent = ($$anchor3) => {
          var div_1 = root_29();
          var node_2 = child(div_1);
          html(node_2, () => get(legendTitle));
          reset(div_1);
          append($$anchor3, div_1);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (get(legendTitle)) $$render(consequent);
          }),
          "if",
          ColorLegend,
          43,
          8
        );
      }
      var node_3 = sibling(node_1, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_4 = first_child(fragment_1);
          validate_each_keys(() => plot.scales.color.domain, (value) => value);
          add_svelte_meta(
            () => each(node_4, 16, () => plot.scales.color.domain, (value) => value, ($$anchor4, value) => {
              const symbolV = tag(user_derived(() => plot.scales.symbol.fn(value)), "symbolV");
              get(symbolV);
              const symbolType = tag(user_derived(() => maybeSymbol(get(symbolV))), "symbolType");
              get(symbolType);
              var div_2 = root_43();
              var div_3 = child(div_2);
              var svg = child(div_3);
              var node_5 = child(svg);
              {
                var consequent_1 = ($$anchor5) => {
                  var path2 = root_52();
                  let styles;
                  template_effect(
                    ($0, $1) => {
                      set_attribute(path2, "d", $0);
                      styles = set_style(path2, "", styles, $1);
                    },
                    [
                      () => Symbol2(get(symbolType), 40)(),
                      () => ({
                        fill: plot.hasFilledDotMarks ? plot.scales.color.fn(value) : "none",
                        stroke: plot.hasFilledDotMarks ? null : plot.scales.color.fn(value)
                      })
                    ]
                  );
                  append($$anchor5, path2);
                };
                var alternate = ($$anchor5) => {
                  var rect = root_62();
                  let styles_1;
                  template_effect(($0) => styles_1 = set_style(rect, "", styles_1, $0), [() => ({ fill: plot.scales.color.fn(value) })]);
                  append($$anchor5, rect);
                };
                add_svelte_meta(
                  () => if_block(node_5, ($$render) => {
                    if (plot.colorSymbolRedundant) $$render(consequent_1);
                    else $$render(alternate, false);
                  }),
                  "if",
                  ColorLegend,
                  54,
                  29
                );
              }
              reset(svg);
              reset(div_3);
              var span = sibling(div_3, 2);
              var text2 = child(span, true);
              reset(span);
              reset(div_2);
              template_effect(() => set_text(text2, value));
              append($$anchor4, div_2);
            }),
            "each",
            ColorLegend,
            48,
            12
          );
          append($$anchor3, fragment_1);
        };
        var alternate_2 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_6 = first_child(fragment_2);
          {
            var consequent_3 = ($$anchor4) => {
              const domain = tag(user_derived(() => extent(plot.scales.color.fn.domain())), "domain");
              get(domain);
              const range3 = tag(user_derived(() => plot.scales.color.range), "range");
              get(range3);
              const tickLabels = tag(
                user_derived(() => strict_equals(get(scaleType), "quantile") ? plot.scales.color.fn.quantiles() : strict_equals(get(scaleType), "quantize") ? plot.scales.color.fn.thresholds() : plot.scales.color.fn.domain()),
                "tickLabels"
              );
              get(tickLabels);
              const ticks2 = tag(user_derived(() => range(get(domain)[0], get(domain)[1], (get(domain)[1] - get(domain)[0]) / get(range3).length).slice(1)), "ticks");
              get(ticks2);
              var fragment_3 = comment();
              var node_7 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ domain: get(domain), ticks: get(ticks2) }));
                add_svelte_meta(
                  () => Plot_default2(node_7, {
                    maxWidth: "240px",
                    margin: 1,
                    marginLeft: 1,
                    marginRight: 1,
                    marginTop: 6,
                    marginBottom: 20,
                    height: 38,
                    inset: 0,
                    get x() {
                      return get($0);
                    },
                    children: wrap_snippet(ColorLegend, ($$anchor5, $$slotProps) => {
                      var fragment_4 = root_9();
                      var defs = first_child(fragment_4);
                      var linearGradient = child(defs);
                      var stop = child(linearGradient);
                      var node_8 = sibling(stop);
                      add_svelte_meta(
                        () => each(node_8, 17, () => get(ticks2), index, ($$anchor6, t, i) => {
                          const offset = tag(user_derived(() => 100 * (get(t) - get(domain)[0]) / (get(domain)[1] - get(domain)[0])), "offset");
                          get(offset);
                          var fragment_5 = root_10();
                          var stop_1 = first_child(fragment_5);
                          var stop_2 = sibling(stop_1);
                          template_effect(
                            ($02, $1) => {
                              set_attribute(stop_1, "offset", `${get(offset) - 1e-3}%`);
                              set_attribute(stop_1, "stop-color", $02);
                              set_attribute(stop_2, "offset", `${get(offset) ?? ""}%`);
                              set_attribute(stop_2, "stop-color", $1);
                            },
                            [
                              () => plot.scales.color.fn(get(tickLabels)[i] - 0.1),
                              () => plot.scales.color.fn(get(tickLabels)[i])
                            ]
                          );
                          append($$anchor6, fragment_5);
                        }),
                        "each",
                        ColorLegend,
                        101,
                        24
                      );
                      var stop_3 = sibling(node_8);
                      reset(linearGradient);
                      reset(defs);
                      var node_9 = sibling(defs);
                      add_svelte_meta(
                        () => Frame_default(node_9, {
                          dy: -5,
                          stroke: null,
                          get fill() {
                            return `url(#gradient-${randId ?? ""})`;
                          }
                        }),
                        "component",
                        ColorLegend,
                        113,
                        16,
                        { componentTag: "Frame" }
                      );
                      var node_10 = sibling(node_9);
                      add_svelte_meta(
                        () => AxisX_default(node_10, {
                          tickSize: 18,
                          dy: -17,
                          tickFormat: (d, i) => get(tickFormat2)(get(tickLabels)[i])
                        }),
                        "component",
                        ColorLegend,
                        114,
                        16,
                        { componentTag: "AxisX" }
                      );
                      template_effect(
                        ($02) => {
                          set_attribute(linearGradient, "id", `gradient-${randId ?? ""}`);
                          set_attribute(stop, "stop-color", get(range3)[0]);
                          set_attribute(stop_3, "stop-color", $02);
                        },
                        [() => get(range3).at(-1)]
                      );
                      append($$anchor5, fragment_4);
                    }),
                    $$slots: { default: true }
                  }),
                  "component",
                  ColorLegend,
                  88,
                  12,
                  { componentTag: "Plot" }
                );
              }
              append($$anchor4, fragment_3);
            };
            var alternate_1 = ($$anchor4) => {
              const domain = tag(user_derived(() => extent(plot.scales.color.domain)), "domain");
              get(domain);
              const ticks2 = tag(user_derived(() => range(get(domain)[0], get(domain)[1], (get(domain)[1] - get(domain)[0]) / 7).slice(1)), "ticks");
              get(ticks2);
              var fragment_6 = comment();
              var node_11 = first_child(fragment_6);
              {
                let $0 = user_derived(() => ({
                  domain: get(domain),
                  tickSpacing: 30,
                  tickFormat: get(tickFormat2)
                }));
                add_svelte_meta(
                  () => Plot_default2(node_11, {
                    maxWidth: "240px",
                    margin: 1,
                    marginLeft: 10,
                    marginRight: 10,
                    marginTop: 6,
                    marginBottom: 20,
                    height: 38,
                    inset: 0,
                    get x() {
                      return get($0);
                    },
                    children: wrap_snippet(ColorLegend, ($$anchor5, $$slotProps) => {
                      var fragment_7 = root_122();
                      var defs_1 = first_child(fragment_7);
                      var linearGradient_1 = child(defs_1);
                      validate_each_keys(() => get(ticks2), (t) => t);
                      add_svelte_meta(
                        () => each(linearGradient_1, 20, () => get(ticks2), (t) => t, ($$anchor6, t) => {
                          var stop_4 = root_132();
                          template_effect(
                            ($02) => {
                              set_attribute(stop_4, "offset", `${100 * (t - get(domain)[0]) / (get(domain)[1] - get(domain)[0])}%`);
                              set_attribute(stop_4, "stop-color", $02);
                            },
                            [() => plot.scales.color.fn(t)]
                          );
                          append($$anchor6, stop_4);
                        }),
                        "each",
                        ColorLegend,
                        133,
                        24
                      );
                      reset(linearGradient_1);
                      reset(defs_1);
                      var node_12 = sibling(defs_1);
                      add_svelte_meta(
                        () => Frame_default(node_12, {
                          dy: -5,
                          stroke: null,
                          get fill() {
                            return `url(#gradient-${randId ?? ""})`;
                          }
                        }),
                        "component",
                        ColorLegend,
                        140,
                        16,
                        { componentTag: "Frame" }
                      );
                      var node_13 = sibling(node_12);
                      add_svelte_meta(() => AxisX_default(node_13, { tickSize: 18, dy: -17 }), "component", ColorLegend, 141, 16, { componentTag: "AxisX" });
                      template_effect(() => set_attribute(linearGradient_1, "id", `gradient-${randId ?? ""}`));
                      append($$anchor5, fragment_7);
                    }),
                    $$slots: { default: true }
                  }),
                  "component",
                  ColorLegend,
                  121,
                  12,
                  { componentTag: "Plot" }
                );
              }
              append($$anchor4, fragment_6);
            };
            add_svelte_meta(
              () => if_block(
                node_6,
                ($$render) => {
                  if (strict_equals(get(scaleType), "quantile") || strict_equals(get(scaleType), "quantize") || strict_equals(get(scaleType), "threshold")) $$render(consequent_3);
                  else $$render(alternate_1, false);
                },
                true
              ),
              "if",
              ColorLegend,
              74,
              8
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_3, ($$render) => {
            if (strict_equals(get(scaleType), "ordinal") || strict_equals(get(scaleType), "categorical")) $$render(consequent_2);
            else $$render(alternate_2, false);
          }),
          "if",
          ColorLegend,
          47,
          8
        );
      }
      reset(div);
      template_effect(() => set_class(div, 1, `color-legend ${(className() || "") ?? ""}`, "s-NHtpI6QzmIs6"));
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (plot.scales.color.manualActiveMarks > 0) $$render(consequent_4);
      }),
      "if",
      ColorLegend,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  ColorLegend = hmr(ColorLegend);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-NHtpI6QzmIs6");
    ColorLegend[HMR].update(module.default);
  });
}
var ColorLegend_default = ColorLegend;

// node_modules/svelteplot/dist/marks/GridX.svelte
GridX[FILENAME] = "node_modules/svelteplot/dist/marks/GridX.svelte";
var root_34 = add_locations(from_svg(`<line></line>`), GridX[FILENAME], [[94, 20]]);
var root_16 = add_locations(from_svg(`<g class="grid-x"></g>`), GridX[FILENAME], [[70, 8]]);
var $$css8 = {
  hash: "s-Ca1Pc0w0Uz8q",
  code: "\n    line.s-Ca1Pc0w0Uz8q {\n        stroke: currentColor;\n        stroke-opacity: 0.2;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZFguc3ZlbHRlIiwic291cmNlcyI6WyJHcmlkWC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBAY29tcG9uZW50XG4gICAgUmVuZGVycyB2ZXJ0aWNhbCBncmlkbGluZXMgYXQgeC1heGlzIHRpY2sgcG9zaXRpb25zXG4tLT5cbjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJEYXR1bSA9IFJhd1ZhbHVlXCI+XG4gICAgaW50ZXJmYWNlIEdyaWRYTWFya1Byb3BzIGV4dGVuZHMgT21pdDxCYXNlTWFya1Byb3BzPERhdHVtPiwgJ2ZpbGwnIHwgJ2ZpbGxPcGFjaXR5Jz4ge1xuICAgICAgICBkYXRhPzogRGF0dW1bXTtcbiAgICAgICAgYXV0b21hdGljPzogYm9vbGVhbjtcbiAgICAgICAgeTE/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICB5Mj86IENoYW5uZWxBY2Nlc3NvcjxEYXR1bT47XG4gICAgfVxuICAgIGltcG9ydCBNYXJrIGZyb20gJy4uL01hcmsuc3ZlbHRlJztcbiAgICBpbXBvcnQgdHlwZSB7IEJhc2VNYXJrUHJvcHMsIFJhd1ZhbHVlLCBEYXRhUmVjb3JkLCBDaGFubmVsQWNjZXNzb3IgfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgcmVzb2x2ZUNoYW5uZWwsIHJlc29sdmVQcm9wLCByZXNvbHZlU3R5bGVzIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlLmpzJztcbiAgICBpbXBvcnQgeyBhdXRvVGlja3MgfSBmcm9tICcuLi9oZWxwZXJzL2F1dG9UaWNrcy5qcyc7XG4gICAgaW1wb3J0IHsgdGVzdEZpbHRlciB9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IFJBV19WQUxVRSB9IGZyb20gJy4uL3RyYW5zZm9ybXMvcmVjb3JkaXplLmpzJztcbiAgICBpbXBvcnQgaXNEYXRhUmVjb3JkIGZyb20gJy4uL2hlbHBlcnMvaXNEYXRhUmVjb3JkJztcbiAgICBpbXBvcnQgeyBJTkRFWCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG4gICAgaW1wb3J0IHsgZ2V0UGxvdERlZmF1bHRzIH0gZnJvbSAnLi4vaG9va3MvcGxvdERlZmF1bHRzLmpzJztcbiAgICBpbXBvcnQgeyB1c2VQbG90IH0gZnJvbSAnLi4vaG9va3MvdXNlUGxvdC5zdmVsdGUuanMnO1xuXG4gICAgbGV0IG1hcmtQcm9wczogR3JpZFhNYXJrUHJvcHMgPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IERFRkFVTFRTID0ge1xuICAgICAgICAuLi5nZXRQbG90RGVmYXVsdHMoKS5ncmlkLFxuICAgICAgICAuLi5nZXRQbG90RGVmYXVsdHMoKS5ncmlkWFxuICAgIH07XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGRhdGEgPSBbXSxcbiAgICAgICAgYXV0b21hdGljID0gZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9OiBHcmlkWE1hcmtQcm9wcyA9ICRkZXJpdmVkKHtcbiAgICAgICAgLi4uREVGQVVMVFMsXG4gICAgICAgIC4uLm1hcmtQcm9wc1xuICAgIH0pO1xuXG4gICAgY29uc3QgcGxvdCA9IHVzZVBsb3QoKTtcblxuICAgIGNvbnN0IGF1dG9UaWNrQ291bnQgPSAkZGVyaXZlZChcbiAgICAgICAgTWF0aC5tYXgoMywgTWF0aC5yb3VuZChwbG90LmZhY2V0V2lkdGggLyBwbG90Lm9wdGlvbnMueC50aWNrU3BhY2luZykpXG4gICAgKTtcblxuICAgIGNvbnN0IHRpY2tzOiBEYXRhUmVjb3JkW10gPSAkZGVyaXZlZChcbiAgICAgICAgKGRhdGEubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAvLyB1c2UgY3VzdG9tIHRpY2sgdmFsdWVzIGlmIHVzZXIgcGFzc2VkIGFueSBhcyBwcm9wXG4gICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIDogLy8gdXNlIGN1c3RvbSBzY2FsZSB0aWNrIHZhbHVlcyBpZiB1c2VyIHBhc3NlZCBhbnkgYXMgcGxvdCBzY2FsZSBvcHRpb25cbiAgICAgICAgICAgICAgYXV0b1RpY2tzKFxuICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueC50eXBlLFxuICAgICAgICAgICAgICAgICAgcGxvdC5vcHRpb25zLngudGlja3MsXG4gICAgICAgICAgICAgICAgICBwbG90Lm9wdGlvbnMueC5pbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgIHBsb3Quc2NhbGVzLnguZG9tYWluLFxuICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueC5mbixcbiAgICAgICAgICAgICAgICAgIGF1dG9UaWNrQ291bnRcbiAgICAgICAgICAgICAgKVxuICAgICAgICApLm1hcCgoZCwgaSkgPT5cbiAgICAgICAgICAgIGlzRGF0YVJlY29yZChkKSA/IHsgLi4uZCwgW0lOREVYXTogaSB9IDogeyBbUkFXX1ZBTFVFXTogZCwgW0lOREVYXTogaSB9XG4gICAgICAgICkgYXMgRGF0YVJlY29yZFtdXG4gICAgKTtcbjwvc2NyaXB0PlxuXG48TWFya1xuICAgIHR5cGU9XCJncmlkWFwiXG4gICAgZGF0YT17ZGF0YS5sZW5ndGggPyBkYXRhLm1hcCgodGljaykgPT4gKHsgW1JBV19WQUxVRV06IHRpY2sgfSkpIDogW119XG4gICAgY2hhbm5lbHM9e1sneTEnLCAneTInLCAneCcsICdzdHJva2UnLCAnc3Ryb2tlT3BhY2l0eSddfVxuICAgIHsuLi57IC4uLm9wdGlvbnMsIHg6IFJBV19WQUxVRSB9fVxuICAgIHthdXRvbWF0aWN9PlxuICAgIHsjc25pcHBldCBjaGlsZHJlbih7IHVzZWRTY2FsZXMgfSl9XG4gICAgICAgIDxnIGNsYXNzPVwiZ3JpZC14XCI+XG4gICAgICAgICAgICB7I2VhY2ggdGlja3MgYXMgdGljaywgdCAodCl9XG4gICAgICAgICAgICAgICAgeyNpZiB0ZXN0RmlsdGVyKHRpY2ssIG9wdGlvbnMpfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHggPVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueC5mbih0aWNrW1JBV19WQUxVRV0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwbG90LnNjYWxlcy54LnR5cGUgPT09ICdiYW5kJyA/IHBsb3Quc2NhbGVzLnguZm4uYmFuZHdpZHRoKCkgKiAwLjUgOiAwKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCB5MV8gPSByZXNvbHZlQ2hhbm5lbCgneTEnLCB0aWNrLCBvcHRpb25zKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCB5Ml8gPSByZXNvbHZlQ2hhbm5lbCgneTInLCB0aWNrLCBvcHRpb25zKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCBkeCA9ICtyZXNvbHZlUHJvcChvcHRpb25zPy5keCwgdGljaywgMCl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgZHkgPSArcmVzb2x2ZVByb3Aob3B0aW9ucz8uZHksIHRpY2ssIDApfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHkxID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMueTEgIT0gbnVsbCA/IHBsb3Quc2NhbGVzLnkuZm4oeTFfKSA6IHBsb3Qub3B0aW9ucy5tYXJnaW5Ub3B9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeTIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy55MiAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwbG90LnNjYWxlcy55LmZuKHkyXylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBsb3Qub3B0aW9ucy5tYXJnaW5Ub3AgKyBwbG90LmZhY2V0SGVpZ2h0fVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFtzdHlsZSwgc3R5bGVDbGFzc10gPSByZXNvbHZlU3R5bGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgZGF0dW06IHRpY2sgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRTY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz17c3R5bGVDbGFzc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7eCArIGR4fSx7ZHl9KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB7c3R5bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICB7eTF9XG4gICAgICAgICAgICAgICAgICAgICAgICB7eTJ9IC8+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9nPlxuICAgIHsvc25pcHBldH1cbjwvTWFyaz5cblxuPHN0eWxlPlxuICAgIGxpbmUge1xuICAgICAgICBzdHJva2U6IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgc3Ryb2tlLW9wYWNpdHk6IDAuMjtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function GridX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GridX);
  append_styles($$anchor, $$css8);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().grid, ...getPlotDefaults().gridX };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [], true)), "data"), automatic = tag(user_derived(() => fallback(get($$d).automatic, false)), "automatic"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "automatic"])), "options");
  const plot = usePlot();
  const autoTickCount = tag(user_derived(() => Math.max(3, Math.round(plot.facetWidth / plot.options.x.tickSpacing))), "autoTickCount");
  const ticks2 = tag(
    user_derived(() => (get(data).length > 0 ? get(
      // use custom tick values if user passed any as prop
      data
    ) : (
      // use custom scale tick values if user passed any as plot scale option
      autoTicks(plot.scales.x.type, plot.options.x.ticks, plot.options.x.interval, plot.scales.x.domain, plot.scales.x.fn, get(autoTickCount))
    )).map((d, i) => isDataRecord_default(d) ? { ...d, [INDEX]: i } : { [RAW_VALUE]: d, [INDEX]: i })),
    "ticks"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(GridX, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_16();
      add_svelte_meta(
        () => each(g, 21, () => get(ticks2), index, ($$anchor3, tick) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              const x2 = tag(user_derived(() => plot.scales.x.fn(get(tick)[RAW_VALUE]) + (strict_equals(plot.scales.x.type, "band") ? plot.scales.x.fn.bandwidth() * 0.5 : 0)), "x");
              get(x2);
              const y1_ = tag(user_derived(() => resolveChannel("y1", get(tick), get(options))), "y1_");
              get(y1_);
              const y2_ = tag(user_derived(() => resolveChannel("y2", get(tick), get(options))), "y2_");
              get(y2_);
              const dx = tag(user_derived(() => +resolveProp(get(options)?.dx, get(tick), 0)), "dx");
              get(dx);
              const dy = tag(user_derived(() => +resolveProp(get(options)?.dy, get(tick), 0)), "dy");
              get(dy);
              const y12 = tag(user_derived(() => equals(get(options).y1, null, false) ? plot.scales.y.fn(get(y1_)) : plot.options.marginTop), "y1");
              get(y12);
              const y2 = tag(
                user_derived(() => equals(get(options).y2, null, false) ? plot.scales.y.fn(get(y2_)) : plot.options.marginTop + plot.facetHeight),
                "y2"
              );
              get(y2);
              const computed_const = tag(
                user_derived(() => {
                  const [style, styleClass] = resolveStyles(plot, { datum: get(tick) }, get(options), "stroke", usedScales(), true);
                  return { style, styleClass };
                }),
                "[@const]"
              );
              get(computed_const);
              var line = root_34();
              template_effect(() => {
                set_class(line, 0, clsx(get(computed_const).styleClass), "s-Ca1Pc0w0Uz8q");
                set_attribute(line, "transform", `translate(${get(x2) + get(dx)},${get(dy) ?? ""})`);
                set_style(line, get(computed_const).style);
                set_attribute(line, "y1", get(y12));
                set_attribute(line, "y2", get(y2));
              });
              append($$anchor4, line);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (testFilter(get(tick), get(options))) $$render(consequent);
              }),
              "if",
              GridX,
              72,
              16
            );
          }
          append($$anchor3, fragment_1);
        }),
        "each",
        GridX,
        71,
        12
      );
      reset(g);
      append($$anchor2, g);
    });
    let $0 = user_derived(() => get(data).length ? get(data).map((tick) => ({ [RAW_VALUE]: tick })) : []);
    let $1 = user_derived(() => ({ ...get(options), x: RAW_VALUE }));
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "gridX",
          get data() {
            return get($0);
          },
          channels: ["y1", "y2", "x", "stroke", "strokeOpacity"]
        },
        () => get($1),
        {
          get automatic() {
            return get(automatic);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      GridX,
      63,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  GridX = hmr(GridX);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-Ca1Pc0w0Uz8q");
    GridX[HMR].update(module.default);
  });
}
var GridX_default = GridX;

// node_modules/svelteplot/dist/marks/GridY.svelte
GridY[FILENAME] = "node_modules/svelteplot/dist/marks/GridY.svelte";
var root_35 = add_locations(from_svg(`<line></line>`), GridY[FILENAME], [[89, 20]]);
var root_17 = add_locations(from_svg(`<g class="grid-y"></g>`), GridY[FILENAME], [[65, 8]]);
var $$css9 = {
  hash: "s-0C1IaAQ8FLMu",
  code: "\n    line.s-0C1IaAQ8FLMu {\n        stroke: currentColor;\n        stroke-opacity: 0.2;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZFkuc3ZlbHRlIiwic291cmNlcyI6WyJHcmlkWS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBAY29tcG9uZW50XG4gICAgUmVuZGVycyBob3Jpem9udGFsIGdyaWRsaW5lcyBhdCB5LWF4aXMgdGljayBwb3NpdGlvbnNcbi0tPlxuPHNjcmlwdCBsYW5nPVwidHNcIiBnZW5lcmljcz1cIkRhdHVtID0gUmF3VmFsdWVcIj5cbiAgICBpbnRlcmZhY2UgR3JpZFlNYXJrUHJvcHMgZXh0ZW5kcyBPbWl0PEJhc2VNYXJrUHJvcHM8RGF0dW0+LCAnZmlsbCcgfCAnZmlsbE9wYWNpdHknPiB7XG4gICAgICAgIGRhdGE/OiBEYXR1bVtdO1xuICAgICAgICBhdXRvbWF0aWM/OiBib29sZWFuO1xuICAgICAgICB4MT86IENoYW5uZWxBY2Nlc3NvcjxEYXR1bT47XG4gICAgICAgIHgyPzogQ2hhbm5lbEFjY2Vzc29yPERhdHVtPjtcbiAgICB9XG4gICAgaW1wb3J0IE1hcmsgZnJvbSAnLi4vTWFyay5zdmVsdGUnO1xuICAgIGltcG9ydCB0eXBlIHsgQmFzZU1hcmtQcm9wcywgUmF3VmFsdWUsIENoYW5uZWxBY2Nlc3NvciB9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbiAgICBpbXBvcnQgeyByZXNvbHZlQ2hhbm5lbCwgcmVzb2x2ZVByb3AsIHJlc29sdmVTdHlsZXMgfSBmcm9tICcuLi9oZWxwZXJzL3Jlc29sdmUuanMnO1xuICAgIGltcG9ydCB7IGF1dG9UaWNrcyB9IGZyb20gJy4uL2hlbHBlcnMvYXV0b1RpY2tzLmpzJztcbiAgICBpbXBvcnQgeyB0ZXN0RmlsdGVyIH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgUkFXX1ZBTFVFIH0gZnJvbSAnLi4vdHJhbnNmb3Jtcy9yZWNvcmRpemUuanMnO1xuICAgIGltcG9ydCB7IGdldFBsb3REZWZhdWx0cyB9IGZyb20gJy4uL2hvb2tzL3Bsb3REZWZhdWx0cy5qcyc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIGxldCBtYXJrUHJvcHM6IEdyaWRZTWFya1Byb3BzID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgICAgLi4uZ2V0UGxvdERlZmF1bHRzKCkuZ3JpZCxcbiAgICAgICAgLi4uZ2V0UGxvdERlZmF1bHRzKCkuZ3JpZFlcbiAgICB9O1xuXG4gICAgY29uc3Qge1xuICAgICAgICBkYXRhID0gW10sXG4gICAgICAgIGF1dG9tYXRpYyA9IGZhbHNlLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfTogR3JpZFlNYXJrUHJvcHMgPSAkZGVyaXZlZCh7XG4gICAgICAgIC4uLkRFRkFVTFRTLFxuICAgICAgICAuLi5tYXJrUHJvcHNcbiAgICB9KTtcblxuICAgIGNvbnN0IHBsb3QgPSB1c2VQbG90KCk7XG5cbiAgICBjb25zdCBhdXRvVGlja0NvdW50ID0gJGRlcml2ZWQoXG4gICAgICAgIE1hdGgubWF4KDIsIE1hdGgucm91bmQocGxvdC5mYWNldEhlaWdodCAvIHBsb3Qub3B0aW9ucy55LnRpY2tTcGFjaW5nKSlcbiAgICApO1xuXG4gICAgY29uc3QgdGlja3M6IFJhd1ZhbHVlW10gPSAkZGVyaXZlZChcbiAgICAgICAgZGF0YS5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IC8vIHVzZSBjdXN0b20gdGljayB2YWx1ZXMgaWYgdXNlciBwYXNzZWQgYW55IGFzIHByb3BcbiAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgOiAvLyB1c2UgY3VzdG9tIHNjYWxlIHRpY2sgdmFsdWVzIGlmIHVzZXIgcGFzc2VkIGFueSBhcyBwbG90IHNjYWxlIG9wdGlvblxuICAgICAgICAgICAgICBhdXRvVGlja3MoXG4gICAgICAgICAgICAgICAgICBwbG90LnNjYWxlcy55LnR5cGUsXG4gICAgICAgICAgICAgICAgICBwbG90Lm9wdGlvbnMueS50aWNrcyxcbiAgICAgICAgICAgICAgICAgIHBsb3Qub3B0aW9ucy55LmludGVydmFsLFxuICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueS5kb21haW4sXG4gICAgICAgICAgICAgICAgICBwbG90LnNjYWxlcy55LmZuLFxuICAgICAgICAgICAgICAgICAgYXV0b1RpY2tDb3VudFxuICAgICAgICAgICAgICApXG4gICAgKTtcbjwvc2NyaXB0PlxuXG48TWFya1xuICAgIHR5cGU9XCJncmlkWVwiXG4gICAgZGF0YT17ZGF0YS5sZW5ndGggPyBkYXRhLm1hcCgodGljaykgPT4gKHsgW1JBV19WQUxVRV06IHRpY2sgfSkpIDogW119XG4gICAgY2hhbm5lbHM9e1sneDEnLCAneDInLCAneScsICdzdHJva2UnLCAnc3Ryb2tlT3BhY2l0eSddfVxuICAgIHsuLi57IC4uLm9wdGlvbnMsIHk6IFJBV19WQUxVRSB9fVxuICAgIHthdXRvbWF0aWN9PlxuICAgIHsjc25pcHBldCBjaGlsZHJlbih7IHVzZWRTY2FsZXMgfSl9XG4gICAgICAgIDxnIGNsYXNzPVwiZ3JpZC15XCI+XG4gICAgICAgICAgICB7I2VhY2ggdGlja3MgYXMgdGljaywgdCAodCl9XG4gICAgICAgICAgICAgICAgeyNpZiB0ZXN0RmlsdGVyKHRpY2ssIG9wdGlvbnMpfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxvdC5zY2FsZXMueS5mbih0aWNrKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocGxvdC5zY2FsZXMueS50eXBlID09PSAnYmFuZCcgPyBwbG90LnNjYWxlcy55LmZuLmJhbmR3aWR0aCgpICogMC41IDogMCl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeDFfID0gcmVzb2x2ZUNoYW5uZWwoJ3gxJywgdGljaywgb3B0aW9ucyl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeDJfID0gcmVzb2x2ZUNoYW5uZWwoJ3gyJywgdGljaywgb3B0aW9ucyl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeDEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy54MSAhPSBudWxsID8gcGxvdC5zY2FsZXMueC5mbih4MV8pIDogcGxvdC5vcHRpb25zLm1hcmdpbkxlZnR9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeDIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy54MiAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwbG90LnNjYWxlcy54LmZuKHgyXylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0ICsgcGxvdC5mYWNldFdpZHRofVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IGR4ID0gK3Jlc29sdmVQcm9wKG9wdGlvbnM/LmR4LCB0aWNrLCAwKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCBkeSA9ICtyZXNvbHZlUHJvcChvcHRpb25zPy5keSwgdGljaywgMCl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgW3N0eWxlLCBzdHlsZUNsYXNzXSA9IHJlc29sdmVTdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBwbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBkYXR1bTogeyBbUkFXX1ZBTFVFXTogdGljayB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkU2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAge3N0eWxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9e3N0eWxlQ2xhc3N9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoe2R4fSx7eSArIGR5fSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAge3gxfVxuICAgICAgICAgICAgICAgICAgICAgICAge3gyfSAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZz5cbiAgICB7L3NuaXBwZXR9XG48L01hcms+XG5cbjxzdHlsZT5cbiAgICBsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiBjdXJyZW50Q29sb3I7XG4gICAgICAgIHN0cm9rZS1vcGFjaXR5OiAwLjI7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function GridY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GridY);
  append_styles($$anchor, $$css9);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().grid, ...getPlotDefaults().gridY };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [], true)), "data"), automatic = tag(user_derived(() => fallback(get($$d).automatic, false)), "automatic"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "automatic"])), "options");
  const plot = usePlot();
  const autoTickCount = tag(user_derived(() => Math.max(2, Math.round(plot.facetHeight / plot.options.y.tickSpacing))), "autoTickCount");
  const ticks2 = tag(
    user_derived(() => get(data).length > 0 ? get(
      // use custom tick values if user passed any as prop
      data
    ) : (
      // use custom scale tick values if user passed any as plot scale option
      autoTicks(plot.scales.y.type, plot.options.y.ticks, plot.options.y.interval, plot.scales.y.domain, plot.scales.y.fn, get(autoTickCount))
    )),
    "ticks"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(GridY, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_17();
      add_svelte_meta(
        () => each(g, 21, () => get(ticks2), index, ($$anchor3, tick) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              const y2 = tag(user_derived(() => plot.scales.y.fn(get(tick)) + (strict_equals(plot.scales.y.type, "band") ? plot.scales.y.fn.bandwidth() * 0.5 : 0)), "y");
              get(y2);
              const x1_ = tag(user_derived(() => resolveChannel("x1", get(tick), get(options))), "x1_");
              get(x1_);
              const x2_ = tag(user_derived(() => resolveChannel("x2", get(tick), get(options))), "x2_");
              get(x2_);
              const x12 = tag(
                user_derived(() => equals(get(options).x1, null, false) ? plot.scales.x.fn(get(x1_)) : plot.options.marginLeft),
                "x1"
              );
              get(x12);
              const x2 = tag(
                user_derived(() => equals(get(options).x2, null, false) ? plot.scales.x.fn(get(x2_)) : plot.options.marginLeft + plot.facetWidth),
                "x2"
              );
              get(x2);
              const dx = tag(user_derived(() => +resolveProp(get(options)?.dx, get(tick), 0)), "dx");
              get(dx);
              const dy = tag(user_derived(() => +resolveProp(get(options)?.dy, get(tick), 0)), "dy");
              get(dy);
              const computed_const = tag(
                user_derived(() => {
                  const [style, styleClass] = resolveStyles(plot, { datum: { [RAW_VALUE]: get(tick) } }, get(options), "stroke", usedScales(), true);
                  return { style, styleClass };
                }),
                "[@const]"
              );
              get(computed_const);
              var line = root_35();
              template_effect(() => {
                set_style(line, get(computed_const).style);
                set_class(line, 0, clsx(get(computed_const).styleClass), "s-0C1IaAQ8FLMu");
                set_attribute(line, "transform", `translate(${get(dx) ?? ""},${get(y2) + get(dy)})`);
                set_attribute(line, "x1", get(x12));
                set_attribute(line, "x2", get(x2));
              });
              append($$anchor4, line);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (testFilter(get(tick), get(options))) $$render(consequent);
              }),
              "if",
              GridY,
              67,
              16
            );
          }
          append($$anchor3, fragment_1);
        }),
        "each",
        GridY,
        66,
        12
      );
      reset(g);
      append($$anchor2, g);
    });
    let $0 = user_derived(() => get(data).length ? get(data).map((tick) => ({ [RAW_VALUE]: tick })) : []);
    let $1 = user_derived(() => ({ ...get(options), y: RAW_VALUE }));
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "gridY",
          get data() {
            return get($0);
          },
          channels: ["x1", "x2", "y", "stroke", "strokeOpacity"]
        },
        () => get($1),
        {
          get automatic() {
            return get(automatic);
          },
          children,
          $$slots: { default: true }
        }
      )),
      "component",
      GridY,
      58,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  GridY = hmr(GridY);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-0C1IaAQ8FLMu");
    GridY[HMR].update(module.default);
  });
}
var GridY_default = GridY;

// node_modules/svelteplot/dist/marks/SymbolLegend.svelte
SymbolLegend[FILENAME] = "node_modules/svelteplot/dist/marks/SymbolLegend.svelte";
var root_210 = add_locations(from_html(`<div class="item s-luiyUXAfvzwg"><div class="swatch s-luiyUXAfvzwg"><svg width="15" height="15"><path transform="translate(7.5,7.5)" class="s-luiyUXAfvzwg"></path></svg></div> <span class="item-label s-luiyUXAfvzwg"> </span></div>`), SymbolLegend[FILENAME], [[26, 12, [[27, 16, [[28, 20, [[29, 24]]]]], [36, 16]]]]);
var root_18 = add_locations(from_html(`<div class="symbol-legend s-luiyUXAfvzwg"></div>`), SymbolLegend[FILENAME], [[19, 4]]);
var $$css10 = {
  hash: "s-luiyUXAfvzwg",
  code: "\n    .symbol-legend.s-luiyUXAfvzwg {\n        text-align: left;\n        font-size: 12px;\n        display: inline-block;\n        margin-right: 2em;\n    }\n    .item.s-luiyUXAfvzwg {\n        margin: 0 1em 0.5ex 0;\n    }\n    path.s-luiyUXAfvzwg {\n        stroke-width: 1.5;\n    }\n    .item.s-luiyUXAfvzwg,\n    .item-label.s-luiyUXAfvzwg,\n    .swatch.s-luiyUXAfvzwg {\n        display: inline-block;\n    }\n    .item-label.s-luiyUXAfvzwg {\n        vertical-align: text-bottom;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ltYm9sTGVnZW5kLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU3ltYm9sTGVnZW5kLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICAgIGltcG9ydCB7IHN5bWJvbCBhcyBkM1N5bWJvbCB9IGZyb20gJ2QzLXNoYXBlJztcbiAgICBpbXBvcnQgeyBtYXliZVN5bWJvbCB9IGZyb20gJy4uL2hlbHBlcnMvc3ltYm9scy5qcyc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIGNvbnN0IHBsb3QgPSB1c2VQbG90KCk7XG5cbiAgICAvLyBUT0RPOiBhbGxvdyBzdHlsaW5nIG9mIGxlZ2VuZFxuPC9zY3JpcHQ+XG5cbjwhLS1cbiAgICBAY29tcG9uZW50XG4gICAgVGhlIFN5bWJvbExlZ2VuZCBpcyBhbiBIVE1MIG1hcmsgdGhhdCBjYW4gYmUgcGxhY2VkIGluIHRoZSBoZWFkZXIsIGZvb3RlciBhbmQgb3ZlcmxheVxuICAgIHNuaXBwZXRzLiBZb3UgY2FuIGFjdGl2YXRlIGFuIGltcGxpY2l0IFN5bWJvbExlZ2VuZCBhYm92ZSB0aGUgY2hhcnQgdXNpbmcgdGhlIGdsb2JhbFxuICAgIHN5bWJvbC5sZWdlbmQgc2NhbGUgb3B0aW9uLlxuLS0+XG5cbnsjaWYgcGxvdC5zY2FsZXMuY29sb3IubWFudWFsQWN0aXZlTWFya3MgPiAwfVxuICAgIDxkaXYgY2xhc3M9XCJzeW1ib2wtbGVnZW5kXCI+XG4gICAgICAgIHsjZWFjaCBwbG90LnNjYWxlcy5jb2xvci5kb21haW4gYXMgdmFsdWUgKHZhbHVlKX1cbiAgICAgICAgICAgIHtAY29uc3Qgc3ltYm9sViA9IHBsb3Quc2NhbGVzLnN5bWJvbC5mbih2YWx1ZSl9XG4gICAgICAgICAgICB7QGNvbnN0IHN5bWJvbFR5cGUgPSBtYXliZVN5bWJvbChzeW1ib2xWKX1cbiAgICAgICAgICAgIHtAY29uc3QgY29sb3IgPSBwbG90LmNvbG9yU3ltYm9sUmVkdW5kYW50XG4gICAgICAgICAgICAgICAgPyBwbG90LnNjYWxlcy5jb2xvci5mbih2YWx1ZSlcbiAgICAgICAgICAgICAgICA6ICdjdXJyZW50Q29sb3InfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW1cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3dhdGNoXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE1XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg3LjUsNy41KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ZmlsbD17cGxvdC5oYXNGaWxsZWREb3RNYXJrcyA/IGNvbG9yIDogJ25vbmUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOnN0cm9rZT17cGxvdC5oYXNGaWxsZWREb3RNYXJrcyA/IG51bGwgOiBjb2xvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPXtkM1N5bWJvbChzeW1ib2xUeXBlLCA0MCkoKX0gLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpdGVtLWxhYmVsXCI+e3ZhbHVlfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgLnN5bWJvbC1sZWdlbmQge1xuICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAyZW07XG4gICAgfVxuICAgIC5pdGVtIHtcbiAgICAgICAgbWFyZ2luOiAwIDFlbSAwLjVleCAwO1xuICAgIH1cbiAgICBwYXRoIHtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAxLjU7XG4gICAgfVxuICAgIC5pdGVtLFxuICAgIC5pdGVtLWxhYmVsLFxuICAgIC5zd2F0Y2gge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgfVxuICAgIC5pdGVtLWxhYmVsIHtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHRleHQtYm90dG9tO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function SymbolLegend($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SymbolLegend);
  append_styles($$anchor, $$css10);
  const plot = usePlot();
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_18();
      validate_each_keys(() => plot.scales.color.domain, (value) => value);
      add_svelte_meta(
        () => each(div, 20, () => plot.scales.color.domain, (value) => value, ($$anchor3, value) => {
          const symbolV = tag(user_derived(() => plot.scales.symbol.fn(value)), "symbolV");
          get(symbolV);
          const symbolType = tag(user_derived(() => maybeSymbol(get(symbolV))), "symbolType");
          get(symbolType);
          const color2 = tag(user_derived(() => plot.colorSymbolRedundant ? plot.scales.color.fn(value) : "currentColor"), "color");
          get(color2);
          var div_1 = root_210();
          var div_2 = child(div_1);
          var svg = child(div_2);
          var path2 = child(svg);
          let styles;
          reset(svg);
          reset(div_2);
          var span = sibling(div_2, 2);
          var text2 = child(span, true);
          reset(span);
          reset(div_1);
          template_effect(
            ($0) => {
              set_attribute(path2, "d", $0);
              styles = set_style(path2, "", styles, {
                fill: plot.hasFilledDotMarks ? get(color2) : "none",
                stroke: plot.hasFilledDotMarks ? null : get(color2)
              });
              set_text(text2, value);
            },
            [() => Symbol2(get(symbolType), 40)()]
          );
          append($$anchor3, div_1);
        }),
        "each",
        SymbolLegend,
        20,
        8
      );
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (plot.scales.color.manualActiveMarks > 0) $$render(consequent);
      }),
      "if",
      SymbolLegend,
      18,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  SymbolLegend = hmr(SymbolLegend);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-luiyUXAfvzwg");
    SymbolLegend[HMR].update(module.default);
  });
}
var SymbolLegend_default = SymbolLegend;

// node_modules/svelteplot/dist/core/FacetAxes.svelte
FacetAxes[FILENAME] = "node_modules/svelteplot/dist/core/FacetAxes.svelte";
var root_19 = add_locations(from_svg(`<g><!></g>`), FacetAxes[FILENAME], [[39, 4]]);
var root_211 = add_locations(from_svg(`<g><!></g>`), FacetAxes[FILENAME], [[61, 4]]);
var root4 = add_locations(from_svg(`<!><!>`, 1), FacetAxes[FILENAME], []);
function FacetAxes($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, FacetAxes);
  const { getPlotState } = getContext("svelteplot");
  const plot = tag(user_derived(getPlotState), "plot");
  const useFacetX = tag(user_derived(() => get(plot).scales.fx.domain.length > 0), "useFacetX");
  const useFacetY = tag(user_derived(() => get(plot).scales.fy.domain.length > 0), "useFacetY");
  const fxValues = tag(user_derived(() => get(useFacetX) ? get(plot).scales.fx.domain : [true]), "fxValues");
  const fyValues = tag(user_derived(() => get(useFacetY) ? get(plot).scales.fy.domain : [true]), "fyValues");
  const facetXScale = tag(user_derived(() => band().paddingInner(get(plot).options.fx?.paddingInner ?? get(plot).options.fx?.padding ?? 0.1).domain(get(fxValues)).rangeRound([0, get(plot).plotWidth])), "facetXScale");
  const facetYScale = tag(user_derived(() => band().paddingInner(get(plot).options.fy?.paddingInner ?? get(plot).options.fy?.padding ?? 0.1).domain(get(fyValues)).rangeRound([0, get(plot).plotHeight])), "facetYScale");
  var $$exports = { ...legacy_api() };
  var fragment = root4();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var g = root_19();
      var node_1 = child(g);
      {
        let $0 = user_derived(() => get(plot).options.fx.tickFormat || ((d) => d));
        let $1 = user_derived(() => strict_equals(get(plot).options.x.axis, get(plot).options.fx.axis) || strict_equals(get(plot).options.x.axis, "both") ? 25 : 5);
        let $2 = user_derived(() => get(plot).options.fx.axisOptions || {});
        add_svelte_meta(
          () => BaseAxisX_default(node_1, spread_props(
            {
              class: "facet-axis-x",
              get scaleFn() {
                return get(facetXScale);
              },
              scaleType: "band",
              get ticks() {
                return get(fxValues);
              },
              get tickFormat() {
                return get($0);
              },
              tickFontSize: 11,
              tickSize: 0,
              get tickPadding() {
                return get($1);
              },
              get anchor() {
                return get(plot).options.fx.axis;
              },
              get options() {
                return get($2);
              }
            },
            () => get(plot).options.fx.axisProps || {},
            {
              get height() {
                return get(plot).plotHeight;
              },
              get marginTop() {
                return get(plot).options.marginTop;
              },
              get plot() {
                return get(plot);
              }
            }
          )),
          "component",
          FacetAxes,
          40,
          8,
          { componentTag: "BaseAxisX" }
        );
      }
      reset(g);
      template_effect(() => set_attribute(g, "transform", `translate(${get(plot).options.marginLeft ?? ""}, 0)`));
      append($$anchor2, g);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(fxValues).length > 1 && get(plot).options.fx.axis) $$render(consequent);
      }),
      "if",
      FacetAxes,
      38,
      0
    );
  }
  var node_2 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      var g_1 = root_211();
      var node_3 = child(g_1);
      {
        let $0 = user_derived(() => get(plot).options.fy.tickFormat || ((d) => d));
        let $1 = user_derived(() => get(plot).options.fy.axisOptions || {});
        add_svelte_meta(
          () => BaseAxisY_default(node_3, spread_props(
            {
              class: "facet-axis-y",
              get scaleFn() {
                return get(facetYScale);
              },
              scaleType: "band",
              get ticks() {
                return get(fyValues);
              },
              get tickFormat() {
                return get($0);
              },
              tickFontSize: 11,
              tickSize: 0,
              tickPadding: 5,
              get anchor() {
                return get(plot).options.fy.axis;
              },
              lineAnchor: "center",
              get options() {
                return get($1);
              }
            },
            () => get(plot).options.fy.axisProps || {},
            {
              get width() {
                return get(plot).plotWidth;
              },
              get marginLeft() {
                return get(plot).options.marginLeft;
              },
              get plot() {
                return get(plot);
              }
            }
          )),
          "component",
          FacetAxes,
          62,
          8,
          { componentTag: "BaseAxisY" }
        );
      }
      reset(g_1);
      template_effect(() => set_attribute(g_1, "transform", `translate(0, ${get(plot).options.marginTop ?? ""})`));
      append($$anchor2, g_1);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if (get(fyValues).length > 1 && get(plot).options.fy.axis) $$render(consequent_1);
      }),
      "if",
      FacetAxes,
      60,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  FacetAxes = hmr(FacetAxes);
  import.meta.hot.accept((module) => {
    FacetAxes[HMR].update(module.default);
  });
}
var FacetAxes_default = FacetAxes;

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
function cividis_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c2 = cubehelix();
function rainbow_default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c2.h = 360 * t - 100;
  c2.s = 1.5 - 1.5 * ts;
  c2.l = 0.8 - 0.9 * ts;
  return c2 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c3 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;
function sinebow_default(t) {
  var x2;
  t = (0.5 - t) * Math.PI;
  c3.r = 255 * (x2 = Math.sin(t)) * x2;
  c3.g = 255 * (x2 = Math.sin(t + pi_1_3)) * x2;
  c3.b = 255 * (x2 = Math.sin(t + pi_2_3)) * x2;
  return c3 + "";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range3) {
  var n = range3.length;
  return function(t) {
    return range3[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/svelteplot/dist/helpers/colors.js
var schemeObservable10 = [
  "#4269d0",
  "#efb118",
  "#ff725c",
  "#6cc5b0",
  "#3ca951",
  "#ff8ab7",
  "#a463f2",
  "#97bbf5",
  "#9c6b4e",
  "#9498a0"
];
var categoricalSchemes = /* @__PURE__ */ new Map([
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["observable10", schemeObservable10],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default]
]);
function isCategoricalScheme(scheme28) {
  return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
}
var ordinalSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["grays", scheme92(scheme24, Greys_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default2)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function isOrdinalScheme(scheme28) {
  return ordinalSchemes.has(`${scheme28}`.toLowerCase());
}
function scheme92(scheme28, interpolate) {
  return (n) => {
    if (n === 1)
      return [scheme28[3][1]];
    if (n === 2)
      return [scheme28[3][1], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme112(scheme28, interpolate) {
  return (n) => {
    if (n === 2)
      return [scheme28[3][0], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme11r(scheme28, interpolate) {
  return (n) => {
    if (n === 2)
      return [scheme28[3][2], scheme28[3][0]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();
  };
}
function schemei(interpolate) {
  return (n) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
}
function schemeicyclical(interpolate) {
  return (n) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s2 = `${scheme28}`.toLowerCase();
  const match = ordinalSchemes.get(s2);
  if (!match)
    throw new Error(`unknown ordinal scheme: ${s2}`);
  return match;
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t) => RdBu_default(1 - t)],
  ["buylrd", (t) => RdYlBu_default(1 - t)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["grays", Greys_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default2],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function isQuantitativeScheme(scheme28) {
  return quantitativeSchemes.has(String(scheme28).toLowerCase());
}
function quantitativeScheme(scheme28) {
  const s2 = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s2))
    throw new Error(`unknown quantitative scheme: ${s2}`);
  return quantitativeSchemes.get(s2);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}

// node_modules/svelteplot/dist/helpers/callWithProps.js
function callWithProps_default(d3func, args = [], props = {}) {
  const res = d3func(...args);
  const resWithKeys = res;
  for (const [key2, val] of Object.entries(props)) {
    const setter = resWithKeys[key2];
    if (typeof setter !== "function")
      throw new Error(`function ${key2} does not exist`);
    setter(val);
  }
  return res;
}

// node_modules/svelteplot/dist/helpers/getLogTicks.js
function getLogTicks(domain, count2 = 6) {
  const inverted = domain[0] < 0 && domain[1] < 0;
  if (inverted)
    domain = [domain[0] * -1, domain[1] * -1];
  const reversed = domain[1] < domain[0];
  if (reversed)
    domain = domain.slice(0).reverse();
  if (domain[0] < 0 || domain[1] < 0)
    return [];
  if (domain[0] === 0)
    return ticks(domain[0], domain[1], count2 - 2);
  let mult = 1;
  count2 += 2;
  let candidates = getTickCandidates(domain, mult);
  if (candidates[0].num > count2) {
    while (candidates[0].num > count2) {
      mult *= 10;
      candidates = getTickCandidates(domain, mult);
    }
  } else if (candidates[candidates.length - 1].num < count2) {
    const ticksList2 = ticks(domain[0], domain[1], count2 - 2);
    if (reversed)
      ticksList2.reverse();
    return ticksList2;
  }
  count2 -= 2;
  const ticksList = candidates.map((d) => ({
    ...d,
    ticks: d.ticks.filter((t) => t >= domain[0] && t <= domain[1])
  })).map((d) => ({ ...d, diff: Math.abs(d.ticks.length - count2) })).sort((a2, b) => a2.diff - b.diff)[0].ticks;
  if (reversed)
    ticksList.reverse();
  if (inverted)
    return ticksList.map((t) => t * -1);
  return ticksList;
}
var logSeries = [[10], [5, 4, 5], [3, 10 / 3], [2, 2.5, 2], [1.5, 2, 5 / 3, 2]];
function getTickCandidates(domain, mult = 1) {
  return logSeries.map((factors) => {
    let i = Math.pow(10, Math.floor(Math.log10(domain[0])));
    let f = 0;
    const ticks2 = [i];
    while (i < domain[1] && ticks2.length < 50) {
      i *= factors[f] * mult;
      ticks2.push(i);
      f = (f + 1) % factors.length;
    }
    return { ticks: ticks2, num: ticks2.length };
  });
}

// node_modules/svelteplot/dist/helpers/autoScales.js
var Scales = {
  point,
  band,
  linear: linear2,
  time,
  sqrt,
  pow,
  log,
  symlog,
  ordinal,
  sequential,
  diverging
};
var SequentialScales = {
  linear: sequential,
  log: sequentialLog,
  symlog: sequentialSymlog,
  pow: sequentialPow,
  sqrt: sequentialSqrt,
  "quantile-cont": sequentialQuantile
};
var DivergingScales = {
  diverging,
  "diverging-log": divergingLog,
  "diverging-symlog": divergingSymlog,
  "diverging-pow": divergingPow,
  "diverging-sqrt": divergingSqrt
};
var ThresholdScales = {
  // custom thresholds
  threshold,
  // quantile scales
  quantize,
  quantile: quantile2
};
function autoScale({ name, type, domain, scaleOptions, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults }) {
  let fn;
  let range3;
  range3 = scaleOptions?.range || getScaleRange(name, scaleOptions, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks);
  if (scaleOptions.reverse)
    range3.reverse();
  const niceTickCount = name === "x" || name === "y" ? Math.round(Math.abs(range3[0] - range3[1]) / scaleOptions.tickSpacing) : void 0;
  const scaleProps = {
    domain,
    range: range3,
    ...(type === "linear" || type === "log") && scaleOptions.nice ? {
      nice: scaleOptions.nice ? niceTickCount : true
    } : {},
    ...type === "linear" ? {
      clamp: scaleOptions.clamp,
      ...scaleOptions.round ? { interpolate: round_default } : {}
    } : {},
    ...type === "log" ? {
      base: scaleOptions.base || 10
    } : {},
    ...type === "symlog" ? {
      constant: scaleOptions.constant || 1
    } : {},
    ...type === "band" || type === "point" ? {
      align: scaleOptions.align,
      ...type === "point" ? {
        // point scales don't have paddingInner/Outer, only padding
        padding: maybeNumber(coalesce(scaleOptions.padding, plotOptions.padding, 0.15))
      } : {
        //   padding: maybeNumber(coalesce(scaleOptions.padding, plotOptions.padding, 0.15)),
        paddingInner: maybeNumber(coalesce(scaleOptions.paddingInner, scaleOptions.padding, plotOptions.padding, 0.15)),
        paddingOuter: maybeNumber(coalesce(scaleOptions.paddingOuter, scaleOptions.padding, plotOptions.padding, 0.15))
      }
    } : {}
  };
  fn = callWithProps_default(Scales[type], [], scaleProps);
  if (type === "band" || type === "point") {
    fn.ticks = () => domain;
  }
  if (type === "log") {
    fn.ticks = (count2) => getLogTicks(domain, count2);
  } else if (type === "symlog") {
    const maxabs = Math.max(Math.abs(domain[0]), Math.abs(domain[1]));
    fn.ticks = (count2) => {
      const ticks2 = getLogTicks([scaleProps.constant + 1, maxabs], count2 / 2);
      return [...ticks2.map((t) => -t).reverse(), 0, ...ticks2];
    };
  }
  return fn;
}
function autoScaleColor({ type, domain, scaleOptions, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks, plotDefaults }) {
  let fn;
  let range3;
  const { scheme: scheme28, interpolate, pivot, n = type === "threshold" ? domain.length + 1 : 9, unknown = plotDefaults.unknown } = scaleOptions;
  if (type === "categorical" || type === "ordinal") {
    let scheme_ = scheme28 || plotDefaults.categoricalColorScheme;
    if (isPlainObject(scheme_)) {
      const newScheme = Object.values(scheme_);
      const newDomain = Object.keys(scheme_);
      for (const v of domain) {
        if (scheme_[v] == null) {
          newDomain.push(v);
          newScheme.push(unknown);
        }
      }
      domain = newDomain;
      scheme_ = newScheme;
    }
    range3 = Array.isArray(scheme_) ? scheme_ : isCategoricalScheme(scheme_) ? categoricalSchemes.get(scheme_) : ordinalScheme(scheme_)(domain.length);
    fn = ordinal().domain(domain).range(range3);
  } else if (!!ThresholdScales[type]) {
    const scheme_ = scheme28 || plotDefaults.colorScheme;
    range3 = Array.isArray(scheme_) && (scaleOptions.n == null || scaleOptions.n === scheme_.length) ? scheme_.slice(0) : Array.isArray(scheme_) ? (
      // interpolate n colors from custom colors
      range(n).map((i) => i / (n - 1)).map(linear2(scheme_.map((c4, i) => i / (scheme_.length - 1)), scheme_).interpolate(lab2))
    ) : interpolate ? range(n).map((i) => interpolate(i / (n - 1))) : isOrdinalScheme(scheme_) ? ordinalScheme(scheme_)(n) : null;
    if (range3 == null) {
      throw new Error("unknown ordinal scheme " + scheme_);
    }
    if (scaleOptions.reverse)
      range3 = range3.toReversed();
    fn = ThresholdScales[type]().domain(domain).range(range3);
  } else if (!!SequentialScales[type] || !!DivergingScales[type]) {
    const scale = SequentialScales[type] || DivergingScales[type];
    const scheme_ = scheme28 || plotDefaults.colorScheme;
    if (interpolate) {
      fn = scale(domain, interpolate);
    } else if (Array.isArray(scheme_)) {
      const step = 1 / (scheme_.length - 1);
      fn = scale(domain, (type === "linear" ? linear2 : log)(range(0, 1 + step / 2, step), scheme_).interpolate(lab2));
    } else if (!!DivergingScales[type] || scaleOptions.type === "auto" && isDivergingScheme(scheme_)) {
      const maxabs = Math.max(Math.abs(domain[0]), Math.abs(domain[1]));
      const domain_ = pivot != null ? [domain[0], pivot, domain[1]] : [-maxabs, 0, maxabs];
      fn = scale(domain_, quantitativeScheme(scheme_));
    } else if (!!SequentialScales[type] || scaleOptions.type === "auto" && isQuantitativeScheme(scheme_)) {
      fn = scale(domain, quantitativeScheme(scheme_));
    }
    if (type === "log") {
      fn.ticks = (count2) => getLogTicks(domain, count2);
    }
  }
  if (!fn) {
    console.error("color problem", type);
    fn = () => "red";
    fn.range = () => ["red"];
  }
  return fn;
}
function getScaleRange(name, scaleOptions, plotOptions, plotWidth, plotHeight, plotHasFilledDotMarks) {
  const { marginTop, marginLeft, inset } = plotOptions;
  const { insetLeft, insetRight, insetTop, insetBottom } = scaleOptions;
  return name === "opacity" ? [0, 1] : name === "length" ? [0, 20] : name === "x" ? [
    marginLeft + (insetLeft || inset || 0),
    marginLeft + plotWidth - (insetRight || inset || 0)
  ] : name === "y" ? [
    plotHeight + marginTop - (insetBottom || inset || 0),
    marginTop + (insetTop || inset || 0)
  ] : name === "r" ? [0, 10] : name === "symbol" ? (
    // Plot is smart enough to pick different default shapes depending on whether
    // or not there are filled dot marks in the plot, so we have to pass this
    // information all the way here
    plotHasFilledDotMarks ? ["circle", "cross", "diamond", "square", "star", "triangle", "wye"] : ["circle", "plus", "times", "triangle2", "asterisk", "square2", "diamond2"]
  ) : [];
}

// node_modules/svelteplot/dist/helpers/autoProjection.js
var identity8 = constant2({ stream: (stream) => stream });
var reflectY = constant2({
  ...transform_default({
    point(x2, y2) {
      this.stream.point(x2, -y2);
    }
  }),
  invert(x2, y2) {
    return [x2, -y2];
  }
});
var pi4 = Math.PI;
var tau4 = 2 * pi4;
function namedProjection(projection2) {
  switch (`${projection2}`.toLowerCase()) {
    case "albers-usa":
      return scaleProjection(albersUsa_default, 0.7463, 0.4673);
    case "albers":
      return conicProjection2(albers_default, 0.7463, 0.4673);
    case "azimuthal-equal-area":
      return scaleProjection(azimuthalEqualArea_default, 4, 4);
    case "azimuthal-equidistant":
      return scaleProjection(azimuthalEquidistant_default, tau4, tau4);
    case "conic-conformal":
      return conicProjection2(conicConformal_default, tau4, tau4);
    case "conic-equal-area":
      return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
    case "conic-equidistant":
      return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
    case "equal-earth":
      return scaleProjection(equalEarth_default, 5.4133, 2.6347);
    case "equirectangular":
      return scaleProjection(equirectangular_default, tau4, pi4);
    case "gnomonic":
      return scaleProjection(gnomonic_default, 3.4641, 3.4641);
    case "identity":
      return { type: identity8 };
    case "reflect-y":
      return { type: reflectY };
    case "mercator":
      return scaleProjection(mercator_default, tau4, tau4);
    case "orthographic":
      return scaleProjection(orthographic_default, 2, 2);
    case "stereographic":
      return scaleProjection(stereographic_default, 2, 2);
    case "transverse-mercator":
      return scaleProjection(transverseMercator_default, tau4, tau4);
    default:
      throw new Error(`unknown projection type: ${projection2}`);
  }
}
function scaleProjection(createProjection2, kx2, ky2) {
  return {
    type: ({ width, height, rotate, precision = 0.15, clip }) => {
      const projection2 = createProjection2();
      if (precision != null)
        projection2.precision?.(precision);
      if (rotate != null)
        projection2.rotate?.(rotate);
      if (typeof clip === "number")
        projection2.clipAngle?.(clip);
      projection2.scale(Math.min(width / kx2, height / ky2));
      projection2.translate([width / 2, height / 2]);
      return projection2;
    },
    aspectRatio: ky2 / kx2
  };
}
function conicProjection2(createProjection2, kx2, ky2) {
  const { type, aspectRatio } = scaleProjection(createProjection2, kx2, ky2);
  return {
    type: (options) => {
      const { parallels, domain, width, height } = options;
      const projection2 = type(options);
      if (parallels != null) {
        projection2.parallels?.(parallels);
        if (domain === void 0) {
          projection2.fitSize([width, height], { type: "Sphere" });
        }
      }
      return projection2;
    },
    aspectRatio
  };
}

// node_modules/svelteplot/dist/Plot.svelte
Plot_1[FILENAME] = "node_modules/svelteplot/dist/Plot.svelte";
var root_212 = add_locations(from_html(`<h2> </h2>`), Plot_1[FILENAME], [[82, 27]]);
var root_36 = add_locations(from_html(`<h3> </h3>`), Plot_1[FILENAME], [[83, 30]]);
var root_110 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), Plot_1[FILENAME], []);
var root_82 = add_locations(from_html(`<div> </div>`), Plot_1[FILENAME], [[95, 29]]);
var root_7 = add_locations(from_html(`<!> <!>`, 1), Plot_1[FILENAME], []);
var root_102 = add_locations(from_html(`<div class="error s-MjBGrrO9VNdF"> </div>`), Plot_1[FILENAME], [[175, 8]]);
var root_142 = add_locations(from_svg(`<tspan x="0"> </tspan>`), Plot_1[FILENAME], [[165, 28]]);
var root_133 = add_locations(from_svg(`<text class="error s-MjBGrrO9VNdF" transform="translate(10,10)"></text>`), Plot_1[FILENAME], [[163, 20]]);
var root_162 = add_locations(from_html(`<!> <!>`, 1), Plot_1[FILENAME], []);
var root_192 = add_locations(from_html(`<!> <!>`, 1), Plot_1[FILENAME], []);
var root_152 = add_locations(from_html(`<!> <!> <!> <!> <!> <!>`, 1), Plot_1[FILENAME], []);
var $$css11 = {
  hash: "s-MjBGrrO9VNdF",
  code: "\n    .error.s-MjBGrrO9VNdF {\n        font-size: 11px;\n        stroke-width: 3px;\n        font-weight: bold;\n    }\n    text.error.s-MjBGrrO9VNdF {\n        stroke: var(--svelteplot-bg, white);\n        fill: crimson;\n        paint-order: stroke fill;\n    }\n    div.error.s-MjBGrrO9VNdF {\n        color: crimson;\n        white-space: pre-wrap;\n        line-height: 1.1;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxvdC5zdmVsdGUiLCJzb3VyY2VzIjpbIlBsb3Quc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cbiAgICBAY29tcG9uZW50XG4gICAgVGhlIFBsb3QgY29tcG9uZW50IGlzIHRoZSBjb250YWluZXIgZm9yIHBsb3RzLiBJdCBjb2xsZWN0cyB0aGUgbWFya3Mgd2l0aFxuICAgIHRoZWlyIGRhdGEgYW5kIGNoYW5uZWxzIGFuZCBjb21wdXRlcyB0aGUgc2hhcmVkIHNjYWxlcy5cblxuICAgIFRoZSBQbG90IGNvbXBvbmVudCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhpcyBpcyB0aGUgb3V0ZXIgUGxvdCB3aGljaCBcbiAgICBwcm92aWRlcyBjb252ZW5pZW50IGRlZmF1bHRzIGFuZCBhdXRvbWF0aWNhbGx5IGFkZHMgYXhlcyBldGMgdG8gdGhlIGdyYXBoaWNzLlxuICAgIFRoZSBkb3duc2lkZSBpcyB0aGF0IGl0IGFkZHMgYSBidW5jaCBvZiBpbXBvcnRzIHRoYXQgeW91IG1heSBub3QgYmUgdXNpbmcuXG4gICAgVG8gaGVscCB3aXRoIHRoaXMgeW91IGNhbiB1c2UgdGhlIGNvcmUvUGxvdCBjb21wb25lbnQgZGlyZWN0bHkgZm9yIGEgbW9yZVxuICAgIGxvdy1sZXZlbCBQbG90IHdyYXBwZXIuXG4tLT5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IFBsb3QgZnJvbSAnLi9jb3JlL1Bsb3Quc3ZlbHRlJztcblxuICAgIGltcG9ydCB0eXBlIHsgUGxvdE9wdGlvbnMsIFJhd1ZhbHVlLCBTY2FsZU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzL2luZGV4LmpzJztcblxuICAgIC8vIGltcGxpY2l0IG1hcmtzXG4gICAgaW1wb3J0IEF4aXNYIGZyb20gJy4vbWFya3MvQXhpc1guc3ZlbHRlJztcbiAgICBpbXBvcnQgQXhpc1kgZnJvbSAnLi9tYXJrcy9BeGlzWS5zdmVsdGUnO1xuICAgIGltcG9ydCBDb2xvckxlZ2VuZCBmcm9tICcuL21hcmtzL0NvbG9yTGVnZW5kLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IEZyYW1lIGZyb20gJy4vbWFya3MvRnJhbWUuc3ZlbHRlJztcbiAgICBpbXBvcnQgR3JpZFggZnJvbSAnLi9tYXJrcy9HcmlkWC5zdmVsdGUnO1xuICAgIGltcG9ydCBHcmlkWSBmcm9tICcuL21hcmtzL0dyaWRZLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IFN5bWJvbExlZ2VuZCBmcm9tICcuL21hcmtzL1N5bWJvbExlZ2VuZC5zdmVsdGUnO1xuICAgIGltcG9ydCBGYWNldEF4ZXMgZnJvbSAnLi9jb3JlL0ZhY2V0QXhlcy5zdmVsdGUnO1xuXG4gICAgLy8gYXV0b21hdGljIHNjYWxlc1xuICAgIGltcG9ydCB7IGF1dG9TY2FsZSwgYXV0b1NjYWxlQ29sb3IgfSBmcm9tICcuL2hlbHBlcnMvYXV0b1NjYWxlcy5qcyc7XG4gICAgaW1wb3J0IHsgbmFtZWRQcm9qZWN0aW9uIH0gZnJvbSAnLi9oZWxwZXJzL2F1dG9Qcm9qZWN0aW9uLmpzJztcbiAgICBpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4vaGVscGVycy9pbmRleC5qcyc7XG5cbiAgICBsZXQge1xuICAgICAgICBoZWFkZXI6IHVzZXJIZWFkZXIsXG4gICAgICAgIGZvb3RlcjogdXNlckZvb3RlcixcbiAgICAgICAgb3ZlcmxheSxcbiAgICAgICAgdW5kZXJsYXksXG4gICAgICAgIGNoaWxkcmVuOiBwYXJlbnRDaGlsZHJlbixcbiAgICAgICAgdGVzdGlkLFxuICAgICAgICBmYWNldCxcbiAgICAgICAgcHJvamVjdGlvbixcbiAgICAgICAgLi4ucmVzdE9wdGlvbnNcbiAgICB9OiBQYXJ0aWFsPFBsb3RPcHRpb25zPiA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgcHJvamVjdGlvbk9wdHMgPSAkZGVyaXZlZC5ieSgoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHByb2plY3Rpb24gJiZcbiAgICAgICAgICAgIHR5cGVvZiBwcm9qZWN0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICB0eXBlb2YgcHJvamVjdGlvbj8udHlwZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZTogcHJvakZhY3RvcnksIGFzcGVjdFJhdGlvIH0gPSBuYW1lZFByb2plY3Rpb24oXG4gICAgICAgICAgICAgICAgaXNPYmplY3QocHJvamVjdGlvbikgPyBwcm9qZWN0aW9uLnR5cGUgOiBwcm9qZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi4oaXNPYmplY3QocHJvamVjdGlvbikgPyBwcm9qZWN0aW9uIDoge30pLFxuICAgICAgICAgICAgICAgIHR5cGU6IHByb2pGYWN0b3J5LFxuICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2NhbGVzID0gJGRlcml2ZWQoXG4gICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIFsneCcsICd5JywgJ3InLCAnY29sb3InLCAnb3BhY2l0eScsICdzeW1ib2wnLCAnbGVuZ3RoJywgJ2Z4JywgJ2Z5J10ubWFwKChzY2FsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlT3B0cyA9IG1heWJlU2NhbGVPcHRpb25zKHJlc3RPcHRpb25zW3NjYWxlXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVGbiA9IHNjYWxlT3B0cy5zY2FsZSB8fCAoc2NhbGUgPT09ICdjb2xvcicgPyBhdXRvU2NhbGVDb2xvciA6IGF1dG9TY2FsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzY2FsZSwgeyAuLi5zY2FsZU9wdHMsIHNjYWxlOiBzY2FsZUZuIH1dO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBtYXliZVNjYWxlT3B0aW9ucyhcbiAgICAgICAgc2NhbGVPcHRpb25zOiB1bmRlZmluZWQgfCBmYWxzZSB8IFJhd1ZhbHVlW10gfCBvYmplY3RcbiAgICApOiBQYXJ0aWFsPFNjYWxlT3B0aW9ucz4gfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoc2NhbGVPcHRpb25zID09PSBmYWxzZSkgcmV0dXJuIHsgYXhpczogZmFsc2UgfTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NhbGVPcHRpb25zKSkgcmV0dXJuIHsgZG9tYWluOiBzY2FsZU9wdGlvbnMgfTtcbiAgICAgICAgcmV0dXJuIHNjYWxlT3B0aW9ucyB8fCB7fTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IGhlYWRlcigpfVxuICAgIHsjaWYgcmVzdE9wdGlvbnMudGl0bGV9PGgyPntyZXN0T3B0aW9ucy50aXRsZX08L2gyPnsvaWZ9XG4gICAgeyNpZiByZXN0T3B0aW9ucy5zdWJ0aXRsZX08aDM+e3Jlc3RPcHRpb25zLnN1YnRpdGxlfTwvaDM+ey9pZn1cbiAgICA8IS0tIGFsc28gcGFzcyBvbiB1c2VyIGhlYWRlciAtLT5cbiAgICB7I2lmIHVzZXJIZWFkZXJ9e0ByZW5kZXIgdXNlckhlYWRlcj8uKCl9ey9pZn1cbiAgICB7I2lmIHJlc3RPcHRpb25zLmNvbG9yPy5sZWdlbmR9XG4gICAgICAgIDxDb2xvckxlZ2VuZCAvPlxuICAgIHsvaWZ9XG4gICAgeyNpZiByZXN0T3B0aW9ucy5zeW1ib2w/LmxlZ2VuZH1cbiAgICAgICAgPFN5bWJvbExlZ2VuZCAvPlxuICAgIHsvaWZ9XG57L3NuaXBwZXR9XG5cbnsjc25pcHBldCBmb290ZXIoKX1cbiAgICB7I2lmIHJlc3RPcHRpb25zLmNhcHRpb259PGRpdj57cmVzdE9wdGlvbnMuY2FwdGlvbn08L2Rpdj57L2lmfVxuICAgIHsjaWYgdXNlckZvb3Rlcn17QHJlbmRlciB1c2VyRm9vdGVyPy4oKX17L2lmfVxuey9zbmlwcGV0fVxuXG48IS0tIFRoZXJlJ3MgYSBidWcgdHJpZ2dlcmluZyBSYW5nZUVycm9yOiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZCBcbiAgICAgd2hlbiB1c2luZyBTdmVsdGVQbG90IGluIHNzciwgc28gZm9yIG5vdywgd2UncmUgZGlzYWJsaW5nIGl0IC0tPlxuXG48c3ZlbHRlOmJvdW5kYXJ5PlxuICAgIDxQbG90XG4gICAgICAgIHtvdmVybGF5fVxuICAgICAgICB7dW5kZXJsYXl9XG4gICAgICAgIHsuLi5yZXN0T3B0aW9uc31cbiAgICAgICAgaGVhZGVyPXt1c2VySGVhZGVyIHx8XG4gICAgICAgIHJlc3RPcHRpb25zLnRpdGxlIHx8XG4gICAgICAgIHJlc3RPcHRpb25zLnN1YnRpdGxlIHx8XG4gICAgICAgIHJlc3RPcHRpb25zLmNvbG9yPy5sZWdlbmQgfHxcbiAgICAgICAgcmVzdE9wdGlvbnMuc3ltYm9sPy5sZWdlbmRcbiAgICAgICAgICAgID8gaGVhZGVyXG4gICAgICAgICAgICA6IG51bGx9XG4gICAgICAgIGZvb3Rlcj17dXNlckZvb3RlciB8fCByZXN0T3B0aW9ucz8uY2FwdGlvbiA/IGZvb3RlciA6IG51bGx9XG4gICAgICAgIHByb2plY3Rpb249e3Byb2plY3Rpb25PcHRzfVxuICAgICAgICBpbXBsaWNpdFNjYWxlc1xuICAgICAgICB7Li4uc2NhbGVzfT5cbiAgICAgICAgeyNzbmlwcGV0IGNoaWxkcmVuKHtcbiAgICAgICAgICAgIGhhc1Byb2plY3Rpb24sXG4gICAgICAgICAgICBoYXNFeHBsaWNpdEF4aXNYLFxuICAgICAgICAgICAgaGFzRXhwbGljaXRBeGlzWSxcbiAgICAgICAgICAgIGhhc0V4cGxpY2l0R3JpZFgsXG4gICAgICAgICAgICBoYXNFeHBsaWNpdEdyaWRZLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHNjYWxlcyxcbiAgICAgICAgICAgIC4uLnJlc3RQcm9wc1xuICAgICAgICB9KX1cbiAgICAgICAgICAgIDxzdmVsdGU6Ym91bmRhcnkgb25lcnJvcj17KGVycikgPT4gY29uc29sZS5lcnJvcihlcnIpfT5cbiAgICAgICAgICAgICAgICA8IS0tIGltcGxpY2l0IGF4ZXMgLS0+XG4gICAgICAgICAgICAgICAgeyNpZiAhaGFzUHJvamVjdGlvbiAmJiAhaGFzRXhwbGljaXRBeGlzWH1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBvcHRpb25zLmF4ZXMgJiYgKG9wdGlvbnMueC5heGlzID09PSAndG9wJyB8fCBvcHRpb25zLnguYXhpcyA9PT0gJ2JvdGgnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBeGlzWCBhbmNob3I9XCJ0b3BcIiBhdXRvbWF0aWMgLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBvcHRpb25zLmF4ZXMgJiYgKG9wdGlvbnMueC5heGlzID09PSAnYm90dG9tJyB8fCBvcHRpb25zLnguYXhpcyA9PT0gJ2JvdGgnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBeGlzWCBhbmNob3I9XCJib3R0b21cIiBhdXRvbWF0aWMgLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsjaWYgIWhhc1Byb2plY3Rpb24gJiYgIWhhc0V4cGxpY2l0QXhpc1l9XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgb3B0aW9ucy5heGVzICYmIChvcHRpb25zLnkuYXhpcyA9PT0gJ2xlZnQnIHx8IG9wdGlvbnMueS5heGlzID09PSAnYm90aCcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPEF4aXNZIGFuY2hvcj1cImxlZnRcIiBhdXRvbWF0aWMgLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBvcHRpb25zLmF4ZXMgJiYgKG9wdGlvbnMueS5heGlzID09PSAncmlnaHQnIHx8IG9wdGlvbnMueS5heGlzID09PSAnYm90aCcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPEF4aXNZIGFuY2hvcj1cInJpZ2h0XCIgYXV0b21hdGljIC8+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8IS0tIGltcGxpY2l0IGdyaWRzIC0tPlxuICAgICAgICAgICAgICAgIHsjaWYgIWhhc0V4cGxpY2l0R3JpZFggJiYgKG9wdGlvbnMuZ3JpZCB8fCBvcHRpb25zLnguZ3JpZCl9XG4gICAgICAgICAgICAgICAgICAgIDxHcmlkWCBhdXRvbWF0aWMgLz5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsjaWYgIWhhc0V4cGxpY2l0R3JpZFkgJiYgKG9wdGlvbnMuZ3JpZCB8fCBvcHRpb25zLnkuZ3JpZCl9XG4gICAgICAgICAgICAgICAgICAgIDxHcmlkWSBhdXRvbWF0aWMgLz5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIDwhLS0gaW1wbGljaXQgZnJhbWUgLS0+XG4gICAgICAgICAgICAgICAgeyNpZiBvcHRpb25zLmZyYW1lfVxuICAgICAgICAgICAgICAgICAgICA8RnJhbWUgYXV0b21hdGljIC8+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7QHJlbmRlciBwYXJlbnRDaGlsZHJlbj8uKHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN0UHJvcHNcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICB7I3NuaXBwZXQgZmFpbGVkKGVycm9yLCByZXNldCl9XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0IGNsYXNzPVwiZXJyb3JcIiB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTAsMTApXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2VhY2ggZXJyb3IubWVzc2FnZS5zcGxpdCgnXFxuJykgYXMgbGluZSwgaSAoaSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9XCIwXCIgZHk9e2kgPyAxNCA6IDB9PntsaW5lfTwvdHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgICAgIDwvdGV4dD57L3NuaXBwZXR9XG4gICAgICAgICAgICA8L3N2ZWx0ZTpib3VuZGFyeT5cbiAgICAgICAgey9zbmlwcGV0fVxuICAgICAgICB7I3NuaXBwZXQgZmFjZXRBeGVzKCl9XG4gICAgICAgICAgICA8RmFjZXRBeGVzIC8+XG4gICAgICAgIHsvc25pcHBldH1cbiAgICA8L1Bsb3Q+XG4gICAgeyNzbmlwcGV0IGZhaWxlZChlcnJvcil9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJlcnJvclwiPkVycm9yOiB7ZXJyb3IubWVzc2FnZX08L2Rpdj5cbiAgICB7L3NuaXBwZXR9XG48L3N2ZWx0ZTpib3VuZGFyeT5cblxuPHN0eWxlPlxuICAgIC5lcnJvciB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAzcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cbiAgICB0ZXh0LmVycm9yIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1zdmVsdGVwbG90LWJnLCB3aGl0ZSk7XG4gICAgICAgIGZpbGw6IGNyaW1zb247XG4gICAgICAgIHBhaW50LW9yZGVyOiBzdHJva2UgZmlsbDtcbiAgICB9XG4gICAgZGl2LmVycm9yIHtcbiAgICAgICAgY29sb3I6IGNyaW1zb247XG4gICAgICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function Plot_1($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Plot_1);
  append_styles($$anchor, $$css11);
  const header = wrap_snippet(Plot_1, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = root_110();
    var node = first_child(fragment);
    {
      var consequent = ($$anchor3) => {
        var h2 = root_212();
        var text2 = child(h2, true);
        reset(h2);
        template_effect(() => set_text(text2, $$props.title));
        append($$anchor3, h2);
      };
      add_svelte_meta(
        () => if_block(node, ($$render) => {
          if ($$props.title) $$render(consequent);
        }),
        "if",
        Plot_1,
        82,
        4
      );
    }
    var node_1 = sibling(node, 2);
    {
      var consequent_1 = ($$anchor3) => {
        var h3 = root_36();
        var text_1 = child(h3, true);
        reset(h3);
        template_effect(() => set_text(text_1, $$props.subtitle));
        append($$anchor3, h3);
      };
      add_svelte_meta(
        () => if_block(node_1, ($$render) => {
          if ($$props.subtitle) $$render(consequent_1);
        }),
        "if",
        Plot_1,
        83,
        4
      );
    }
    var node_2 = sibling(node_1, 2);
    {
      var consequent_2 = ($$anchor3) => {
        var fragment_1 = comment();
        var node_3 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_3, () => $$props.header ?? noop), "render", Plot_1, 85, 20);
        append($$anchor3, fragment_1);
      };
      add_svelte_meta(
        () => if_block(node_2, ($$render) => {
          if ($$props.header) $$render(consequent_2);
        }),
        "if",
        Plot_1,
        85,
        4
      );
    }
    var node_4 = sibling(node_2, 2);
    {
      var consequent_3 = ($$anchor3) => {
        var fragment_2 = comment();
        var node_5 = first_child(fragment_2);
        add_svelte_meta(() => ColorLegend_default(node_5, {}), "component", Plot_1, 87, 8, { componentTag: "ColorLegend" });
        append($$anchor3, fragment_2);
      };
      add_svelte_meta(
        () => if_block(node_4, ($$render) => {
          if ($$props.color?.legend) $$render(consequent_3);
        }),
        "if",
        Plot_1,
        86,
        4
      );
    }
    var node_6 = sibling(node_4, 2);
    {
      var consequent_4 = ($$anchor3) => {
        var fragment_3 = comment();
        var node_7 = first_child(fragment_3);
        add_svelte_meta(() => SymbolLegend_default(node_7, {}), "component", Plot_1, 90, 8, { componentTag: "SymbolLegend" });
        append($$anchor3, fragment_3);
      };
      add_svelte_meta(
        () => if_block(node_6, ($$render) => {
          if ($$props.symbol?.legend) $$render(consequent_4);
        }),
        "if",
        Plot_1,
        89,
        4
      );
    }
    append($$anchor2, fragment);
  });
  const footer = wrap_snippet(Plot_1, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment_4 = root_7();
    var node_8 = first_child(fragment_4);
    {
      var consequent_5 = ($$anchor3) => {
        var div = root_82();
        var text_2 = child(div, true);
        reset(div);
        template_effect(() => set_text(text_2, $$props.caption));
        append($$anchor3, div);
      };
      add_svelte_meta(
        () => if_block(node_8, ($$render) => {
          if ($$props.caption) $$render(consequent_5);
        }),
        "if",
        Plot_1,
        95,
        4
      );
    }
    var node_9 = sibling(node_8, 2);
    {
      var consequent_6 = ($$anchor3) => {
        var fragment_5 = comment();
        var node_10 = first_child(fragment_5);
        add_svelte_meta(() => snippet(node_10, () => $$props.footer ?? noop), "render", Plot_1, 96, 20);
        append($$anchor3, fragment_5);
      };
      add_svelte_meta(
        () => if_block(node_9, ($$render) => {
          if ($$props.footer) $$render(consequent_6);
        }),
        "if",
        Plot_1,
        96,
        4
      );
    }
    append($$anchor2, fragment_4);
  });
  let restOptions = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "header",
      "footer",
      "overlay",
      "underlay",
      "children",
      "testid",
      "facet",
      "projection"
    ],
    "restOptions"
  );
  const projectionOpts = tag(
    user_derived(() => {
      if ($$props.projection && strict_equals(typeof $$props.projection, "function", false) && strict_equals(typeof $$props.projection?.type, "function", false)) {
        const { type: projFactory, aspectRatio } = namedProjection(isObject($$props.projection) ? $$props.projection.type : $$props.projection);
        return {
          ...isObject($$props.projection) ? $$props.projection : {},
          type: projFactory,
          aspectRatio
        };
      }
      return $$props.projection;
    }),
    "projectionOpts"
  );
  const scales = tag(
    user_derived(() => Object.fromEntries([
      "x",
      "y",
      "r",
      "color",
      "opacity",
      "symbol",
      "length",
      "fx",
      "fy"
    ].map((scale) => {
      const scaleOpts = maybeScaleOptions(restOptions[scale]);
      const scaleFn = scaleOpts.scale || (strict_equals(scale, "color") ? autoScaleColor : autoScale);
      return [scale, { ...scaleOpts, scale: scaleFn }];
    }))),
    "scales"
  );
  function maybeScaleOptions(scaleOptions) {
    if (strict_equals(scaleOptions, false)) return { axis: false };
    if (Array.isArray(scaleOptions)) return { domain: scaleOptions };
    return scaleOptions || {};
  }
  var $$exports = { ...legacy_api() };
  var fragment_6 = comment();
  var node_11 = first_child(fragment_6);
  {
    const failed = wrap_snippet(Plot_1, function($$anchor2, error = noop) {
      validate_snippet_args(...arguments);
      var div_1 = root_102();
      var text_3 = child(div_1);
      reset(div_1);
      template_effect(() => set_text(text_3, `Error: ${error().message ?? ""}`));
      append($$anchor2, div_1);
    });
    boundary(node_11, { failed }, ($$anchor2) => {
      var fragment_7 = comment();
      var node_12 = first_child(fragment_7);
      {
        const children = wrap_snippet(Plot_1, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let hasProjection = () => $$arg0?.().hasProjection;
          hasProjection();
          let hasExplicitAxisX = () => $$arg0?.().hasExplicitAxisX;
          hasExplicitAxisX();
          let hasExplicitAxisY = () => $$arg0?.().hasExplicitAxisY;
          hasExplicitAxisY();
          let hasExplicitGridX = () => $$arg0?.().hasExplicitGridX;
          hasExplicitGridX();
          let hasExplicitGridY = () => $$arg0?.().hasExplicitGridY;
          hasExplicitGridY();
          let options = () => $$arg0?.().options;
          options();
          let scales2 = () => $$arg0?.().scales;
          scales2();
          let restProps = () => exclude_from_object($$arg0?.(), [
            "hasProjection",
            "hasExplicitAxisX",
            "hasExplicitAxisY",
            "hasExplicitGridX",
            "hasExplicitGridY",
            "options",
            "scales"
          ]);
          restProps();
          var fragment_8 = comment();
          var node_13 = first_child(fragment_8);
          {
            const failed2 = wrap_snippet(Plot_1, function($$anchor4, error = noop, reset2 = noop) {
              validate_snippet_args(...arguments);
              var text_4 = root_133();
              add_svelte_meta(
                () => each(text_4, 21, () => error().message.split("\n"), index, ($$anchor5, line, i) => {
                  var tspan = root_142();
                  set_attribute(tspan, "dy", i ? 14 : 0);
                  var text_5 = child(tspan, true);
                  reset(tspan);
                  template_effect(() => set_text(text_5, get(line)));
                  append($$anchor5, tspan);
                }),
                "each",
                Plot_1,
                164,
                24
              );
              reset(text_4);
              append($$anchor4, text_4);
            });
            boundary(
              node_13,
              {
                onerror: (err) => console.error(...log_if_contains_state("error", err)),
                failed: failed2
              },
              ($$anchor4) => {
                var fragment_9 = root_152();
                var node_14 = first_child(fragment_9);
                {
                  var consequent_9 = ($$anchor5) => {
                    var fragment_10 = root_162();
                    var node_15 = first_child(fragment_10);
                    {
                      var consequent_7 = ($$anchor6) => {
                        var fragment_11 = comment();
                        var node_16 = first_child(fragment_11);
                        add_svelte_meta(() => AxisX_default(node_16, { anchor: "top", automatic: true }), "component", Plot_1, 132, 24, { componentTag: "AxisX" });
                        append($$anchor6, fragment_11);
                      };
                      add_svelte_meta(
                        () => if_block(node_15, ($$render) => {
                          if (options().axes && (strict_equals(options().x.axis, "top") || strict_equals(options().x.axis, "both"))) $$render(consequent_7);
                        }),
                        "if",
                        Plot_1,
                        131,
                        20
                      );
                    }
                    var node_17 = sibling(node_15, 2);
                    {
                      var consequent_8 = ($$anchor6) => {
                        var fragment_12 = comment();
                        var node_18 = first_child(fragment_12);
                        add_svelte_meta(() => AxisX_default(node_18, { anchor: "bottom", automatic: true }), "component", Plot_1, 135, 24, { componentTag: "AxisX" });
                        append($$anchor6, fragment_12);
                      };
                      add_svelte_meta(
                        () => if_block(node_17, ($$render) => {
                          if (options().axes && (strict_equals(options().x.axis, "bottom") || strict_equals(options().x.axis, "both"))) $$render(consequent_8);
                        }),
                        "if",
                        Plot_1,
                        134,
                        20
                      );
                    }
                    append($$anchor5, fragment_10);
                  };
                  add_svelte_meta(
                    () => if_block(node_14, ($$render) => {
                      if (!hasProjection() && !hasExplicitAxisX()) $$render(consequent_9);
                    }),
                    "if",
                    Plot_1,
                    130,
                    16
                  );
                }
                var node_19 = sibling(node_14, 2);
                {
                  var consequent_12 = ($$anchor5) => {
                    var fragment_13 = root_192();
                    var node_20 = first_child(fragment_13);
                    {
                      var consequent_10 = ($$anchor6) => {
                        var fragment_14 = comment();
                        var node_21 = first_child(fragment_14);
                        add_svelte_meta(() => AxisY_default(node_21, { anchor: "left", automatic: true }), "component", Plot_1, 140, 24, { componentTag: "AxisY" });
                        append($$anchor6, fragment_14);
                      };
                      add_svelte_meta(
                        () => if_block(node_20, ($$render) => {
                          if (options().axes && (strict_equals(options().y.axis, "left") || strict_equals(options().y.axis, "both"))) $$render(consequent_10);
                        }),
                        "if",
                        Plot_1,
                        139,
                        20
                      );
                    }
                    var node_22 = sibling(node_20, 2);
                    {
                      var consequent_11 = ($$anchor6) => {
                        var fragment_15 = comment();
                        var node_23 = first_child(fragment_15);
                        add_svelte_meta(() => AxisY_default(node_23, { anchor: "right", automatic: true }), "component", Plot_1, 143, 24, { componentTag: "AxisY" });
                        append($$anchor6, fragment_15);
                      };
                      add_svelte_meta(
                        () => if_block(node_22, ($$render) => {
                          if (options().axes && (strict_equals(options().y.axis, "right") || strict_equals(options().y.axis, "both"))) $$render(consequent_11);
                        }),
                        "if",
                        Plot_1,
                        142,
                        20
                      );
                    }
                    append($$anchor5, fragment_13);
                  };
                  add_svelte_meta(
                    () => if_block(node_19, ($$render) => {
                      if (!hasProjection() && !hasExplicitAxisY()) $$render(consequent_12);
                    }),
                    "if",
                    Plot_1,
                    138,
                    16
                  );
                }
                var node_24 = sibling(node_19, 2);
                {
                  var consequent_13 = ($$anchor5) => {
                    var fragment_16 = comment();
                    var node_25 = first_child(fragment_16);
                    add_svelte_meta(() => GridX_default(node_25, { automatic: true }), "component", Plot_1, 148, 20, { componentTag: "GridX" });
                    append($$anchor5, fragment_16);
                  };
                  add_svelte_meta(
                    () => if_block(node_24, ($$render) => {
                      if (!hasExplicitGridX() && (options().grid || options().x.grid)) $$render(consequent_13);
                    }),
                    "if",
                    Plot_1,
                    147,
                    16
                  );
                }
                var node_26 = sibling(node_24, 2);
                {
                  var consequent_14 = ($$anchor5) => {
                    var fragment_17 = comment();
                    var node_27 = first_child(fragment_17);
                    add_svelte_meta(() => GridY_default(node_27, { automatic: true }), "component", Plot_1, 151, 20, { componentTag: "GridY" });
                    append($$anchor5, fragment_17);
                  };
                  add_svelte_meta(
                    () => if_block(node_26, ($$render) => {
                      if (!hasExplicitGridY() && (options().grid || options().y.grid)) $$render(consequent_14);
                    }),
                    "if",
                    Plot_1,
                    150,
                    16
                  );
                }
                var node_28 = sibling(node_26, 2);
                {
                  var consequent_15 = ($$anchor5) => {
                    var fragment_18 = comment();
                    var node_29 = first_child(fragment_18);
                    add_svelte_meta(() => Frame_default(node_29, { automatic: true }), "component", Plot_1, 155, 20, { componentTag: "Frame" });
                    append($$anchor5, fragment_18);
                  };
                  add_svelte_meta(
                    () => if_block(node_28, ($$render) => {
                      if (options().frame) $$render(consequent_15);
                    }),
                    "if",
                    Plot_1,
                    154,
                    16
                  );
                }
                var node_30 = sibling(node_28, 2);
                {
                  let $02 = user_derived(() => ({ options: options(), scales: scales2(), ...restProps() }));
                  add_svelte_meta(() => snippet(node_30, () => $$props.children ?? noop, () => get($02)), "render", Plot_1, 157, 16);
                }
                append($$anchor4, fragment_9);
              }
            );
          }
          append($$anchor3, fragment_8);
        });
        const facetAxes = wrap_snippet(Plot_1, function($$anchor3) {
          validate_snippet_args(...arguments);
          var fragment_19 = comment();
          var node_31 = first_child(fragment_19);
          add_svelte_meta(() => FacetAxes_default(node_31, {}), "component", Plot_1, 171, 12, { componentTag: "FacetAxes" });
          append($$anchor3, fragment_19);
        });
        let $0 = user_derived(() => $$props.header || $$props.title || $$props.subtitle || $$props.color?.legend || $$props.symbol?.legend ? header : null);
        let $1 = user_derived(() => $$props.footer || $$props?.caption ? footer : null);
        add_svelte_meta(
          () => Plot_default(node_12, spread_props(
            {
              get overlay() {
                return $$props.overlay;
              },
              get underlay() {
                return $$props.underlay;
              }
            },
            () => restOptions,
            {
              get header() {
                return get($0);
              },
              get footer() {
                return get($1);
              },
              get projection() {
                return get(projectionOpts);
              },
              implicitScales: true
            },
            () => get(scales),
            {
              children,
              facetAxes,
              $$slots: { default: true, facetAxes: true }
            }
          )),
          "component",
          Plot_1,
          103,
          4,
          { componentTag: "Plot" }
        );
      }
      append($$anchor2, fragment_7);
    });
  }
  append($$anchor, fragment_6);
  return pop($$exports);
}
if (import.meta.hot) {
  Plot_1 = hmr(Plot_1);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-MjBGrrO9VNdF");
    Plot_1[HMR].update(module.default);
  });
}
var Plot_default2 = Plot_1;

// node_modules/svelteplot/dist/marks/helpers/GroupMultiple.svelte
GroupMultiple[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/GroupMultiple.svelte";
var root_111 = add_locations(from_svg(`<g><!></g>`), GroupMultiple[FILENAME], [[12, 4]]);
function GroupMultiple($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GroupMultiple);
  let length = prop($$props, "length", 3, 1), className = prop($$props, "class", 3, null), groupProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "length",
      "children",
      "class"
    ],
    "groupProps"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var g = root_111();
      attribute_effect(g, () => ({ class: className(), ...groupProps }));
      var node_1 = child(g);
      add_svelte_meta(() => snippet(node_1, () => $$props.children), "render", GroupMultiple, 13, 8);
      reset(g);
      append($$anchor2, g);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_2, () => $$props.children), "render", GroupMultiple, 16, 4);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (length() > 1 || className()) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      GroupMultiple,
      11,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  GroupMultiple = hmr(GroupMultiple);
  import.meta.hot.accept((module) => {
    GroupMultiple[HMR].update(module.default);
  });
}
var GroupMultiple_default = GroupMultiple;

// node_modules/svelteplot/dist/helpers/curves.js
var curves = /* @__PURE__ */ new Map([
  ["basis", basis_default2],
  ["basis-closed", basisClosed_default2],
  ["basis-open", basisOpen_default],
  ["bundle", bundle_default],
  ["bump-x", bumpX],
  ["bump-y", bumpY],
  ["cardinal", cardinal_default],
  ["cardinal-closed", cardinalClosed_default],
  ["cardinal-open", cardinalOpen_default],
  ["catmull-rom", catmullRom_default],
  ["catmull-rom-closed", catmullRomClosed_default],
  ["catmull-rom-open", catmullRomOpen_default],
  ["linear", linear_default],
  ["linear-closed", linearClosed_default],
  ["monotone-x", monotoneX],
  ["monotone-y", monotoneY],
  ["natural", natural_default],
  ["step", step_default],
  ["step-after", stepAfter],
  ["step-before", stepBefore]
]);
function maybeCurve(curve = linear_default, tension) {
  if (typeof curve === "function")
    return curve;
  const c4 = curves.get(`${curve}`.toLowerCase());
  if (!c4)
    throw new Error(`unknown curve: ${curve}`);
  if (tension !== void 0) {
    if ("beta" in c4) {
      return c4.beta(tension);
    } else if ("tension" in c4) {
      return c4.tension(tension);
    } else if ("alpha" in c4) {
      return c4.alpha(tension);
    }
  }
  return c4;
}

// node_modules/svelteplot/dist/marks/helpers/CanvasLayer.svelte
CanvasLayer[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/CanvasLayer.svelte";
var root_112 = add_locations(from_html(`<canvas></canvas>`), CanvasLayer[FILENAME], [[38, 8]]);
var root5 = add_locations(from_svg(`<foreignObject x="0" y="0" class="s-JzhMMOX__MYV"><!></foreignObject>`), CanvasLayer[FILENAME], [[36, 0]]);
var $$css12 = {
  hash: "s-JzhMMOX__MYV",
  code: "\n    foreignObject.s-JzhMMOX__MYV,\n    canvas.s-JzhMMOX__MYV {\n        color: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzTGF5ZXIuc3ZlbHRlIiwic291cmNlcyI6WyJDYW52YXNMYXllci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgICBpbXBvcnQgeyBkZXZpY2VQaXhlbFJhdGlvIH0gZnJvbSAnc3ZlbHRlL3JlYWN0aXZpdHkvd2luZG93JztcbiAgICBpbXBvcnQgeyBNZWRpYVF1ZXJ5IH0gZnJvbSAnc3ZlbHRlL3JlYWN0aXZpdHknO1xuICAgIGltcG9ydCB0eXBlIHsgQXR0YWNobWVudCB9IGZyb20gJ3N2ZWx0ZS9hdHRhY2htZW50cyc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uLy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIGNvbnN0IGRhcmtNb2RlID0gbmV3IE1lZGlhUXVlcnkoJ3ByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrJyk7XG4gICAgbGV0IGNvbG9yU2NoZW1lID0gJHN0YXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiB3ZSBuZWVkIHRvIHJlcGFpbnQgb24gZGFyayBtb2RlIGNoYW5nZXMgaW4gY2FzZSB0aGUgdXNlclxuICAgICAqIGlzIHVzaW5nIGFueSBjc3MgdmFyaWFibGVzIG9yIGN1cnJlbnRDb2xvciB0aGF0IGNoYW5nZXNcbiAgICAgKiB3aXRoIHRoZSBjb2xvciBzY2hlbWVcbiAgICAgKi9cbiAgICBjb25zdCB3YXRjaENvbG9yU2NoZW1lOiBBdHRhY2htZW50ID0gKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lID0gZ2V0Q29tcHV0ZWRTdHlsZShodG1sRWxlbWVudCkuY29sb3JTY2hlbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGh0bWxFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCByZXN0UHJvcHM6IHt9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBwbG90ID0gdXNlUGxvdCgpO1xuPC9zY3JpcHQ+XG5cbjwhLS0gXG4gICAgQGNvbXBvbmVudCBUaGUgQ2FudmFzTGF5ZXIgY29tcG9uZW50IGlzIGEgaGVscGVyIGNvbXBvbmVudCB0aGF0IGluc2VydHMgYSBcbiAgICBjYW52YXMgZWxlbWVudCBpbnNpZGUgYSBmb3JlaWduT2JqZWN0IGZvciB1c2UgaW4gYSBwbG90IGFuZCB0YWtlcyBjYXJlIG9mIFxuICAgIHNjYWxpbmcgaXQgdG8gdGhlIGRldmljZSBwaXhlbCByYXRpby5cbi0tPlxuPGZvcmVpZ25PYmplY3QgeD1cIjBcIiB5PVwiMFwiIHtAYXR0YWNoIHdhdGNoQ29sb3JTY2hlbWV9IHdpZHRoPXtwbG90LndpZHRofSBoZWlnaHQ9e3Bsb3QuaGVpZ2h0fT5cbiAgICB7I2tleSBbY29sb3JTY2hlbWUsIGRhcmtNb2RlLmN1cnJlbnRdfVxuICAgICAgICA8Y2FudmFzXG4gICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgICAgICAgICAgey4uLnJlc3RQcm9wc31cbiAgICAgICAgICAgIHdpZHRoPXtwbG90LndpZHRoICogKGRldmljZVBpeGVsUmF0aW8uY3VycmVudCA/PyAxKX1cbiAgICAgICAgICAgIGhlaWdodD17cGxvdC5oZWlnaHQgKiAoZGV2aWNlUGl4ZWxSYXRpby5jdXJyZW50ID8/IDEpfVxuICAgICAgICAgICAgc3R5bGU9XCJ3aWR0aDoge3Bsb3Qud2lkdGh9cHg7IGhlaWdodDoge3Bsb3QuaGVpZ2h0fXB4O1wiPjwvY2FudmFzPlxuICAgIHsva2V5fVxuPC9mb3JlaWduT2JqZWN0PlxuXG48c3R5bGU+XG4gICAgZm9yZWlnbk9iamVjdCxcbiAgICBjYW52YXMge1xuICAgICAgICBjb2xvcjogY3VycmVudENvbG9yO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function CanvasLayer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CanvasLayer);
  append_styles($$anchor, $$css12);
  const darkMode = new MediaQuery("prefers-color-scheme: dark");
  let colorScheme = tag(state(void 0), "colorScheme");
  const watchColorScheme = (element2) => {
    const htmlElement = element2.ownerDocument.documentElement;
    const observer = new MutationObserver(() => {
      set(colorScheme, getComputedStyle(htmlElement).colorScheme, true);
    });
    observer.observe(htmlElement, { attributes: true });
    return () => {
      observer.disconnect();
    };
  };
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const plot = usePlot();
  var $$exports = { ...legacy_api() };
  var foreignObject = root5();
  var node = child(foreignObject);
  add_svelte_meta(
    () => key(node, () => [get(colorScheme), darkMode.current], ($$anchor2) => {
      var canvas = root_112();
      attribute_effect(
        canvas,
        () => ({
          xmlns: "http://www.w3.org/1999/xhtml",
          ...restProps,
          width: plot.width * (devicePixelRatio.current ?? 1),
          height: plot.height * (devicePixelRatio.current ?? 1),
          style: `width: ${plot.width ?? ""}px; height: ${plot.height ?? ""}px;`
        }),
        void 0,
        void 0,
        void 0,
        "s-JzhMMOX__MYV"
      );
      append($$anchor2, canvas);
    }),
    "key",
    CanvasLayer,
    37,
    4
  );
  reset(foreignObject);
  attach(foreignObject, () => watchColorScheme);
  template_effect(() => {
    set_attribute(foreignObject, "width", plot.width);
    set_attribute(foreignObject, "height", plot.height);
  });
  append($$anchor, foreignObject);
  return pop($$exports);
}
if (import.meta.hot) {
  CanvasLayer = hmr(CanvasLayer);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-JzhMMOX__MYV");
    CanvasLayer[HMR].update(module.default);
  });
}
var CanvasLayer_default = CanvasLayer;

// node_modules/svelteplot/dist/marks/helpers/canvas.js
function resolveColor(color2, canvas) {
  if (`${color2}`.toLowerCase() === "currentcolor") {
    color2 = getComputedStyle(canvas?.parentElement?.parentElement).getPropertyValue("color");
  }
  if (CSS_VAR.test(color2)) {
    color2 = getComputedStyle(canvas).getPropertyValue(color2.slice(4, -1));
  }
  if (CSS_URL.test(color2)) {
    const m = color2.match(/^url\((#[^)]+)\)/);
    const gradientId = m[1];
    const gradient = canvas.ownerDocument.querySelector(gradientId);
    if (gradient) {
      if (gradient.nodeName.toLowerCase() === "lineargradient") {
        const x06 = +gradient.getAttribute("x1");
        const x12 = +gradient.getAttribute("x2");
        const y06 = +gradient.getAttribute("y1");
        const y12 = +gradient.getAttribute("y2");
        const ctxGradient = canvas.getContext("2d").createLinearGradient(x06, y06, x12, y12);
        for (const stop of gradient.querySelectorAll("stop")) {
          const offset = +stop.getAttribute("offset");
          const color3 = resolveColor(stop.getAttribute("stop-color"), canvas);
          ctxGradient.addColorStop(Math.min(1, Math.max(0, offset)), color3);
        }
        return ctxGradient;
      }
    }
  }
  return color2;
}

// node_modules/svelteplot/dist/marks/helpers/AreaCanvas.svelte
AreaCanvas[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/AreaCanvas.svelte";
function AreaCanvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AreaCanvas);
  const plot = usePlot();
  function maybeOpacity(value) {
    return equals(value, null) ? 1 : +value;
  }
  const render = (canvas) => {
    const context = canvas.getContext("2d");
    user_effect(() => {
      if (context) {
        $$props.areaPath.context(context);
        context.resetTransform();
        context.scale(devicePixelRatio.current ?? 1, devicePixelRatio.current ?? 1);
        for (const group3 of $$props.groupedAreaData) {
          if (group3.length < 2) continue;
          const firstPoint = group3[0];
          if (!firstPoint || !firstPoint.valid) continue;
          let { fill: fill2, stroke, ...restStyles } = resolveScaledStyleProps(firstPoint.datum, $$props.mark.options, $$props.usedScales, plot, "fill");
          const opacity = maybeOpacity(restStyles["opacity"]);
          const fillOpacity = maybeOpacity(restStyles["fill-opacity"]);
          const strokeOpacity = maybeOpacity(restStyles["stroke-opacity"]);
          const strokeWidth = resolveProp($$props.mark.options.strokeWidth, firstPoint.datum, 0);
          fill2 = resolveColor(fill2 || "currentColor", canvas);
          stroke = resolveColor(stroke, canvas);
          context.beginPath();
          $$props.areaPath(group3);
          if (fill2 && strict_equals(fill2, "none", false)) {
            context.fillStyle = fill2;
            context.globalAlpha = opacity * fillOpacity;
            context.fill();
          }
          if (stroke && strict_equals(stroke, "none", false) && strokeWidth > 0) {
            context.strokeStyle = stroke;
            context.lineWidth = strokeWidth;
            context.globalAlpha = opacity * strokeOpacity;
            context.stroke();
          }
        }
        $$props.areaPath.context(null);
      }
      return () => {
        context?.clearRect(0, 0, plot.width * (devicePixelRatio.current ?? 1), plot.height * (devicePixelRatio.current ?? 1));
      };
    });
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => CanvasLayer_default(node, { [createAttachmentKey()]: render }), "component", AreaCanvas, 105, 0, { componentTag: "CanvasLayer" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  AreaCanvas = hmr(AreaCanvas);
  import.meta.hot.accept((module) => {
    AreaCanvas[HMR].update(module.default);
  });
}
var AreaCanvas_default = AreaCanvas;

// node_modules/svelteplot/dist/marks/Area.svelte
Area[FILENAME] = "node_modules/svelteplot/dist/marks/Area.svelte";
var root_83 = add_locations(from_svg(`<title> </title>`), Area[FILENAME], [[150, 44]]);
var root_72 = add_locations(from_svg(`<path><!></path>`), Area[FILENAME], [[136, 28]]);
function Area($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Area);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    fill: "currentColor",
    curve: "linear",
    tension: 0,
    ...getPlotDefaults().area
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), curve = tag(user_derived(() => fallback(get($$d).curve, "linear")), "curve"), tension = tag(user_derived(() => fallback(get($$d).tension, 0)), "tension"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), areaClass = tag(user_derived(() => get($$d).areaClass), "areaClass"), canvas = tag(user_derived(() => fallback(get($$d).canvas, false)), "canvas"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "curve", "tension", "class", "areaClass", "canvas"])), "options");
  const plot = usePlot();
  const groupByKey = tag(user_derived(() => get(options).z || get(options).fill || get(options).stroke), "groupByKey");
  const areaPath = tag(
    user_derived(() => callWithProps_default(area_default, [], {
      curve: maybeCurve(get(curve), get(tension)),
      defined: (d) => equals(get(options).x1, null, false) && equals(get(options).x2, null, false) ? (
        // vertical
        isValid(d.y1) && isValid(d.x1) && isValid(d.x2)
      ) : (
        // horizontal
        isValid(d.x1) && isValid(d.y1) && isValid(d.y2)
      ),
      ...equals(get(options).x1, null, false) && equals(get(options).x2, null, false) ? {
        // "vertical" area
        x0: (d) => d.x1,
        x1: (d) => d.x2,
        y: (d) => d.y1
      } : {
        // "horizontal" area
        x: (d) => d.x1,
        y0: (d) => d.y1,
        y1: (d) => d.y2
      }
    })),
    "areaPath"
  );
  function groupAndSort(data2) {
    const groups2 = get(groupByKey) ? groups(data2, (d) => resolveProp(get(groupByKey), d.datum)).map((d) => d[1]) : [data2];
    if (get(options).sort) {
      return groups2.toSorted((a2, b) => resolveChannel("sort", a2[0].datum, get(options)) > resolveChannel("sort", b[0].datum, get(options)) ? 1 : -1);
    }
    return groups2;
  }
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Area, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      const grouped = tag(user_derived(() => groupAndSort(scaledData())), "grouped");
      get(grouped);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => AreaCanvas_default(node_2, {
              get groupedAreaData() {
                return get(grouped);
              },
              get mark() {
                return mark();
              },
              get usedScales() {
                return usedScales();
              },
              get areaPath() {
                return get(areaPath);
              }
            }),
            "component",
            Area,
            121,
            12,
            { componentTag: "AreaCanvas" }
          );
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(
            () => GroupMultiple_default(node_3, {
              get class() {
                return get(className);
              },
              get length() {
                return get(grouped).length;
              },
              children: wrap_snippet(Area, ($$anchor4, $$slotProps) => {
                var fragment_4 = comment();
                var node_4 = first_child(fragment_4);
                add_svelte_meta(
                  () => each(node_4, 17, () => get(grouped), index, ($$anchor5, areaData) => {
                    const datum = tag(user_derived(() => get(areaData)[0]), "datum");
                    get(datum);
                    var fragment_5 = comment();
                    var node_5 = first_child(fragment_5);
                    {
                      var consequent_2 = ($$anchor6) => {
                        var fragment_6 = comment();
                        var node_6 = first_child(fragment_6);
                        add_svelte_meta(
                          () => Anchor_default(node_6, {
                            get options() {
                              return get(options);
                            },
                            get datum() {
                              return get(datum);
                            },
                            children: wrap_snippet(Area, ($$anchor7, $$slotProps2) => {
                              const title = tag(user_derived(() => resolveProp(get(options).title, get(datum).datum, "")), "title");
                              get(title);
                              const computed_const = tag(
                                user_derived(() => {
                                  const [style, styleClass] = resolveStyles(plot, get(datum), get(options), "fill", usedScales());
                                  return { style, styleClass };
                                }),
                                "[@const]"
                              );
                              get(computed_const);
                              var path2 = root_72();
                              var node_7 = child(path2);
                              {
                                var consequent_1 = ($$anchor8) => {
                                  var title_1 = root_83();
                                  var text2 = child(title_1, true);
                                  reset(title_1);
                                  template_effect(() => set_text(text2, get(title)));
                                  append($$anchor8, title_1);
                                };
                                add_svelte_meta(
                                  () => if_block(node_7, ($$render) => {
                                    if (get(title)) $$render(consequent_1);
                                  }),
                                  "if",
                                  Area,
                                  150,
                                  33
                                );
                              }
                              reset(path2);
                              attach(path2, () => addEventHandlers({ plot, options: get(options), datum: get(datum)?.datum }));
                              template_effect(
                                ($0, $1) => {
                                  set_class(path2, 0, $0);
                                  set_attribute(path2, "clip-path", get(options).clipPath);
                                  set_attribute(path2, "d", $1);
                                  set_style(path2, get(computed_const).style);
                                },
                                [
                                  () => clsx([
                                    "area",
                                    resolveProp(get(areaClass), get(areaData)[0].datum),
                                    get(computed_const).styleClass
                                  ]),
                                  () => get(areaPath)(get(areaData))
                                ]
                              );
                              append($$anchor7, path2);
                            }),
                            $$slots: { default: true }
                          }),
                          "component",
                          Area,
                          127,
                          24,
                          { componentTag: "Anchor" }
                        );
                        append($$anchor6, fragment_6);
                      };
                      add_svelte_meta(
                        () => if_block(node_5, ($$render) => {
                          if (get(areaData).length > 0) $$render(consequent_2);
                        }),
                        "if",
                        Area,
                        126,
                        20
                      );
                    }
                    append($$anchor5, fragment_5);
                  }),
                  "each",
                  Area,
                  124,
                  16
                );
                append($$anchor4, fragment_4);
              }),
              $$slots: { default: true }
            }),
            "component",
            Area,
            123,
            12,
            { componentTag: "GroupMultiple" }
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (get(canvas)) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Area,
          120,
          8
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "area",
          get data() {
            return get(data);
          },
          channels: [
            "x1",
            "x2",
            "y1",
            "y2",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ],
          required: ["x1", "y1"]
        },
        () => markProps,
        () => get(options),
        { children, $$slots: { default: true } }
      )),
      "component",
      Area,
      111,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Area = hmr(Area);
  import.meta.hot.accept((module) => {
    Area[HMR].update(module.default);
  });
}
var Area_default = Area;

// node_modules/svelteplot/dist/transforms/filter.js
function filter2({ data, ...channels }) {
  return {
    data: data.filter((d) => testFilter(d, channels)),
    ...channels,
    filter: null
  };
}

// node_modules/svelteplot/dist/transforms/stack.js
var S = {
  x: /* @__PURE__ */ Symbol("x"),
  x1: /* @__PURE__ */ Symbol("x1"),
  x2: /* @__PURE__ */ Symbol("x2"),
  y: /* @__PURE__ */ Symbol("y"),
  y1: /* @__PURE__ */ Symbol("y1"),
  y2: /* @__PURE__ */ Symbol("y2")
};
var GROUP = /* @__PURE__ */ Symbol("group");
var FACET = /* @__PURE__ */ Symbol("facet");
var DEFAULT_STACK_OPTIONS = {
  order: null,
  offset: null,
  reverse: false
};
var STACK_ORDER = {
  // null
  // TODO: value: ,
  none: none_default2,
  sum: ascending_default,
  appearance: appearance_default,
  "inside-out": insideOut_default
};
var STACK_OFFSET = {
  none: null,
  diverging: diverging_default,
  wiggle: wiggle_default,
  center: silhouette_default,
  normalize: expand_default
};
function stackXY(byDim, data, channels, options) {
  if (options === false) {
    return { data, ...channels };
  }
  const groupFacetsBy = [
    channels.fx != null ? "fx" : null,
    channels.fy != null ? "fy" : null
  ].filter((d) => d !== null);
  const groupBy2 = channels.z ? "z" : channels.fill ? "fill" : channels.stroke ? "stroke" : true;
  const secondDim = byDim === "x" ? channels.y1 != null ? "y1" : "y" : channels.x1 != null ? "x1" : "x";
  const byLow = `${byDim}1`;
  const byHigh = `${byDim}2`;
  if (channels[byDim] != null && channels[`${byLow}`] === void 0 && channels[`${byHigh}`] === void 0) {
    const resolvedData = indexData(data).map((d, i) => ({
      ...isDataRecord_default(d) ? d : { [RAW_VALUE]: d },
      [S[secondDim]]: resolveChannel(secondDim, d, channels),
      [GROUP]: groupBy2 === true ? "G" : resolveChannel(groupBy2, d, channels),
      [FACET]: groupFacetsBy.length > 0 ? groupFacetsBy.map((channel) => String(resolveChannel(channel, d, channels))).join("---") : "F",
      [S[byDim]]: resolveChannel(byDim, d, channels)
    }));
    const out = [];
    const groups2 = groups(resolvedData, (d) => d[FACET]);
    for (const [, facetData] of groups2) {
      let keys;
      const groupedBySecondDim = groups(facetData, (d) => d[S[secondDim]]);
      let stackData;
      const hasUniqueGroups = groupBy2 !== true && groupedBySecondDim.every(([, items]) => {
        const groupSet = new Set(items.map((d) => d[GROUP]));
        return groupSet.size === items.length;
      });
      if (groupBy2 === true || !hasUniqueGroups) {
        let maxKeys = 0;
        stackData = groupedBySecondDim.map(([k2, items]) => {
          const values = items.map((d) => ({ i: d[INDEX], v: d[S[byDim]] }));
          if (values.length > maxKeys)
            maxKeys = values.length;
          return values;
        });
        keys = range(maxKeys);
      } else {
        const keySet = new Set(facetData.map((d) => d[GROUP]));
        stackData = groupedBySecondDim.map(([k2, items]) => {
          const obj = {};
          items.forEach((d) => {
            const key2 = d[GROUP];
            if (obj[key2] == null)
              obj[key2] = { i: d[INDEX], v: d[S[byDim]] };
            else
              obj[key2] = {
                i: d[INDEX],
                v: obj[key2].v + d[S[byDim]]
              };
          });
          return obj;
        });
        keys = Array.from(keySet);
      }
      const stackOrder = (series2) => {
        const f = STACK_ORDER[options.order || "none"];
        return options.reverse ? f(series2).reverse() : f(series2);
      };
      const series = stack_default().order(stackOrder).offset(groupBy2 === true && options.offset === "wiggle" ? STACK_OFFSET["center"] : STACK_OFFSET[options.offset]).keys(keys).value((d, key2, i, data2) => {
        return d[key2]?.v == null ? void 0 : d[key2]?.v;
      })(stackData);
      const newData = series.flatMap((s2) => s2.map((d) => [d[0], d[1], d.data[s2.key]?.i])).filter((d) => d[2] !== void 0).map((d) => ({ [S[byLow]]: d[0], [S[byHigh]]: d[1], ...resolvedData[d[2]] }));
      out.push(...newData);
    }
    return {
      data: out.sort((a2, b) => a2[INDEX] - b[INDEX]),
      ...channels,
      [byDim]: void 0,
      ...typeof channels[byDim] === "string" && !channels[ORIGINAL_NAME_KEYS[byDim]] ? { [ORIGINAL_NAME_KEYS[byDim]]: channels[byDim] } : {},
      ...{ [byLow]: S[byLow], [byHigh]: S[byHigh] }
    };
  }
  return { data, ...channels };
}
function stackY({ data, ...channels }, opts = {}) {
  return stackXY("y", data, channels, applyDefaults(opts));
}
function stackX({ data, ...channels }, opts = {}) {
  return stackXY("x", data, channels, applyDefaults(opts));
}
function applyDefaults(opts) {
  if (opts === false)
    return false;
  if (opts.offset === "wiggle" && opts.order === void 0) {
    return { ...DEFAULT_STACK_OPTIONS, order: "inside-out", ...opts };
  }
  return { ...DEFAULT_STACK_OPTIONS, ...opts };
}
function stackMosaic({ data, x: x2, y: y2, value, fx, fy, ...rest2 }, { outer, inner }, { x: xOpt, y: yOpt } = {}) {
  const out = [];
  const { data: filtered, ...restArgs } = sort2(filter2({ data, x: x2, y: y2, value, fx, fy, ...rest2 }));
  if (!filtered)
    throw new Error("stackMosaic: missing data");
  if (!x2)
    throw new Error("stackMosaic: missing x channel");
  if (!y2)
    throw new Error("stackMosaic: missing y channel");
  if (!value)
    throw new Error("stackMosaic: missing value channel");
  if (min(filtered, (d) => resolveProp(d[value], d)) < 0)
    throw new Error("stackMosaic: negative values not supported");
  groupFacetsAndZ(filtered, restArgs, (data2) => {
    const total = sum(data2, (d) => resolveProp(d[value], d));
    let outerPos = 0;
    const outerChannel = outer === "x" ? x2 : y2;
    const innerChannel = inner === "x" ? x2 : y2;
    const outerSym1 = outer === "x" ? S.x1 : S.y1;
    const outerSym2 = outer === "x" ? S.x2 : S.y2;
    const innerSym1 = inner === "x" ? S.x1 : S.y1;
    const innerSym2 = inner === "x" ? S.x2 : S.y2;
    const outerOpt = outer === "x" ? xOpt : yOpt;
    const innerOpt = inner === "x" ? xOpt : yOpt;
    const grouped = groups(data2, (d) => resolveProp(d[outerChannel], d));
    const innerOrder = new Map(grouped[0][1].map((d, i) => [d[innerChannel], i]));
    grouped.forEach(([k2, items], i) => {
      const groupValue = sum(items, (d) => resolveProp(d[value], d));
      const o1 = outerPos, o2 = outerPos + groupValue;
      outerPos = o2;
      let innerPos = 0;
      (i ? items.sort((a2, b) => innerOrder.get(a2[innerChannel]) - innerOrder.get(b[innerChannel])) : items).forEach((d) => {
        const iv = resolveProp(d[value], d);
        const i1 = innerPos, i2 = innerPos + iv;
        innerPos = i2;
        const normO1 = outerOpt?.percent ? o1 / total : o1;
        const normO2 = outerOpt?.percent ? o2 / total : o2;
        const normI1 = innerOpt?.percent ? i1 / groupValue : i1;
        const normI2 = innerOpt?.percent ? i2 / groupValue : i2;
        const result = { ...d };
        result[outerSym1] = normO1;
        result[outerSym2] = normO2;
        result[innerSym1] = normI1;
        result[innerSym2] = normI2;
        result[S.x] = (result[S.x1] + result[S.x2]) / 2;
        result[S.y] = (result[S.y1] + result[S.y2]) / 2;
        out.push(result);
      });
    });
  });
  return {
    ...rest2,
    fx,
    fy,
    data: out,
    x: S.x,
    x1: S.x1,
    x2: S.x2,
    y: S.y,
    y1: S.y1,
    y2: S.y2
  };
}
function stackMosaicX(args, opts) {
  return stackMosaic(args, { outer: "x", inner: "y" }, opts);
}
function stackMosaicY(args, opts) {
  return stackMosaic(args, { outer: "y", inner: "x" }, opts);
}

// node_modules/svelteplot/dist/marks/AreaX.svelte
AreaX[FILENAME] = "node_modules/svelteplot/dist/marks/AreaX.svelte";
function AreaX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AreaX);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = getPlotDefaults().areaX;
  const $$d = user_derived(() => ({
    ...equals($$props.x, void 0) ? { x1: 0, x2: 0 } : {},
    ...DEFAULTS,
    ...markProps
  })), data = tag(user_derived(() => get($$d).data), "data"), stack = tag(user_derived(() => get($$d).stack), "stack"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "stack"])), "options");
  const args = tag(user_derived(() => renameChannels(stackX(recordizeX({ data: get(data), ...get(options), y1: null, y2: null }), get(stack)), { y: "y1" })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Area_default(node, spread_props(() => get(args))), "component", AreaX, 36, 0, { componentTag: "Area" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  AreaX = hmr(AreaX);
  import.meta.hot.accept((module) => {
    AreaX[HMR].update(module.default);
  });
}
var AreaX_default = AreaX;

// node_modules/svelteplot/dist/marks/AreaY.svelte
AreaY[FILENAME] = "node_modules/svelteplot/dist/marks/AreaY.svelte";
function AreaY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, AreaY);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = getPlotDefaults().areaY;
  const $$d = user_derived(() => ({
    ...equals($$props.y, void 0) ? { y1: 0, y2: 0 } : {},
    ...DEFAULTS,
    ...markProps
  })), data = tag(user_derived(() => get($$d).data), "data"), stack = tag(user_derived(() => get($$d).stack), "stack"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "stack"])), "options");
  const args = tag(user_derived(() => renameChannels(stackY(recordizeY({ data: get(data), ...get(options), x1: null, x2: null }), get(stack)), { x: "x1" })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Area_default(node, spread_props(() => get(args))), "component", AreaY, 35, 0, { componentTag: "Area" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  AreaY = hmr(AreaY);
  import.meta.hot.accept((module) => {
    AreaY[HMR].update(module.default);
  });
}
var AreaY_default = AreaY;

// node_modules/svelteplot/dist/helpers/arrowPath.js
var RADIANS = Math.PI / 180;
function arrowPath(x12, y12, x2, y2, insetStart, insetEnd, headAngle, headLength, bend, strokeWidth, sweep) {
  const wingAngle = headAngle * RADIANS / 2;
  const wingScale = headLength / 1.5;
  const lineLength = Math.hypot(x2 - x12, y2 - y12);
  if (lineLength <= insetStart + insetEnd)
    return null;
  let lineAngle = Math.atan2(y2 - y12, x2 - x12);
  const headLength_ = Math.min(wingScale * strokeWidth, lineLength / 3);
  const bendAngle = sweep(x12, y12, x2, y2) * bend * RADIANS;
  const r = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
  if (insetStart || insetEnd) {
    if (r < 1e5) {
      const sign3 = Math.sign(bendAngle);
      const [cx, cy] = pointPointCenter([x12, y12], [x2, y2], r, sign3);
      if (insetStart) {
        [x12, y12] = circleCircleIntersect([cx, cy, r], [x12, y12, insetStart], -sign3 * Math.sign(insetStart));
      }
      if (insetEnd) {
        const [x5, y5] = circleCircleIntersect([cx, cy, r], [x2, y2, insetEnd], sign3 * Math.sign(insetEnd));
        lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y2 - cy, x2 - cx);
        x2 = x5, y2 = y5;
      }
    } else {
      const dx = x2 - x12, dy = y2 - y12, d = Math.hypot(dx, dy);
      if (insetStart)
        x12 += dx / d * insetStart, y12 += dy / d * insetStart;
      if (insetEnd)
        x2 -= dx / d * insetEnd, y2 -= dy / d * insetEnd;
    }
  }
  const endAngle = lineAngle + bendAngle;
  const leftAngle = endAngle + wingAngle;
  const rightAngle = endAngle - wingAngle;
  const x3 = x2 - headLength_ * Math.cos(leftAngle);
  const y3 = y2 - headLength_ * Math.sin(leftAngle);
  const x4 = x2 - headLength_ * Math.cos(rightAngle);
  const y4 = y2 - headLength_ * Math.sin(rightAngle);
  const a2 = r < 1e5 ? `A${r},${r} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;
  const h = headLength_ ? `M${x3},${y3}L${x2},${y2}L${x4},${y4}` : "";
  return `M${x12},${y12}${a2}${x2},${y2}${h}`;
}
function pointPointCenter([ax, ay], [bx, by], r, sign3) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const k2 = sign3 * Math.sqrt(r * r - d * d / 4) / d;
  return [(ax + bx) / 2 - dy * k2, (ay + by) / 2 + dx * k2];
}
function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign3) {
  const dx = bx - ax, dy = by - ay, d = Math.hypot(dx, dy);
  const x2 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d);
  const y2 = sign3 * Math.sqrt(ar * ar - x2 * x2);
  return [ax + (dx * x2 + dy * y2) / d, ay + (dy * x2 - dx * y2) / d];
}
function constant3(x2) {
  return () => x2;
}
function keyword(input, name, allowed) {
  const i = `${input}`.toLowerCase();
  if (!allowed.includes(i))
    throw new Error(`invalid ${name}: ${input}`);
  return i;
}
function maybeSweep(sweep = 1) {
  if (typeof sweep === "number")
    return constant3(Math.sign(sweep));
  if (typeof sweep === "function")
    return (x12, y12, x2, y2) => Math.sign(sweep(x12, y12, x2, y2));
  switch (keyword(sweep, "sweep", ["+x", "-x", "+y", "-y"])) {
    case "+x":
      return (x12, y12, x2) => ascending(x12, x2);
    case "-x":
      return (x12, y12, x2) => descending(x12, x2);
    case "+y":
      return (x12, y12, x2, y2) => ascending(y12, y2);
    case "-y":
      return (x12, y12, x2, y2) => descending(y12, y2);
  }
}

// node_modules/svelteplot/dist/marks/Arrow.svelte
Arrow[FILENAME] = "node_modules/svelteplot/dist/marks/Arrow.svelte";
var root_53 = add_locations(from_svg(`<path></path>`), Arrow[FILENAME], [[141, 28]]);
var root_44 = add_locations(from_svg(`<g><!><path></path></g>`), Arrow[FILENAME], [[132, 20, [[146, 24]]]]);
function Arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    headAngle: 60,
    headLength: 8,
    inset: 0,
    ...getPlotDefaults().arrow
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  const plot = usePlot();
  const args = tag(user_derived(() => sort2(replaceChannels({ data: indexData(get(data)), ...get(options) }, { y: ["y1", "y2"], x: ["x1", "x2"] }))), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Arrow, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      const sweep = tag(user_derived(() => maybeSweep(get(args).sweep)), "sweep");
      get(sweep);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => GroupMultiple_default(node_1, {
          class: "arrow",
          get length() {
            return scaledData().length;
          },
          children: wrap_snippet(Arrow, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(
              () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                {
                  var consequent_1 = ($$anchor5) => {
                    const inset = tag(user_derived(() => resolveProp(get(args).inset, get(d).datum, 0)), "inset");
                    get(inset);
                    const insetStart = tag(user_derived(() => resolveProp(get(args).insetStart, get(d).datum)), "insetStart");
                    get(insetStart);
                    const insetEnd = tag(user_derived(() => resolveProp(get(args).insetEnd, get(d).datum)), "insetEnd");
                    get(insetEnd);
                    const headAngle = tag(user_derived(() => resolveProp(get(args).headAngle, get(d).datum)), "headAngle");
                    get(headAngle);
                    const headLength = tag(user_derived(() => resolveProp(get(args).headLength, get(d).datum)), "headLength");
                    get(headLength);
                    const bend = tag(user_derived(() => resolveProp(get(args).bend, get(d).datum, 0)), "bend");
                    get(bend);
                    const strokeWidth = tag(user_derived(() => resolveProp(get(args).strokeWidth, get(d).datum, 1)), "strokeWidth");
                    get(strokeWidth);
                    const arrPath = tag(
                      user_derived(() => arrowPath(
                        get(d).x1,
                        get(d).y1,
                        get(d).x2,
                        get(d).y2,
                        maybeNumber(coalesce(get(insetStart), get(inset))),
                        maybeNumber(coalesce(get(insetEnd), get(inset))),
                        get(headAngle),
                        get(headLength),
                        strict_equals(get(bend), true) ? 22.5 : strict_equals(get(bend), false) ? 0 : get(bend),
                        get(strokeWidth),
                        get(sweep)
                      )),
                      "arrPath"
                    );
                    get(arrPath);
                    const computed_const = tag(
                      user_derived(() => {
                        const [style, styleClass] = resolveStyles(
                          plot,
                          get(d),
                          {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            ...get(args),
                            strokeWidth: get(strokeWidth) ?? 1.6
                          },
                          "stroke",
                          usedScales()
                        );
                        return { style, styleClass };
                      }),
                      "[@const]"
                    );
                    get(computed_const);
                    var g = root_44();
                    var node_4 = child(g);
                    {
                      var consequent = ($$anchor6) => {
                        var path2 = root_53();
                        template_effect(() => {
                          set_attribute(path2, "d", get(arrPath));
                          set_style(path2, `fill:none;stroke-width: ${(get(strokeWidth) || 1) + 10}; stroke: red; stroke-opacity:0`);
                        });
                        append($$anchor6, path2);
                      };
                      add_svelte_meta(
                        () => if_block(node_4, ($$render) => {
                          if (get(options).onmouseenter || get(options).onclick) $$render(consequent);
                        }),
                        "if",
                        Arrow,
                        139,
                        24
                      );
                    }
                    var path_1 = sibling(node_4);
                    reset(g);
                    attach(g, () => addEventHandlers({ plot, options: get(options), datum: get(d)?.datum }));
                    template_effect(() => {
                      set_class(g, 0, clsx([get(className)]));
                      set_class(path_1, 0, clsx([get(computed_const).styleClass]));
                      set_attribute(path_1, "d", get(arrPath));
                      set_style(path_1, get(computed_const).style);
                    });
                    append($$anchor5, g);
                  };
                  add_svelte_meta(
                    () => if_block(node_3, ($$render) => {
                      if (get(d).valid) $$render(consequent_1);
                    }),
                    "if",
                    Arrow,
                    99,
                    16
                  );
                }
                append($$anchor4, fragment_3);
              }),
              "each",
              Arrow,
              98,
              12
            );
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        Arrow,
        97,
        8,
        { componentTag: "GroupMultiple" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "arrow",
          required: ["x1", "x2", "y1", "y2"],
          channels: ["x1", "y1", "x2", "y2", "opacity", "stroke", "strokeOpacity"]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Arrow,
      90,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Arrow = hmr(Arrow);
  import.meta.hot.accept((module) => {
    Arrow[HMR].update(module.default);
  });
}
var Arrow_default = Arrow;

// node_modules/svelteplot/dist/marks/BarX.svelte
BarX[FILENAME] = "node_modules/svelteplot/dist/marks/BarX.svelte";
function BarX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BarX);
  const DEFAULTS = {
    fill: "currentColor",
    ...getPlotDefaults().bar,
    ...getPlotDefaults().barX
  };
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, null)), "className"), stack = tag(user_derived(() => get($$d).stack), "stack"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class", "stack"])), "options");
  const plot = usePlot();
  const args = tag(
    user_derived(() => stackX(
      intervalX(
        // by default, sort by y channel (the ordinal labels)
        sort2(recordizeX({ data: get(data), ...get(options) })),
        { plot }
      ),
      get(stack)
    )),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(BarX, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => GroupMultiple_default(node_1, {
          class: "bar-x",
          get length() {
            return scaledData().length;
          },
          children: wrap_snippet(BarX, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(
              () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                const bw = tag(user_derived(() => plot.scales.y.fn.bandwidth()), "bw");
                get(bw);
                const minx = tag(user_derived(() => Math.min(get(d).x1, get(d).x2)), "minx");
                get(minx);
                const maxx = tag(user_derived(() => Math.max(get(d).x1, get(d).x2)), "maxx");
                get(maxx);
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                {
                  var consequent = ($$anchor5) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    {
                      let $0 = user_derived(() => get(d).y - get(bw) * 0.5);
                      let $1 = user_derived(() => get(maxx) - get(minx));
                      add_svelte_meta(
                        () => RectPath_default(node_4, {
                          get usedScales() {
                            return usedScales();
                          },
                          get class() {
                            return get(className);
                          },
                          get options() {
                            return get(options);
                          },
                          get datum() {
                            return get(d);
                          },
                          get x() {
                            return get(minx);
                          },
                          useInsetAsFallbackHorizontally: false,
                          get y() {
                            return get($0);
                          },
                          get width() {
                            return get($1);
                          },
                          get height() {
                            return get(bw);
                          }
                        }),
                        "component",
                        BarX,
                        78,
                        20,
                        { componentTag: "RectPath" }
                      );
                    }
                    append($$anchor5, fragment_4);
                  };
                  add_svelte_meta(
                    () => if_block(node_3, ($$render) => {
                      if (get(d).valid) $$render(consequent);
                    }),
                    "if",
                    BarX,
                    77,
                    16
                  );
                }
                append($$anchor4, fragment_3);
              }),
              "each",
              BarX,
              73,
              12
            );
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        BarX,
        72,
        8,
        { componentTag: "GroupMultiple" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "barX",
          requiredScales: { y: ["band"] },
          channels: [
            "x1",
            "x2",
            "y",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      BarX,
      66,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BarX = hmr(BarX);
  import.meta.hot.accept((module) => {
    BarX[HMR].update(module.default);
  });
}
var BarX_default = BarX;

// node_modules/svelteplot/dist/marks/BarY.svelte
BarY[FILENAME] = "node_modules/svelteplot/dist/marks/BarY.svelte";
function BarY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BarY);
  const plot = usePlot();
  const DEFAULTS = { ...getPlotDefaults().bar, ...getPlotDefaults().barY };
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, null)), "className"), stack = tag(user_derived(() => get($$d).stack), "stack"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class", "stack"])), "options");
  const args = tag(
    user_derived(() => stackY(
      intervalY(
        // by default, sort by x channel (the ordinal labels)
        sort2(recordizeY({ data: get(data), ...get(options) })),
        { plot }
      ),
      get(stack)
    )),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(BarY, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => GroupMultiple_default(node_1, {
          class: "bar-y",
          get length() {
            return scaledData().length;
          },
          children: wrap_snippet(BarY, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(
              () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                const bw = tag(user_derived(() => plot.scales.x.fn.bandwidth()), "bw");
                get(bw);
                const miny = tag(user_derived(() => Math.min(get(d).y1, get(d).y2)), "miny");
                get(miny);
                const maxy = tag(user_derived(() => Math.max(get(d).y1, get(d).y2)), "maxy");
                get(maxy);
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                {
                  var consequent = ($$anchor5) => {
                    var fragment_4 = comment();
                    var node_4 = first_child(fragment_4);
                    {
                      let $0 = user_derived(() => get(d).x - get(bw) * 0.5);
                      let $1 = user_derived(() => get(maxy) - get(miny));
                      add_svelte_meta(
                        () => RectPath_default(node_4, {
                          get x() {
                            return get($0);
                          },
                          get y() {
                            return get(miny);
                          },
                          get options() {
                            return get(args);
                          },
                          get class() {
                            return get(className);
                          },
                          get width() {
                            return get(bw);
                          },
                          get height() {
                            return get($1);
                          },
                          get datum() {
                            return get(d);
                          },
                          get usedScales() {
                            return usedScales();
                          },
                          useInsetAsFallbackVertically: false
                        }),
                        "component",
                        BarY,
                        78,
                        20,
                        { componentTag: "RectPath" }
                      );
                    }
                    append($$anchor5, fragment_4);
                  };
                  add_svelte_meta(
                    () => if_block(node_3, ($$render) => {
                      if (get(d).valid) $$render(consequent);
                    }),
                    "if",
                    BarY,
                    77,
                    16
                  );
                }
                append($$anchor4, fragment_3);
              }),
              "each",
              BarY,
              73,
              12
            );
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        BarY,
        72,
        8,
        { componentTag: "GroupMultiple" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "barY",
          requiredScales: { x: ["band"] },
          channels: [
            "x",
            "y1",
            "y2",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      BarY,
      66,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BarY = hmr(BarY);
  import.meta.hot.accept((module) => {
    BarY[HMR].update(module.default);
  });
}
var BarY_default = BarY;

// node_modules/svelteplot/dist/marks/BollingerX.svelte
BollingerX[FILENAME] = "node_modules/svelteplot/dist/marks/BollingerX.svelte";
var root6 = add_locations(from_svg(`<g><!><!></g>`), BollingerX[FILENAME], [[42, 0]]);
function BollingerX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BollingerX);
  let className = prop($$props, "class", 3, null), n = prop($$props, "n", 3, 20), k2 = prop($$props, "k", 3, 2), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data", "class", "n", "k"], "options");
  let args = tag(user_derived(() => bollingerX(recordizeX({ data: $$props.data, ...options }), { n: n(), k: k2() })), "args");
  var $$exports = { ...legacy_api() };
  var g = root6();
  var node = child(g);
  {
    let $0 = user_derived(() => ({
      x: "__avg",
      y: "__x",
      ...pick(get(args), ["data", "stroke", "strokeOpacity", "opacity"])
    }));
    add_svelte_meta(() => Line_default(node, spread_props(() => get($0))), "component", BollingerX, 43, 4, { componentTag: "Line" });
  }
  var node_1 = sibling(node);
  {
    let $0 = user_derived(() => ({
      y1: "__x",
      x1: "__lo",
      x2: "__hi",
      ...pick(get(args), ["data", "fill", "fillOpacity", "opacity"]),
      fillOpacity: 0.2
    }));
    add_svelte_meta(() => Area_default(node_1, spread_props(() => get($0))), "component", BollingerX, 49, 4, { componentTag: "Area" });
  }
  reset(g);
  template_effect(() => set_class(g, 0, `bollinger ${(className() || "") ?? ""}`));
  append($$anchor, g);
  return pop($$exports);
}
if (import.meta.hot) {
  BollingerX = hmr(BollingerX);
  import.meta.hot.accept((module) => {
    BollingerX[HMR].update(module.default);
  });
}
var BollingerX_default = BollingerX;

// node_modules/svelteplot/dist/marks/BollingerY.svelte
BollingerY[FILENAME] = "node_modules/svelteplot/dist/marks/BollingerY.svelte";
var root7 = add_locations(from_svg(`<g><!><!></g>`), BollingerY[FILENAME], [[36, 0]]);
function BollingerY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BollingerY);
  let n = prop($$props, "n", 3, 20), k2 = prop($$props, "k", 3, 2), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data", "n", "k", "class"], "options");
  const args = tag(user_derived(() => bollingerY(recordizeY({ data: $$props.data, ...options }), { n: n(), k: k2() })), "args");
  var $$exports = { ...legacy_api() };
  var g = root7();
  var node = child(g);
  {
    let $0 = user_derived(() => pick(get(args), ["x", "y", "data", "stroke", "strokeOpacity", "opacity"]));
    add_svelte_meta(() => Line_default(node, spread_props(() => get($0))), "component", BollingerY, 37, 4, { componentTag: "Line" });
  }
  var node_1 = sibling(node);
  {
    let $0 = user_derived(() => ({
      x1: "__x",
      y1: "__lo",
      y2: "__hi",
      ...pick(get(args), ["data", "fill", "fillOpacity", "opacity"]),
      fillOpacity: 0.2
    }));
    add_svelte_meta(() => Area_default(node_1, spread_props(() => get($0))), "component", BollingerY, 38, 4, { componentTag: "Area" });
  }
  reset(g);
  template_effect(() => set_class(g, 0, `bollinger ${($$props.class || "") ?? ""}`));
  append($$anchor, g);
  return pop($$exports);
}
if (import.meta.hot) {
  BollingerY = hmr(BollingerY);
  import.meta.hot.accept((module) => {
    BollingerY[HMR].update(module.default);
  });
}
var BollingerY_default = BollingerY;

// node_modules/svelteplot/dist/marks/helpers/Box.svelte
Box[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/Box.svelte";
var root_37 = add_locations(from_html(`<!> <!>`, 1), Box[FILENAME], []);
var root_113 = add_locations(from_html(`<!> <!> <!> <!> <!> <!>`, 1), Box[FILENAME], []);
function Box($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Box);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const data = tag(user_derived(() => fallback($$props.data, () => [{}], true)), "data"), bar = tag(user_derived(() => $$props.bar), "bar"), rule = tag(user_derived(() => $$props.rule), "rule"), tickMedian = tag(user_derived(() => $$props.tickMedian), "tickMedian"), tickMinMax = tag(user_derived(() => $$props.tickMinMax), "tickMinMax"), dot = tag(user_derived(() => $$props.dot), "dot"), x2 = tag(user_derived(() => $$props.x), "x"), y2 = tag(user_derived(() => $$props.y), "y"), sort3 = tag(user_derived(() => $$props.sort), "sort"), fx = tag(user_derived(() => $$props.fx), "fx"), fy = tag(user_derived(() => $$props.fy), "fy"), fill2 = tag(user_derived(() => $$props.fill), "fill"), stroke = tag(user_derived(() => $$props.stroke), "stroke"), orientation = tag(user_derived(() => $$props.orientation), "orientation"), className = tag(user_derived(() => fallback($$props.class, "")), "className");
  const groupFn = tag(user_derived(() => strict_equals(get(orientation), "y") ? groupX : groupY), "groupFn");
  const BarMark = tag(user_derived(() => strict_equals(get(orientation), "y") ? BarY_default : BarX_default), "BarMark");
  const RuleMark = tag(user_derived(() => strict_equals(get(orientation), "y") ? RuleX_default : RuleY_default), "RuleMark");
  const TickMark = tag(user_derived(() => strict_equals(get(orientation), "y") ? TickY_default : TickX_default), "TickMark");
  const xChannel = tag(user_derived(() => strict_equals(get(orientation), "y") ? get(y2) : get(x2)), "xChannel");
  const yChannel = tag(user_derived(() => strict_equals(get(orientation), "y") ? get(x2) : get(y2)), "yChannel");
  const xProp = tag(user_derived(() => strict_equals(get(orientation), "x") ? "x" : "y"), "xProp");
  const x1Prop = tag(user_derived(() => `${get(xProp)}1`), "x1Prop");
  const x2Prop = tag(user_derived(() => `${get(xProp)}2`), "x2Prop");
  const yProp = tag(user_derived(() => strict_equals(get(orientation), "x") ? "y" : "x"), "yProp");
  const $$d = user_derived(() => get(groupFn)(
    {
      data: get(data).filter((d) => equals(resolveChannel(get(xProp), d, { x: get(x2), y: get(y2) }), null, false)),
      x: get(x2),
      y: get(y2),
      [get(x1Prop)]: get(xChannel),
      [get(x2Prop)]: get(xChannel),
      fx: get(fx),
      fy: get(fy)
    },
    {
      [get(xProp)]: "median",
      [get(x1Prop)]: "p25",
      [get(x2Prop)]: "p75",
      fill: (rows) => rows
    }
  )), grouped = tag(user_derived(() => get($$d).data), "grouped"), groupChannels = tag(user_derived(() => exclude_from_object(get($$d), ["data"])), "groupChannels");
  const X3 = /* @__PURE__ */ Symbol("x");
  const Y3 = /* @__PURE__ */ Symbol("y");
  const FX = /* @__PURE__ */ Symbol("fx");
  const FY = /* @__PURE__ */ Symbol("fy");
  const P25 = /* @__PURE__ */ Symbol("p25");
  const P75 = /* @__PURE__ */ Symbol("p75");
  const MEDIAN = /* @__PURE__ */ Symbol("median");
  const MIN = /* @__PURE__ */ Symbol("min");
  const MAX = /* @__PURE__ */ Symbol("max");
  const OUTLIERS = /* @__PURE__ */ Symbol("outliers");
  const SORT_REF = /* @__PURE__ */ Symbol("sortRef");
  const facets = tag(
    user_derived(() => ({
      ...equals(get(fx), null, false) && { fx: FX },
      ...equals(get(fy), null, false) && { fy: FY }
    })),
    "facets"
  );
  const sortProps = { [IS_SORTED]: true };
  const compareValues2 = (a2, b) => (strict_equals(typeof a2, "string") && strict_equals(typeof b, "string") ? a2.localeCompare(b) : a2 > b ? 1 : a2 < b ? -1 : 0) || 0;
  const boxData = tag(
    user_derived(() => {
      const boxes = get(grouped).map((row) => {
        const medianKey = get(groupChannels)[get(xProp)];
        const p25Key = get(groupChannels)[get(x1Prop)];
        const p75Key = get(groupChannels)[get(x2Prop)];
        const groupKey = get(groupChannels)[get(yProp)];
        const iqr = row[p75Key] - row[p25Key];
        const whisker = iqr * 1.5;
        const lower = row[p25Key] - whisker;
        const upper = row[p75Key] + whisker;
        const data2 = row[get(groupChannels).fill].map((d) => ({
          ...d,
          [strict_equals(get(orientation), "y") ? Y3 : X3]: resolveChannel(get(xProp), d, { x: get(x2), y: get(y2) })
        }));
        const valueSym = strict_equals(get(orientation), "y") ? Y3 : X3;
        const groupSym = strict_equals(get(orientation), "y") ? X3 : Y3;
        const outliers = data2.filter((d) => d[valueSym] < lower || d[valueSym] > upper);
        const inside = data2.filter((d) => d[valueSym] >= lower && d[valueSym] <= upper).sort((a2, b) => a2[valueSym] - b[valueSym]);
        return {
          ...data2[0],
          [SORT_REF]: row[get(groupChannels).fill]?.[0],
          [groupSym]: row[groupKey],
          [P25]: row[p25Key],
          [MEDIAN]: row[medianKey],
          [P75]: row[p75Key],
          [MIN]: inside.length ? inside[0][valueSym] : null,
          [MAX]: inside.length ? inside.at(-1)[valueSym] : null,
          [FX]: resolveChannel("fx", data2[0], { fx: get(fx) }, null),
          [FY]: resolveChannel("fy", data2[0], { fy: get(fy) }, null),
          [OUTLIERS]: outliers
        };
      }).filter(Boolean);
      const stripSortRef = ({ [SORT_REF]: _, ...rest2 }) => rest2;
      if (!get(sort3)) return boxes.map(stripSortRef);
      const [sort_, direction] = maybeSort(get(sort3));
      const sortAccessor = strict_equals(typeof get(sort3), "function") ? (d) => get(sort3)(d[SORT_REF]) : (d) => {
        switch (sort_) {
          case "min":
            return d[MIN];
          case "max":
            return d[MAX];
          case "p25":
            return d[P25];
          case "p75":
            return d[P75];
          case "median":
          default:
            return d[MEDIAN];
        }
      };
      return boxes.toSorted((a2, b) => compareValues2(sortAccessor(a2), sortAccessor(b)) * direction * (strict_equals(get(orientation), "x") ? -1 : 1)).map(stripSortRef);
    }),
    "boxData"
  );
  function maybeSort(sort4) {
    if (strict_equals(typeof sort4, "string", false)) return [sort4, 1];
    if (sort4.startsWith("-")) {
      return [sort4.slice(1), -1];
    }
    return [sort4, 1];
  }
  const valueSymbol = tag(user_derived(() => strict_equals(get(orientation), "y") ? Y3 : X3), "valueSymbol");
  const groupSymbol = tag(user_derived(() => strict_equals(get(orientation), "y") ? X3 : Y3), "groupSymbol");
  const length = tag(user_derived(() => get(className) ? 2 : get(grouped).length), "length");
  const baseClass = tag(user_derived(() => `box-${get(orientation)} ${get(className) || ""}`), "baseClass");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => GroupMultiple_default(node, {
      get class() {
        return get(baseClass);
      },
      get length() {
        return get(length);
      },
      children: wrap_snippet(Box, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_113();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(
          () => component(node_1, () => get(RuleMark), ($$anchor3, RuleMark_1) => {
            RuleMark_1($$anchor3, spread_props(
              {
                get data() {
                  return get(boxData);
                }
              },
              () => ({
                [get(yProp)]: get(groupSymbol),
                [get(x1Prop)]: MIN,
                [get(x2Prop)]: P25
              }),
              {
                get stroke() {
                  return get(stroke);
                }
              },
              () => get(rule) || {},
              () => get(facets),
              () => sortProps
            ));
          }),
          "component",
          Box,
          217,
          4,
          { componentTag: "RuleMark" }
        );
        var node_2 = sibling(node_1, 2);
        add_svelte_meta(
          () => component(node_2, () => get(RuleMark), ($$anchor3, RuleMark_2) => {
            RuleMark_2($$anchor3, spread_props(
              {
                get data() {
                  return get(boxData);
                }
              },
              () => ({
                [get(yProp)]: get(groupSymbol),
                [get(x1Prop)]: P75,
                [get(x2Prop)]: MAX
              }),
              {
                get stroke() {
                  return get(stroke);
                }
              },
              () => get(rule) || {},
              () => get(facets)
            ));
          }),
          "component",
          Box,
          224,
          4,
          { componentTag: "RuleMark" }
        );
        var node_3 = sibling(node_2, 2);
        add_svelte_meta(
          () => component(node_3, () => get(BarMark), ($$anchor3, BarMark_1) => {
            BarMark_1($$anchor3, spread_props(
              {
                get data() {
                  return get(boxData);
                }
              },
              () => ({
                [get(yProp)]: get(groupSymbol),
                [get(x1Prop)]: P25,
                [get(x2Prop)]: P75
              }),
              {
                get fill() {
                  return get(fill2);
                },
                get stroke() {
                  return get(stroke);
                }
              },
              () => get(facets),
              () => get(bar) || {}
            ));
          }),
          "component",
          Box,
          230,
          4,
          { componentTag: "BarMark" }
        );
        var node_4 = sibling(node_3, 2);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_5 = first_child(fragment_2);
            add_svelte_meta(
              () => component(node_5, () => get(TickMark), ($$anchor4, TickMark_1) => {
                TickMark_1($$anchor4, spread_props(
                  {
                    get data() {
                      return get(boxData);
                    }
                  },
                  () => ({ [get(yProp)]: get(groupSymbol), [get(xProp)]: MEDIAN }),
                  () => get(facets),
                  {
                    get stroke() {
                      return get(stroke);
                    },
                    strokeWidth: 2
                  },
                  () => strict_equals(typeof get(tickMedian), "object") ? get(tickMedian) : {}
                ));
              }),
              "component",
              Box,
              238,
              8,
              { componentTag: "TickMark" }
            );
            append($$anchor3, fragment_2);
          };
          add_svelte_meta(
            () => if_block(node_4, ($$render) => {
              if (get(tickMedian)) $$render(consequent);
            }),
            "if",
            Box,
            237,
            4
          );
        }
        var node_6 = sibling(node_4, 2);
        {
          var consequent_1 = ($$anchor3) => {
            var fragment_3 = root_37();
            var node_7 = first_child(fragment_3);
            add_svelte_meta(
              () => component(node_7, () => get(TickMark), ($$anchor4, TickMark_2) => {
                TickMark_2($$anchor4, spread_props(
                  {
                    get data() {
                      return get(boxData);
                    }
                  },
                  () => ({ [get(yProp)]: get(groupSymbol), [get(xProp)]: MIN }),
                  {
                    get stroke() {
                      return get(stroke);
                    }
                  },
                  () => get(facets),
                  { inset: "20%" },
                  () => strict_equals(typeof get(tickMinMax), "object") ? get(tickMinMax) : {}
                ));
              }),
              "component",
              Box,
              247,
              8,
              { componentTag: "TickMark" }
            );
            var node_8 = sibling(node_7, 2);
            add_svelte_meta(
              () => component(node_8, () => get(TickMark), ($$anchor4, TickMark_3) => {
                TickMark_3($$anchor4, spread_props(
                  {
                    get data() {
                      return get(boxData);
                    }
                  },
                  () => ({ [get(yProp)]: get(groupSymbol), [get(xProp)]: MAX }),
                  {
                    get stroke() {
                      return get(stroke);
                    }
                  },
                  () => get(facets),
                  { inset: "20%" },
                  () => strict_equals(typeof get(tickMinMax), "object") ? get(tickMinMax) : {}
                ));
              }),
              "component",
              Box,
              254,
              8,
              { componentTag: "TickMark" }
            );
            append($$anchor3, fragment_3);
          };
          add_svelte_meta(
            () => if_block(node_6, ($$render) => {
              if (get(tickMinMax)) $$render(consequent_1);
            }),
            "if",
            Box,
            246,
            4
          );
        }
        var node_9 = sibling(node_6, 2);
        {
          let $0 = user_derived(() => get(boxData).map((d) => d[OUTLIERS]).flat());
          add_svelte_meta(
            () => Dot_default(node_9, spread_props(
              {
                get data() {
                  return get($0);
                },
                get x() {
                  return get(x2);
                },
                get y() {
                  return get(y2);
                },
                get fx() {
                  return get(fx);
                },
                get fy() {
                  return get(fy);
                },
                get fill() {
                  return get(fill2);
                },
                get stroke() {
                  return get(stroke);
                }
              },
              () => get(dot) || {}
            )),
            "component",
            Box,
            262,
            4,
            { componentTag: "Dot" }
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Box,
    216,
    0,
    { componentTag: "GroupMultiple" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Box = hmr(Box);
  import.meta.hot.accept((module) => {
    Box[HMR].update(module.default);
  });
}
var Box_default = Box;

// node_modules/svelteplot/dist/marks/BoxX.svelte
BoxX[FILENAME] = "node_modules/svelteplot/dist/marks/BoxX.svelte";
function BoxX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BoxX);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    tickMedian: true,
    tickMinMax: false,
    sort: "median",
    ...getPlotDefaults().box,
    ...getPlotDefaults().boxX
  };
  const props = tag(user_derived(() => ({ ...DEFAULTS, ...markProps })), "props");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Box_default(node, spread_props(() => get(props), { orientation: "x" })), "component", BoxX, 28, 0, { componentTag: "Box" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BoxX = hmr(BoxX);
  import.meta.hot.accept((module) => {
    BoxX[HMR].update(module.default);
  });
}
var BoxX_default = BoxX;

// node_modules/svelteplot/dist/marks/BoxY.svelte
BoxY[FILENAME] = "node_modules/svelteplot/dist/marks/BoxY.svelte";
function BoxY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BoxY);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    tickMedian: true,
    tickMinMax: false,
    sort: "median",
    ...getPlotDefaults().box,
    ...getPlotDefaults().boxY
  };
  const props = tag(user_derived(() => ({ ...DEFAULTS, ...markProps })), "props");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Box_default(node, spread_props(() => get(props), { orientation: "y" })), "component", BoxY, 68, 0, { componentTag: "Box" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BoxY = hmr(BoxY);
  import.meta.hot.accept((module) => {
    BoxY[HMR].update(module.default);
  });
}
var BoxY_default = BoxY;

// node_modules/svelteplot/dist/marks/Rect.svelte
Rect[FILENAME] = "node_modules/svelteplot/dist/marks/Rect.svelte";
function Rect($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Rect);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().rect };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  const plot = usePlot();
  const args = tag(user_derived(() => intervalY(intervalX({ data: get(data), ...get(options) }, { plot }), { plot })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Rect, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => scaledData().length > 1 ? get(className) : null);
        add_svelte_meta(
          () => GroupMultiple_default(node_1, {
            get class() {
              return get($0);
            },
            get length() {
              return scaledData().length;
            },
            children: wrap_snippet(Rect, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                  var fragment_3 = comment();
                  var node_3 = first_child(fragment_3);
                  {
                    var consequent = ($$anchor5) => {
                      const x12 = tag(user_derived(() => equals(get(d).x1, null) ? plot.options.marginLeft + get(d).dx : get(d).x1), "x1");
                      get(x12);
                      const x2 = tag(
                        user_derived(() => equals(get(d).x2, null) ? plot.options.marginLeft + plot.facetWidth + get(d).dx : get(d).x2),
                        "x2"
                      );
                      get(x2);
                      const y12 = tag(user_derived(() => equals(get(d).y1, null) ? plot.options.marginTop + get(d).dy : get(d).y1), "y1");
                      get(y12);
                      const y2 = tag(
                        user_derived(() => equals(get(d).y2, null) ? plot.options.marginTop + plot.facetHeight + get(d).dy : get(d).y2),
                        "y2"
                      );
                      get(y2);
                      const miny = tag(user_derived(() => Math.min(get(y12), get(y2))), "miny");
                      get(miny);
                      const maxy = tag(user_derived(() => Math.max(get(y12), get(y2))), "maxy");
                      get(maxy);
                      const minx = tag(user_derived(() => Math.min(get(x12), get(x2))), "minx");
                      get(minx);
                      const maxx = tag(user_derived(() => Math.max(get(x12), get(x2))), "maxx");
                      get(maxx);
                      var fragment_4 = comment();
                      var node_4 = first_child(fragment_4);
                      {
                        let $02 = user_derived(() => strict_equals(scaledData().length, 1) ? get(className) : null);
                        let $1 = user_derived(() => get(maxx) - get(minx));
                        let $2 = user_derived(() => get(maxy) - get(miny));
                        add_svelte_meta(
                          () => RectPath_default(node_4, {
                            get datum() {
                              return get(d);
                            },
                            get class() {
                              return get($02);
                            },
                            get x() {
                              return get(minx);
                            },
                            get y() {
                              return get(miny);
                            },
                            get width() {
                              return get($1);
                            },
                            get height() {
                              return get($2);
                            },
                            get options() {
                              return get(args);
                            },
                            get usedScales() {
                              return usedScales();
                            }
                          }),
                          "component",
                          Rect,
                          77,
                          20,
                          { componentTag: "RectPath" }
                        );
                      }
                      append($$anchor5, fragment_4);
                    };
                    add_svelte_meta(
                      () => if_block(node_3, ($$render) => {
                        if (get(d).valid) $$render(consequent);
                      }),
                      "if",
                      Rect,
                      64,
                      16
                    );
                  }
                  append($$anchor4, fragment_3);
                }),
                "each",
                Rect,
                63,
                12
              );
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }),
          "component",
          Rect,
          62,
          8,
          { componentTag: "GroupMultiple" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "rect",
          required: [],
          channels: [
            "x1",
            "x2",
            "y1",
            "y2",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => markProps,
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Rect,
      55,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Rect = hmr(Rect);
  import.meta.hot.accept((module) => {
    Rect[HMR].update(module.default);
  });
}
var Rect_default = Rect;

// node_modules/svelteplot/dist/marks/Brush.svelte
Brush[FILENAME] = "node_modules/svelteplot/dist/marks/Brush.svelte";
var root8 = add_locations(from_html(`<!> <!>`, 1), Brush[FILENAME], []);
function Brush($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Brush);
  let brushExternal = prop($$props, "brush", 31, () => tag_proxy(proxy({ enabled: false }), "brushExternal")), markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "brush"], "markProps");
  let brush = tag(state(proxy(brushExternal())), "brush");
  const DEFAULTS = {
    stroke: "currentColor",
    strokeDasharray: "2,3",
    strokeOpacity: 0.6,
    resizeHandleSize: 10,
    constrainToDomain: false,
    ...getPlotDefaults().brush
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), stroke = tag(user_derived(() => get($$d).stroke), "stroke"), strokeWidth = tag(user_derived(() => get($$d).strokeWidth), "strokeWidth"), strokeDasharray = tag(user_derived(() => get($$d).strokeDasharray), "strokeDasharray"), strokeOpacity = tag(user_derived(() => get($$d).strokeOpacity), "strokeOpacity"), strokeLinecap = tag(user_derived(() => get($$d).strokeLinecap), "strokeLinecap"), strokeDashoffset = tag(user_derived(() => get($$d).strokeDashoffset), "strokeDashoffset"), strokeLinejoin = tag(user_derived(() => get($$d).strokeLinejoin), "strokeLinejoin"), strokeMiterlimit = tag(user_derived(() => get($$d).strokeMiterlimit), "strokeMiterlimit"), forceCursor = tag(user_derived(() => get($$d).cursor), "forceCursor"), limitDimension = tag(user_derived(() => fallback(get($$d).limitDimension, false)), "limitDimension"), constrainToDomain = tag(user_derived(() => get($$d).constrainToDomain), "constrainToDomain"), resizeHandleSize = tag(user_derived(() => get($$d).resizeHandleSize), "resizeHandleSize"), onbrushstart = tag(user_derived(() => get($$d).onbrushstart), "onbrushstart"), onbrushend = tag(user_derived(() => get($$d).onbrushend), "onbrushend"), onbrush = tag(user_derived(() => get($$d).onbrush), "onbrush");
  const plot = usePlot();
  const xScaleFn = tag(user_derived(() => plot.scales.x.fn), "xScaleFn");
  const yScaleFn = tag(user_derived(() => plot.scales.y.fn), "yScaleFn");
  const xDomain = tag(user_derived(() => plot.scales.x.domain), "xDomain");
  const xRange = tag(user_derived(() => plot.scales.x.range), "xRange");
  const yDomain = tag(user_derived(() => plot.scales.y.domain), "yDomain");
  const yRange = tag(user_derived(() => plot.scales.y.range), "yRange");
  user_effect(() => {
    if (strict_equals(get(limitDimension), "y", false) && !get(xScaleFn).invert) {
      throw new Error("brushing does not work with band/point scales");
    }
    if (strict_equals(get(limitDimension), "x", false) && !get(yScaleFn).invert) {
      throw new Error("brushing does not work with band/point scales");
    }
  });
  let x12 = tag(state(proxy(get(brush).x1)), "x1");
  let x2 = tag(state(proxy(get(brush).x2)), "x2");
  let y12 = tag(state(proxy(get(brush).y1)), "y1");
  let y2 = tag(state(proxy(get(brush).y2)), "y2");
  let dragging = false;
  let action = tag(state(false), "action");
  let dragStart;
  let pxPointer = tag(state(proxy([0, 0])), "pxPointer");
  const pxBrush = tag(
    user_derived(() => ({
      x1: get(xScaleFn)(get(brush).x1),
      x2: get(xScaleFn)(get(brush).x2),
      y1: get(yScaleFn)(get(brush).y1),
      y2: get(yScaleFn)(get(brush).y2)
    })),
    "pxBrush"
  );
  const HALF_EDGE = tag(user_derived(() => get(resizeHandleSize) * 0.5), "HALF_EDGE");
  const isInsideBrush = tag(user_derived(() => (strict_equals(get(limitDimension), "y") || get(pxPointer)[0] > get(pxBrush).x1 + get(HALF_EDGE)) && (strict_equals(get(limitDimension), "y") || get(pxPointer)[0] < get(pxBrush).x2 - get(HALF_EDGE)) && (strict_equals(get(limitDimension), "x") || get(pxPointer)[1] > get(pxBrush).y2 + get(HALF_EDGE)) && (strict_equals(get(limitDimension), "x") || get(pxPointer)[1] < get(pxBrush).y1 - get(HALF_EDGE))), "isInsideBrush");
  const isXEdge = tag(
    user_derived(() => get(pxPointer)[0] > get(pxBrush).x1 - get(HALF_EDGE) && get(pxPointer)[0] < get(pxBrush).x1 + get(HALF_EDGE) ? "left" : get(pxPointer)[0] > get(pxBrush).x2 - get(HALF_EDGE) && get(pxPointer)[0] < get(pxBrush).x2 + get(HALF_EDGE) ? "right" : false),
    "isXEdge"
  );
  const isYEdge = tag(
    user_derived(() => get(pxPointer)[1] > get(pxBrush).y1 - get(HALF_EDGE) && get(pxPointer)[1] < get(pxBrush).y1 + get(HALF_EDGE) ? "top" : get(pxPointer)[1] > get(pxBrush).y2 - get(HALF_EDGE) && get(pxPointer)[1] < get(pxBrush).y2 + get(HALF_EDGE) ? "bottom" : false),
    "isYEdge"
  );
  const CURSOR_MAP = { left: "w", right: "e", top: "s", bottom: "n" };
  const cursor = tag(
    user_derived(() => get(forceCursor) ? get(forceCursor) : get(action) ? strict_equals(get(action), "draw") ? "crosshair" : get(action) : get(brush).enabled && get(isInsideBrush) ? "move" : get(brush).enabled && (get(isXEdge) || get(isYEdge)) ? `${[get(isYEdge), get(isXEdge)].filter((d) => !!d).map((c4) => CURSOR_MAP[c4]).join("")}-resize` : "crosshair"),
    "cursor"
  );
  user_effect(() => {
    get(brush).x1 = !get(brush).enabled || strict_equals(get(limitDimension), "y") ? void 0 : constrain(get(x12) < get(x2) ? get(x12) : get(x2), get(xDomain));
    get(brush).x2 = !get(brush).enabled || strict_equals(get(limitDimension), "y") ? void 0 : constrain(get(x12) > get(x2) ? get(x12) : get(x2), get(xDomain));
    get(brush).y1 = !get(brush).enabled || strict_equals(get(limitDimension), "x") ? void 0 : constrain(get(y12) < get(y2) ? get(y12) : get(y2), get(yDomain));
    get(brush).y2 = !get(brush).enabled || strict_equals(get(limitDimension), "x") ? void 0 : constrain(get(y12) > get(y2) ? get(y12) : get(y2), get(yDomain));
  });
  user_effect(() => {
    const brushInt = untrack(() => get(brush));
    if (!brushIdentical(brushInt, brushExternal())) {
      set(brush, brushExternal(), true);
      set(x12, get(brush).x1, true);
      set(x2, get(brush).x2, true);
      set(y12, get(brush).y1, true);
      set(y2, get(brush).y2, true);
    }
  });
  user_effect(() => {
    const brushExt = untrack(() => brushExternal());
    if (!brushIdentical(get(brush), brushExt)) {
      brushExternal(get(brush));
    }
  });
  function brushIdentical(b1, b2) {
    return strict_equals(b1.enabled, b2.enabled) && strict_equals(b1.x1, b2.x1) && strict_equals(b1.x2, b2.x2) && strict_equals(b1.y1, b2.y1) && strict_equals(b1.y2, b2.y2);
  }
  function constrain(x3, extent2) {
    const minE = extent2[0] < extent2[1] ? extent2[0] : extent2[1];
    const maxE = extent2[0] > extent2[1] ? extent2[0] : extent2[1];
    if (x3 < minE) return minE;
    if (x3 > maxE) return maxE;
    return x3;
  }
  const DRAG_MIN_DISTANCE = 5;
  function getLayerPos(e) {
    return clientToLayerCoordinates(e, plot.body);
  }
  user_effect(() => {
    plot.body?.ownerDocument.body.addEventListener("pointerup", onpointerup);
    plot.body?.ownerDocument.body.addEventListener("pointermove", onpointermove);
    return () => {
      plot.body?.ownerDocument.body.removeEventListener("pointerup", onpointerup);
      plot.body?.ownerDocument.body.removeEventListener("pointermove", onpointermove);
    };
  });
  function onpointerdown(e) {
    dragging = true;
    dragStart = getLayerPos(e);
    set(pxPointer, getLayerPos(e), true);
    if (get(brush).enabled && get(isInsideBrush)) {
      set(action, "move");
    } else if (get(brush).enabled && (get(isXEdge) || get(isYEdge))) {
      set(action, `${[get(isYEdge), get(isXEdge)].filter((d) => !!d).map((c4) => CURSOR_MAP[c4]).join("")}-resize`);
    } else {
      set(action, "draw");
      if (strict_equals(typeof get(xScaleFn).invert, "function") && strict_equals(get(limitDimension), "y", false)) {
        set(x12, set(x2, get(xScaleFn).invert(dragStart[0]), true), true);
      }
      if (strict_equals(typeof get(yScaleFn).invert, "function") && strict_equals(get(limitDimension), "x", false)) {
        set(y12, set(y2, get(yScaleFn).invert(dragStart[1]), true), true);
      }
    }
    get(onbrushstart)?.({ ...e, brush: get(brush) });
  }
  const EAST = /* @__PURE__ */ new Set(["e-resize", "ne-resize", "se-resize"]);
  const WEST = /* @__PURE__ */ new Set(["w-resize", "nw-resize", "sw-resize"]);
  const NORTH = /* @__PURE__ */ new Set(["n-resize", "ne-resize", "nw-resize"]);
  const SOUTH = /* @__PURE__ */ new Set(["s-resize", "se-resize", "sw-resize"]);
  function onpointermove(e) {
    const newPos = getLayerPos(e);
    if (dragging) {
      let px = newPos[0] - get(pxPointer)[0];
      let py = newPos[1] - get(pxPointer)[1];
      if (get(constrainToDomain)) {
        if (strict_equals(get(action), "move")) {
          px = constrain(px, [
            get(xRange)[0] - get(pxBrush).x1,
            get(xRange)[1] - get(pxBrush).x2
          ]);
          py = constrain(py, [
            get(yRange)[0] - get(pxBrush).y1,
            get(yRange)[1] - get(pxBrush).y2
          ]);
        } else if (strict_equals(get(action), "draw", false)) {
          if (EAST.has(get(action))) {
            px = constrain(px, [
              get(xRange)[0] - get(pxBrush).x2,
              get(xRange)[1] - get(pxBrush).x2
            ]);
          } else if (WEST.has(get(action))) {
            px = constrain(px, [
              get(xRange)[0] - get(pxBrush).x1,
              get(xRange)[1] - get(pxBrush).x1
            ]);
          }
          if (NORTH.has(get(action))) {
            py = constrain(py, [
              get(yRange)[0] - get(pxBrush).y2,
              get(yRange)[1] - get(pxBrush).y2
            ]);
          } else if (SOUTH.has(get(action))) {
            py = constrain(py, [
              get(yRange)[0] - get(pxBrush).y1,
              get(yRange)[1] - get(pxBrush).y1
            ]);
          }
        }
      }
      const hasX = strict_equals(get(limitDimension), "y", false);
      const hasY = strict_equals(get(limitDimension), "x", false);
      const dx1 = !hasX ? 0 : get(xScaleFn).invert(get(xScaleFn)(get(x12)) + px);
      const dx2 = !hasX ? 0 : get(xScaleFn).invert(get(xScaleFn)(get(x2)) + px);
      const dy1 = !hasY ? 0 : get(yScaleFn).invert(get(yScaleFn)(get(y12)) + py);
      const dy2 = !hasY ? 0 : get(yScaleFn).invert(get(yScaleFn)(get(y2)) + py);
      if (strict_equals(get(action), "move")) {
        set(x12, dx1, true);
        set(x2, dx2, true);
        set(y12, dy1, true);
        set(y2, dy2, true);
      } else if (strict_equals(get(action), "draw")) {
        set(x2, !hasX ? 0 : get(xScaleFn).invert(newPos[0]), true);
        set(y2, !hasY ? 0 : get(yScaleFn).invert(newPos[1]), true);
        if (get(constrainToDomain)) {
          set(x2, constrain(get(x2), get(xDomain)), true);
          set(y2, constrain(get(y2), get(yDomain)), true);
        }
      } else {
        if (EAST.has(get(action))) {
          set(x2, dx2, true);
        } else if (WEST.has(get(action))) {
          set(x12, dx1, true);
        }
        if (NORTH.has(get(action))) {
          set(y2, dy2, true);
        } else if (SOUTH.has(get(action))) {
          set(y12, dy1, true);
        }
        (($$value) => {
          var $$array = to_array($$value, 3);
          set(x12, $$array[0], true);
          set(x2, $$array[1], true);
          set(action, $$array[2], true);
        })(swapIfNeeded(get(x12), get(x2), get(action), "e", "w"));
        (($$value) => {
          var $$array_1 = to_array($$value, 3);
          set(y12, $$array_1[0], true);
          set(y2, $$array_1[1], true);
          set(action, $$array_1[2], true);
        })(swapIfNeeded(get(y12), get(y2), get(action), "n", "s"));
      }
      const dist = Math.sqrt((dragStart[0] - get(pxPointer)[0]) ** 2 + (dragStart[1] - get(pxPointer)[1]) ** 2);
      if (dist > DRAG_MIN_DISTANCE) get(brush).enabled = true;
      get(onbrush)?.({ ...e, brush: get(brush) });
      set(pxPointer, [get(pxPointer)[0] + px, get(pxPointer)[1] + py], true);
    } else {
      set(pxPointer, getLayerPos(e), true);
    }
  }
  function swapIfNeeded(v1, v2, action2, swapDir1, swapDir2) {
    if (action2 && v2 < v1) {
      return [
        v2,
        v1,
        `${action2.split("-")[0].replace(swapDir1, "X").replace(swapDir2, swapDir1).replace("X", swapDir2)}-resize`
      ];
    }
    return [v1, v2, action2];
  }
  function onpointerup(e) {
    if (dragging) {
      dragging = false;
      set(action, false);
      get(brush).enabled = Math.sqrt((dragStart[0] - get(pxPointer)[0]) ** 2 + (dragStart[1] - get(pxPointer)[1]) ** 2) > DRAG_MIN_DISTANCE;
      get(onbrushend)?.({ ...e, brush: get(brush) });
    }
  }
  var $$exports = { ...legacy_api() };
  var fragment = root8();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => Rect_default(node_1, spread_props({ class: "brush-rect" }, () => strict_equals(get(limitDimension), "x") ? {} : { y1: get(brush).y1, y2: get(brush).y2 }, () => strict_equals(get(limitDimension), "y") ? {} : { x1: get(brush).x1, x2: get(brush).x2 }, {
          get stroke() {
            return get(stroke);
          },
          get strokeDasharray() {
            return get(strokeDasharray);
          },
          get strokeOpacity() {
            return get(strokeOpacity);
          },
          get strokeDashoffset() {
            return get(strokeDashoffset);
          },
          get strokeLinecap() {
            return get(strokeLinecap);
          },
          get strokeLinejoin() {
            return get(strokeLinejoin);
          },
          get strokeMiterlimit() {
            return get(strokeMiterlimit);
          },
          get strokeWidth() {
            return get(strokeWidth);
          }
        })),
        "component",
        Brush,
        407,
        4,
        { componentTag: "Rect" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(stroke) && get(brush).enabled) $$render(consequent);
      }),
      "if",
      Brush,
      406,
      0
    );
  }
  var node_2 = sibling(node, 2);
  add_svelte_meta(
    () => Frame_default(node_2, {
      fill: "transparent",
      stroke: "transparent",
      inset: -20,
      get cursor() {
        return get(cursor);
      },
      onpointerdown,
      onpointermove
    }),
    "component",
    Brush,
    420,
    0,
    { componentTag: "Frame" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Brush = hmr(Brush);
  import.meta.hot.accept((module) => {
    Brush[HMR].update(module.default);
  });
}
var Brush_default = Brush;

// node_modules/svelteplot/dist/marks/BrushX.svelte
BrushX[FILENAME] = "node_modules/svelteplot/dist/marks/BrushX.svelte";
function BrushX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BrushX);
  var $$ownership_validator = create_ownership_validator($$props);
  let brush = prop($$props, "brush", 31, () => tag_proxy(proxy({ enabled: false }), "brush")), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "brush"], "options");
  const DEFAULTS = { ...getPlotDefaults().brush, ...getPlotDefaults().brushX };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("brush", Brush_default, brush);
    add_svelte_meta(
      () => Brush_default(node, spread_props({ limitDimension: "x" }, () => DEFAULTS, () => options, {
        get brush() {
          return brush();
        },
        set brush($$value) {
          brush($$value);
        }
      })),
      "component",
      BrushX,
      19,
      0,
      { componentTag: "Brush" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BrushX = hmr(BrushX);
  import.meta.hot.accept((module) => {
    BrushX[HMR].update(module.default);
  });
}
var BrushX_default = BrushX;

// node_modules/svelteplot/dist/marks/BrushY.svelte
BrushY[FILENAME] = "node_modules/svelteplot/dist/marks/BrushY.svelte";
function BrushY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BrushY);
  var $$ownership_validator = create_ownership_validator($$props);
  let brush = prop($$props, "brush", 31, () => tag_proxy(proxy({ enabled: false }), "brush")), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "brush"], "options");
  const DEFAULTS = { ...getPlotDefaults().brush, ...getPlotDefaults().brushY };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("brush", Brush_default, brush);
    add_svelte_meta(
      () => Brush_default(node, spread_props({ limitDimension: "y" }, () => DEFAULTS, () => options, {
        get brush() {
          return brush();
        },
        set brush($$value) {
          brush($$value);
        }
      })),
      "component",
      BrushY,
      19,
      0,
      { componentTag: "Brush" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  BrushY = hmr(BrushY);
  import.meta.hot.accept((module) => {
    BrushY[HMR].update(module.default);
  });
}
var BrushY_default = BrushY;

// node_modules/svelteplot/dist/marks/Cell.svelte
Cell[FILENAME] = "node_modules/svelteplot/dist/marks/Cell.svelte";
var root_114 = add_locations(from_svg(`<g></g>`), Cell[FILENAME], [[69, 8]]);
function Cell($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Cell);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().cell };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  const plot = usePlot();
  const args = tag(
    user_derived(() => strict_equals(get(options).sort, void 0, false) ? (
      // user has defined a custom sorting
      sort2(recordizeY({ data: get(data), ...get(options) }))
    ) : (
      // sort by x and y
      sort2({
        ...sort2({
          ...recordizeY({ data: get(data), ...get(options) }),
          sort: { channel: "x" }
        }),
        sort: { channel: "y" }
      })
    )),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Cell, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      const bwx = tag(user_derived(() => plot.scales.x.fn.bandwidth()), "bwx");
      get(bwx);
      const bwy = tag(user_derived(() => plot.scales.y.fn.bandwidth()), "bwy");
      get(bwy);
      var g = root_114();
      add_svelte_meta(
        () => each(g, 21, scaledData, index, ($$anchor3, d) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              {
                let $0 = user_derived(() => get(d).x - get(bwx) * 0.5);
                let $1 = user_derived(() => get(d).y - get(bwy) * 0.5);
                add_svelte_meta(
                  () => RectPath_default(node_2, {
                    get datum() {
                      return get(d);
                    },
                    get class() {
                      return get(className);
                    },
                    get usedScales() {
                      return usedScales();
                    },
                    get options() {
                      return get(args);
                    },
                    get x() {
                      return get($0);
                    },
                    get y() {
                      return get($1);
                    },
                    get width() {
                      return get(bwx);
                    },
                    get height() {
                      return get(bwy);
                    }
                  }),
                  "component",
                  Cell,
                  72,
                  20,
                  { componentTag: "RectPath" }
                );
              }
              append($$anchor4, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (get(d).valid && (equals(get(args).fill, null) || isValid(resolveChannel("fill", get(d).datum, get(args))))) $$render(consequent);
              }),
              "if",
              Cell,
              71,
              16
            );
          }
          append($$anchor3, fragment_1);
        }),
        "each",
        Cell,
        70,
        12
      );
      reset(g);
      template_effect(() => {
        set_class(g, 0, `cell ${(get(className) || "") ?? ""}`);
        set_attribute(g, "data-fill", usedScales().fillOpacity);
      });
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "cell",
          required: ["x", "y"],
          requiredScales: { x: ["band"], y: ["band"] },
          channels: [
            "x",
            "y",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Cell,
      60,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Cell = hmr(Cell);
  import.meta.hot.accept((module) => {
    Cell[HMR].update(module.default);
  });
}
var Cell_default = Cell;

// node_modules/svelteplot/dist/marks/CellX.svelte
CellX[FILENAME] = "node_modules/svelteplot/dist/marks/CellX.svelte";
function CellX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CellX);
  let data = prop($$props, "data", 19, () => [{}]), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "options");
  const args = tag(user_derived(() => recordizeY({ data: data(), ...options })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => $$props.fill || "__value");
    add_svelte_meta(
      () => Cell_default(node, spread_props(() => get(args), {
        y: "0",
        get fill() {
          return get($0);
        }
      })),
      "component",
      CellX,
      25,
      0,
      { componentTag: "Cell" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  CellX = hmr(CellX);
  import.meta.hot.accept((module) => {
    CellX[HMR].update(module.default);
  });
}
var CellX_default = CellX;

// node_modules/svelteplot/dist/marks/CellY.svelte
CellY[FILENAME] = "node_modules/svelteplot/dist/marks/CellY.svelte";
function CellY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CellY);
  let data = prop($$props, "data", 19, () => [{}]), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "options");
  const args = tag(user_derived(() => recordizeX({ data: data(), ...options })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => $$props.fill || "__value");
    add_svelte_meta(
      () => Cell_default(node, spread_props(() => get(args), {
        x: "0",
        get fill() {
          return get($0);
        }
      })),
      "component",
      CellY,
      25,
      0,
      { componentTag: "Cell" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  CellY = hmr(CellY);
  import.meta.hot.accept((module) => {
    CellY[HMR].update(module.default);
  });
}
var CellY_default = CellY;

// node_modules/svelteplot/dist/marks/CustomMark.svelte
CustomMark[FILENAME] = "node_modules/svelteplot/dist/marks/CustomMark.svelte";
var root_115 = add_locations(from_html(`<!> <!>`, 1), CustomMark[FILENAME], []);
function CustomMark($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CustomMark);
  let data = prop($$props, "data", 19, () => [{}]), type = prop($$props, "type", 3, "custom"), options = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "mark",
      "type",
      "marks"
    ],
    "options"
  );
  const args = tag(user_derived(() => sort2({ data: data(), ...options })), "args");
  const channels = [
    "x",
    "x1",
    "x2",
    "y",
    "y1",
    "y2",
    "r",
    "fill",
    "stroke",
    "opacity",
    "fillOpacity",
    "strokeOpacity"
  ];
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(CustomMark, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var fragment_1 = root_115();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            let $02 = user_derived(() => ({
              records: scaledData().filter((d) => d.valid),
              usedScales: usedScales()
            }));
            add_svelte_meta(() => snippet(node_2, () => $$props.marks, () => get($02)), "render", CustomMark, 65, 12);
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.marks) $$render(consequent);
          }),
          "if",
          CustomMark,
          64,
          8
        );
      }
      var node_3 = sibling(node_1, 2);
      {
        var consequent_2 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          add_svelte_meta(
            () => each(node_4, 17, scaledData, index, ($$anchor4, datum, i) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              {
                var consequent_1 = ($$anchor5) => {
                  var fragment_5 = comment();
                  var node_6 = first_child(fragment_5);
                  add_svelte_meta(() => snippet(node_6, () => $$props.mark, () => ({ record: get(datum), index: i, usedScales: usedScales() })), "render", CustomMark, 70, 20);
                  append($$anchor5, fragment_5);
                };
                add_svelte_meta(
                  () => if_block(node_5, ($$render) => {
                    if (get(datum).valid) $$render(consequent_1);
                  }),
                  "if",
                  CustomMark,
                  69,
                  16
                );
              }
              append($$anchor4, fragment_4);
            }),
            "each",
            CustomMark,
            68,
            12
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_3, ($$render) => {
            if ($$props.mark) $$render(consequent_2);
          }),
          "if",
          CustomMark,
          67,
          8
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => channels.filter((d) => !!options[d]));
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          get type() {
            return type();
          },
          required: [],
          get channels() {
            return get($0);
          }
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      CustomMark,
      62,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  CustomMark = hmr(CustomMark);
  import.meta.hot.accept((module) => {
    CustomMark[HMR].update(module.default);
  });
}
var CustomMark_default = CustomMark;

// node_modules/svelteplot/dist/marks/CustomMarkHTML.svelte
CustomMarkHTML[FILENAME] = "node_modules/svelteplot/dist/marks/CustomMarkHTML.svelte";
var root_38 = add_locations(from_html(`<div class="custom-mark-html s-MiMPhL3ZDsJc"><!></div>`), CustomMarkHTML[FILENAME], [[78, 12]]);
var root_45 = add_locations(from_html(`<div><!></div>`), CustomMarkHTML[FILENAME], [[89, 4]]);
var $$css13 = {
  hash: "s-MiMPhL3ZDsJc",
  code: "\n    .custom-mark-html.s-MiMPhL3ZDsJc {\n        position: absolute;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VzdG9tTWFya0hUTUwuc3ZlbHRlIiwic291cmNlcyI6WyJDdXN0b21NYXJrSFRNTC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLVxuICAgIEBjb21wb25lbnRcbiAgICBGb3Igc2hvd2luZyBjdXN0b20gSFRNTCB0b29sdGlwcyBwb3NpdGlvbmVkIGF0IHgveSBjb29yZGluYXRlc1xuLS0+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJEYXR1bSBleHRlbmRzIERhdGFSZWNvcmRcIj5cbiAgICBpbnRlcmZhY2UgQ3VzdG9tTWFya0hUTUxQcm9wcyB7XG4gICAgICAgIGRhdGE6IERhdHVtW107XG4gICAgICAgIHg/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICB5PzogQ2hhbm5lbEFjY2Vzc29yPERhdHVtPjtcbiAgICAgICAgZnJhbWVBbmNob3I/OiBDb25zdGFudEFjY2Vzc29yPFxuICAgICAgICAgICAgfCAnYm90dG9tJ1xuICAgICAgICAgICAgfCAndG9wJ1xuICAgICAgICAgICAgfCAnbGVmdCdcbiAgICAgICAgICAgIHwgJ3JpZ2h0J1xuICAgICAgICAgICAgfCAndG9wLWxlZnQnXG4gICAgICAgICAgICB8ICdib3R0b20tbGVmdCdcbiAgICAgICAgICAgIHwgJ3RvcC1yaWdodCdcbiAgICAgICAgICAgIHwgJ2JvdHRvbS1yaWdodCdcbiAgICAgICAgICAgIHwgJ2NlbnRlcicsXG4gICAgICAgICAgICBEYXR1bVxuICAgICAgICA+O1xuICAgICAgICBjbGFzczogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgY2hpbGRyZW46IFNuaXBwZXQ8eyBkYXR1bTogRGF0dW07IHg6IG51bWJlcjsgeTogbnVtYmVyIH0+O1xuICAgIH1cbiAgICBpbXBvcnQgeyB0eXBlIFNuaXBwZXQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB0eXBlIHsgQ2hhbm5lbEFjY2Vzc29yLCBDb25zdGFudEFjY2Vzc29yLCBEYXRhUmVjb3JkIH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IHVzZVBsb3QgfSBmcm9tICcuLi9ob29rcy91c2VQbG90LnN2ZWx0ZS5qcyc7XG5cbiAgICBpbXBvcnQgeyByZXNvbHZlQ2hhbm5lbCB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZS5qcyc7XG4gICAgaW1wb3J0IHsgcHJvamVjdFgsIHByb2plY3RZLCBwcm9qZWN0WFkgfSBmcm9tICcuLi9oZWxwZXJzL3NjYWxlcy5qcyc7XG4gICAgaW1wb3J0IHsgaXNWYWxpZCB9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4gICAgY29uc3QgcGxvdCA9IHVzZVBsb3QoKTtcblxuICAgIGxldCB7XG4gICAgICAgIGRhdGEgPSBbe30gYXMgRGF0dW1dLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmcmFtZUFuY2hvcixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWUgPSBudWxsXG4gICAgfTogQ3VzdG9tTWFya0hUTUxQcm9wcyA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gZ2V0WFkoZGF0dW06IERhdHVtKSB7XG4gICAgICAgIGNvbnN0IGZhID0gZnJhbWVBbmNob3IgfHwgJ2NlbnRlcic7XG4gICAgICAgIGNvbnN0IGlzTGVmdCA9IGZhLmVuZHNXaXRoKCdsZWZ0Jyk7XG4gICAgICAgIGNvbnN0IGlzUmlnaHQgPSBmYS5lbmRzV2l0aCgncmlnaHQnKTtcbiAgICAgICAgY29uc3QgaXNUb3AgPSBmYS5zdGFydHNXaXRoKCd0b3AnKTtcbiAgICAgICAgY29uc3QgaXNCb3R0b20gPSBmYS5zdGFydHNXaXRoKCdib3R0b20nKTtcblxuICAgICAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gcHJvamVjdCB4IGFuZCB5IGluZGl2aWR1YWxseVxuICAgICAgICAgICAgY29uc3QgcHggPVxuICAgICAgICAgICAgICAgIHggIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IHByb2plY3RYKCd4JywgcGxvdC5zY2FsZXMsIHJlc29sdmVDaGFubmVsKCd4JywgZGF0dW0sIHsgeCwgeSB9KSlcbiAgICAgICAgICAgICAgICAgICAgOiBwbG90Lm9wdGlvbnMubWFyZ2luTGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgKGlzTGVmdCA/IDAgOiBpc1JpZ2h0ID8gcGxvdC53aWR0aCA6IHBsb3Qud2lkdGggLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHB5ID1cbiAgICAgICAgICAgICAgICB5ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBwcm9qZWN0WSgneScsIHBsb3Quc2NhbGVzLCByZXNvbHZlQ2hhbm5lbCgneScsIGRhdHVtLCB7IHgsIHkgfSkpXG4gICAgICAgICAgICAgICAgICAgIDogcGxvdC5vcHRpb25zLm1hcmdpblRvcCArXG4gICAgICAgICAgICAgICAgICAgICAgKGlzVG9wID8gMCA6IGlzQm90dG9tID8gcGxvdC5oZWlnaHQgOiBwbG90LmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIFtweCwgcHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlIHByb2plY3RYWVxuICAgICAgICAgICAgY29uc3QgeF8gPSByZXNvbHZlQ2hhbm5lbCgneCcsIGRhdHVtLCB7IHgsIHkgfSk7XG4gICAgICAgICAgICBjb25zdCB5XyA9IHJlc29sdmVDaGFubmVsKCd5JywgZGF0dW0sIHsgeCwgeSB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0WFkocGxvdC5zY2FsZXMsIHhfLCB5Xyk7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IGN1c3RvbU1hcmtzKCl9XG4gICAgeyNlYWNoIGRhdGEgYXMgZGF0dW0sIGkgKGkpfVxuICAgICAgICB7QGNvbnN0IFtweCwgcHldID0gZ2V0WFkoZGF0dW0pfVxuICAgICAgICB7I2lmIGlzVmFsaWQocHgpICYmIGlzVmFsaWQocHkpfVxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiY3VzdG9tLW1hcmstaHRtbFwiXG4gICAgICAgICAgICAgICAgc3R5bGU6bGVmdD1cIntweC50b0ZpeGVkKDApfXB4XCJcbiAgICAgICAgICAgICAgICBzdHlsZTp0b3A9XCJ7cHkudG9GaXhlZCgwKX1weFwiPlxuICAgICAgICAgICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuKHsgZGF0dW0sIHg6IHB4LCB5OiBweSB9KX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbnsvc25pcHBldH1cblxueyNpZiBkYXRhLmxlbmd0aCA+IDEgfHwgY2xhc3NOYW1lfVxuICAgIDxkaXYgY2xhc3M9XCJnLWN1c3RvbS1tYXJrLWh0bWwge2NsYXNzTmFtZSB8fCAnJ31cIj5cbiAgICAgICAge0ByZW5kZXIgY3VzdG9tTWFya3MoKX1cbiAgICA8L2Rpdj5cbns6ZWxzZX1cbiAgICB7QHJlbmRlciBjdXN0b21NYXJrcygpfVxuey9pZn1cblxuPHN0eWxlPlxuICAgIC5jdXN0b20tbWFyay1odG1sIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function CustomMarkHTML($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, CustomMarkHTML);
  append_styles($$anchor, $$css13);
  const customMarks = wrap_snippet(CustomMarkHTML, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = comment();
    var node = first_child(fragment);
    add_svelte_meta(
      () => each(node, 17, data, index, ($$anchor3, datum) => {
        const computed_const = tag(
          user_derived(() => {
            const [px, py] = getXY(get(datum));
            return { px, py };
          }),
          "[@const]"
        );
        get(computed_const);
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor4) => {
            var div = root_38();
            let styles;
            var node_2 = child(div);
            add_svelte_meta(
              () => snippet(node_2, () => $$props.children, () => ({
                datum: get(datum),
                x: get(computed_const).px,
                y: get(computed_const).py
              })),
              "render",
              CustomMarkHTML,
              82,
              16
            );
            reset(div);
            template_effect(($0) => styles = set_style(div, "", styles, $0), [
              () => ({
                left: `${get(computed_const).px.toFixed(0) ?? ""}px`,
                top: `${get(computed_const).py.toFixed(0) ?? ""}px`
              })
            ]);
            append($$anchor4, div);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if (isValid(get(computed_const).px) && isValid(get(computed_const).py)) $$render(consequent);
            }),
            "if",
            CustomMarkHTML,
            77,
            8
          );
        }
        append($$anchor3, fragment_1);
      }),
      "each",
      CustomMarkHTML,
      75,
      4
    );
    append($$anchor2, fragment);
  });
  const plot = usePlot();
  let data = prop($$props, "data", 19, () => [{}]), className = prop($$props, "class", 3, null);
  function getXY(datum) {
    const fa = $$props.frameAnchor || "center";
    const isLeft = fa.endsWith("left");
    const isRight = fa.endsWith("right");
    const isTop = fa.startsWith("top");
    const isBottom = fa.startsWith("bottom");
    if (equals($$props.x, null) || equals($$props.y, null)) {
      const px = equals($$props.x, null, false) ? projectX("x", plot.scales, resolveChannel("x", datum, { x: $$props.x, y: $$props.y })) : plot.options.marginLeft + (isLeft ? 0 : isRight ? plot.width : plot.width / 2);
      const py = equals($$props.y, null, false) ? projectY("y", plot.scales, resolveChannel("y", datum, { x: $$props.x, y: $$props.y })) : plot.options.marginTop + (isTop ? 0 : isBottom ? plot.height : plot.height / 2);
      return [px, py];
    } else {
      const x_ = resolveChannel("x", datum, { x: $$props.x, y: $$props.y });
      const y_ = resolveChannel("y", datum, { x: $$props.x, y: $$props.y });
      return projectXY(plot.scales, x_, y_);
    }
  }
  var $$exports = { ...legacy_api() };
  var fragment_2 = comment();
  var node_3 = first_child(fragment_2);
  {
    var consequent_1 = ($$anchor2) => {
      var div_1 = root_45();
      var node_4 = child(div_1);
      add_svelte_meta(() => customMarks(node_4), "render", CustomMarkHTML, 90, 8);
      reset(div_1);
      template_effect(() => set_class(div_1, 1, `g-custom-mark-html ${(className() || "") ?? ""}`, "s-MiMPhL3ZDsJc"));
      append($$anchor2, div_1);
    };
    var alternate = ($$anchor2) => {
      add_svelte_meta(() => customMarks($$anchor2), "render", CustomMarkHTML, 93, 4);
    };
    add_svelte_meta(
      () => if_block(node_3, ($$render) => {
        if (data().length > 1 || className()) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      CustomMarkHTML,
      88,
      0
    );
  }
  append($$anchor, fragment_2);
  return pop($$exports);
}
if (import.meta.hot) {
  CustomMarkHTML = hmr(CustomMarkHTML);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-MiMPhL3ZDsJc");
    CustomMarkHTML[HMR].update(module.default);
  });
}
var CustomMarkHTML_default = CustomMarkHTML;

// node_modules/svelteplot/dist/marks/DifferenceY.svelte
DifferenceY[FILENAME] = "node_modules/svelteplot/dist/marks/DifferenceY.svelte";
var root9 = add_locations(from_svg(`<g><clipPath><!></clipPath><!></g><g><clipPath><!></clipPath><!></g><!>`, 1), DifferenceY[FILENAME], [[127, 0, [[129, 4]]], [149, 0, [[151, 4]]]]);
function DifferenceY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DifferenceY);
  const plot = usePlot();
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    positiveFill: "red",
    positiveFillOpacity: 1,
    negativeFill: "blue",
    negativeFillOpacity: 1,
    curve: "linear",
    tension: 0,
    ...getPlotDefaults().differenceY
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => get($$d).data), "data"), stroke = tag(user_derived(() => get($$d).stroke), "stroke"), className = tag(user_derived(() => fallback(get($$d).class, null)), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "stroke", "class"])), "options");
  const x2 = tag(user_derived(() => get(options).x), "x"), x12 = tag(user_derived(() => get(options).x1), "x1"), x22 = tag(user_derived(() => get(options).x2), "x2"), y2 = tag(user_derived(() => get(options).y), "y"), y12 = tag(user_derived(() => get(options).y1), "y1"), y22 = tag(user_derived(() => get(options).y2), "y2");
  const x1x2Differ = tag(user_derived(() => (equals(get(x12), null) || equals(get(x22), null)) && strict_equals(get(x12), get(x22), false)), "x1x2Differ");
  const xExtent = tag(
    user_derived(() => get(x1x2Differ) && equals(get(x2), null, false) ? extent(get(data), (d) => resolveChannel("x", d, get(options))) : null),
    "xExtent"
  );
  const x1Extent = tag(
    user_derived(() => get(x1x2Differ) && equals(get(x12), null, false) ? extent(get(data), (d) => resolveChannel("x1", d, get(options))) : null),
    "x1Extent"
  );
  const x2Extent = tag(
    user_derived(() => get(x1x2Differ) && equals(get(x22), null, false) ? extent(get(data), (d) => resolveChannel("x2", d, get(options))) : null),
    "x2Extent"
  );
  const maxMin = tag(user_derived(() => max([get(xExtent), get(x1Extent), get(x2Extent)].filter((d) => equals(d, null, false)).map((d) => d[0]))), "maxMin");
  const minMax = tag(user_derived(() => min([get(xExtent), get(x1Extent), get(x2Extent)].filter((d) => equals(d, null, false)).map((d) => d[1]))), "minMax");
  const croppedX1 = tag(
    user_derived(() => get(x1x2Differ) ? get(data).filter((d) => {
      const x1val = resolveChannel(equals(get(x12), null, false) ? "x1" : "x", d, get(options));
      return x1val >= get(maxMin) && x1val <= get(minMax);
    }) : get(data)),
    "croppedX1"
  );
  const croppedX2 = tag(
    user_derived(() => get(x1x2Differ) ? get(data).filter((d) => {
      const x2val = resolveChannel(equals(get(x22), null, false) ? "x2" : "x", d, get(options));
      return x2val >= get(maxMin) && x2val <= get(minMax);
    }) : get(data)),
    "croppedX2"
  );
  const id = randomId();
  var $$exports = { ...legacy_api() };
  var fragment = root9();
  var g = first_child(fragment);
  var clipPath = child(g);
  var node = child(clipPath);
  {
    let $0 = user_derived(() => get(options).positiveFill || "red");
    let $1 = user_derived(() => coalesce(get(x22), get(x2)));
    let $2 = user_derived(() => coalesce(get(y22), get(y2)));
    let $3 = user_derived(() => ({
      scale: null,
      value: plot.options.marginTop + plot.facetHeight
    }));
    add_svelte_meta(
      () => Area_default(node, spread_props(
        {
          get data() {
            return get(croppedX2);
          }
        },
        () => get(options),
        {
          get fill() {
            return get($0);
          },
          get x1() {
            return get($1);
          },
          get y1() {
            return get($2);
          },
          get y2() {
            return get($3);
          }
        }
      )),
      "component",
      DifferenceY,
      130,
      8,
      { componentTag: "Area" }
    );
  }
  reset(clipPath);
  var node_1 = sibling(clipPath);
  {
    let $0 = user_derived(() => get(options).positiveFill || "pink");
    let $1 = user_derived(() => coalesce(get(options).positiveFillOpacity, get(options).fillOpacity, 1));
    let $2 = user_derived(() => coalesce(get(x12), get(x22), get(x2)));
    let $3 = user_derived(() => coalesce(get(y12), get(x1x2Differ) ? coalesce(get(y22), get(y2)) : 0));
    add_svelte_meta(
      () => Area_default(node_1, spread_props(
        {
          get clipPath() {
            return `url(#pos-clip-${id ?? ""})`;
          },
          get data() {
            return get(croppedX1);
          }
        },
        () => get(options),
        {
          get fill() {
            return get($0);
          },
          get fillOpacity() {
            return get($1);
          },
          get x1() {
            return get($2);
          },
          y1: { scale: null, value: 0 },
          get y2() {
            return get($3);
          }
        }
      )),
      "component",
      DifferenceY,
      139,
      4,
      { componentTag: "Area" }
    );
  }
  reset(g);
  var g_1 = sibling(g);
  var clipPath_1 = child(g_1);
  var node_2 = child(clipPath_1);
  {
    let $0 = user_derived(() => get(options).negativeFill || "blue");
    let $1 = user_derived(() => coalesce(get(x12), get(x22), get(x2)));
    let $2 = user_derived(() => coalesce(get(y12), get(x1x2Differ) ? coalesce(get(y22), get(y2)) : 0));
    let $3 = user_derived(() => ({
      scale: null,
      value: plot.options.marginTop + plot.facetHeight
    }));
    add_svelte_meta(
      () => Area_default(node_2, spread_props(
        {
          get data() {
            return get(croppedX1);
          }
        },
        () => get(options),
        {
          get fill() {
            return get($0);
          },
          get x1() {
            return get($1);
          },
          get y1() {
            return get($2);
          },
          get y2() {
            return get($3);
          }
        }
      )),
      "component",
      DifferenceY,
      152,
      8,
      { componentTag: "Area" }
    );
  }
  reset(clipPath_1);
  var node_3 = sibling(clipPath_1);
  {
    let $0 = user_derived(() => get(options).negativeFill || "cyan");
    let $1 = user_derived(() => coalesce(get(options).negativeFillOpacity, get(options).fillOpacity, 1));
    let $2 = user_derived(() => coalesce(get(x22), get(x2)));
    let $3 = user_derived(() => coalesce(get(y22), get(y2)));
    add_svelte_meta(
      () => Area_default(node_3, spread_props(
        {
          get clipPath() {
            return `url(#neg-clip-${id ?? ""})`;
          },
          get data() {
            return get(croppedX2);
          }
        },
        () => get(options),
        {
          get fill() {
            return get($0);
          },
          get fillOpacity() {
            return get($1);
          },
          get x1() {
            return get($2);
          },
          y1: { scale: null, value: 0 },
          get y2() {
            return get($3);
          }
        }
      )),
      "component",
      DifferenceY,
      161,
      4,
      { componentTag: "Area" }
    );
  }
  reset(g_1);
  var node_4 = sibling(g_1);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_5 = first_child(fragment_1);
      {
        let $0 = user_derived(() => strict_equals(get(stroke), true) ? "currentColor" : get(stroke));
        let $1 = user_derived(() => coalesce(get(x22), get(x2)));
        let $2 = user_derived(() => coalesce(get(y22), get(y2)));
        add_svelte_meta(
          () => Line_default(node_5, spread_props(
            {
              get data() {
                return get(croppedX2);
              }
            },
            () => get(options),
            {
              get stroke() {
                return get($0);
              },
              get x() {
                return get($1);
              },
              get y() {
                return get($2);
              }
            }
          )),
          "component",
          DifferenceY,
          173,
          4,
          { componentTag: "Line" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node_4, ($$render) => {
        if (equals(get(stroke), null, false)) $$render(consequent);
      }),
      "if",
      DifferenceY,
      171,
      0
    );
  }
  template_effect(() => {
    set_class(g, 0, `positive difference ${(get(className) || "") ?? ""}`);
    set_attribute(clipPath, "id", `pos-clip-${id ?? ""}`);
    set_class(g_1, 0, `negative difference ${(get(className) || "") ?? ""}`);
    set_attribute(clipPath_1, "id", `neg-clip-${id ?? ""}`);
  });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DifferenceY = hmr(DifferenceY);
  import.meta.hot.accept((module) => {
    DifferenceY[HMR].update(module.default);
  });
}
var DifferenceY_default = DifferenceY;

// node_modules/svelteplot/dist/marks/helpers/DotCanvas.svelte
DotCanvas[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/DotCanvas.svelte";
function DotCanvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DotCanvas);
  const plot = usePlot();
  function drawSymbolPath(symbolType, size, context) {
    return Symbol2(maybeSymbol(symbolType), size).context(context)();
  }
  let _markOptions = tag_proxy(proxy($$props.mark.options), "_markOptions");
  const renderDots = (canvas) => {
    const context = canvas.getContext("2d");
    user_effect(() => {
      if (context) {
        context.resetTransform();
        context.scale(devicePixelRatio.current ?? 1, devicePixelRatio.current ?? 1);
        for (const datum of $$props.data) {
          if (datum.valid) {
            let { fill: fill2, stroke } = datum;
            fill2 = resolveColor(fill2, canvas);
            stroke = resolveColor(stroke, canvas);
            if (stroke && strict_equals(stroke, "none", false)) {
              const strokeWidth = resolveProp(_markOptions.strokeWidth, datum.datum, 1.6);
              context.lineWidth = strokeWidth;
            }
            context.fillStyle = fill2 ? fill2 : "none";
            context.strokeStyle = stroke ? stroke : "none";
            context.translate(datum.x, datum.y);
            const size = datum.r * datum.r * Math.PI;
            context.beginPath();
            drawSymbolPath(datum.symbol, size, context);
            context.closePath();
            const { opacity = 1, fillOpacity = 1, strokeOpacity = 1 } = datum;
            if (equals(opacity, null, false)) context.globalAlpha = opacity ?? 1;
            if (equals(fillOpacity, null, false)) context.globalAlpha = (opacity ?? 1) * fillOpacity;
            if (fill2 && strict_equals(fill2, "none", false)) context.fill();
            if (equals(strokeOpacity, null, false)) context.globalAlpha = (opacity ?? 1) * strokeOpacity;
            if (stroke && strict_equals(stroke, "none", false)) context.stroke();
            context.translate(-datum.x, -datum.y);
          }
        }
      }
      return () => {
        context?.clearRect(0, 0, plot.width * (devicePixelRatio.current ?? 1), plot.height * (devicePixelRatio.current ?? 1));
      };
    });
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => CanvasLayer_default(node, { [createAttachmentKey()]: renderDots }), "component", DotCanvas, 94, 0, { componentTag: "CanvasLayer" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DotCanvas = hmr(DotCanvas);
  import.meta.hot.accept((module) => {
    DotCanvas[HMR].update(module.default);
  });
}
var DotCanvas_default = DotCanvas;

// node_modules/svelteplot/dist/marks/Dot.svelte
Dot[FILENAME] = "node_modules/svelteplot/dist/marks/Dot.svelte";
var root_63 = add_locations(from_svg(`<path></path>`), Dot[FILENAME], [[106, 28]]);
var root_116 = add_locations(from_svg(`<g><!></g>`), Dot[FILENAME], [[92, 8]]);
function Dot($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dot);
  const DEFAULTS = { ...getPlotDefaults().dot };
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), canvas = tag(user_derived(() => fallback(get($$d).canvas, false)), "canvas"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), dotClass = tag(user_derived(() => fallback(get($$d).dotClass, null)), "dotClass"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "canvas", "class", "dotClass"])), "options");
  const plot = usePlot();
  function getSymbolPath(symbolType, size) {
    return Symbol2(maybeSymbol(symbolType), size)();
  }
  const args = tag(
    user_derived(() => sort2(recordizeXY({
      data: get(data),
      // sort by descending radius by default
      ...get(options).r && !isOrdinalScale(plot.scales.x.type) && !isOrdinalScale(plot.scales.y.type) ? { sort: { channel: "-r" } } : {},
      ...get(options),
      ...strict_equals(get(options).fill, true) ? { fill: "currentColor" } : {}
    }))),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Dot, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      var g = root_116();
      var node_1 = child(g);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          add_svelte_meta(
            () => DotCanvas_default(node_2, {
              get data() {
                return scaledData();
              },
              get mark() {
                return mark();
              }
            }),
            "component",
            Dot,
            94,
            16,
            { componentTag: "DotCanvas" }
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(
            () => each(node_3, 17, scaledData, index, ($$anchor4, d) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              {
                var consequent_1 = ($$anchor5) => {
                  const computed_const = tag(
                    user_derived(() => {
                      const [style, styleClass] = resolveStyles(plot, get(d), { strokeWidth: 1.6, ...get(args) }, "stroke", usedScales());
                      return { style, styleClass };
                    }),
                    "[@const]"
                  );
                  get(computed_const);
                  var fragment_4 = comment();
                  var node_5 = first_child(fragment_4);
                  add_svelte_meta(
                    () => Anchor_default(node_5, {
                      get options() {
                        return get(options);
                      },
                      get datum() {
                        return get(d).datum;
                      },
                      children: wrap_snippet(Dot, ($$anchor6, $$slotProps) => {
                        var path2 = root_63();
                        attach(path2, () => addEventHandlers({ plot, options: get(args), datum: get(d)?.datum }));
                        template_effect(
                          ($0, $1) => {
                            set_attribute(path2, "transform", `translate(${get(d).x ?? ""}, ${get(d).y ?? ""})`);
                            set_attribute(path2, "d", $0);
                            set_class(path2, 0, $1);
                            set_style(path2, get(computed_const).style);
                          },
                          [
                            () => getSymbolPath(get(d).symbol, get(d).r ** 2 * Math.PI),
                            () => clsx([
                              get(dotClass) ? resolveProp(get(dotClass), get(d).datum, null) : null,
                              get(computed_const).styleClass
                            ])
                          ]
                        );
                        append($$anchor6, path2);
                      }),
                      $$slots: { default: true }
                    }),
                    "component",
                    Dot,
                    105,
                    24,
                    { componentTag: "Anchor" }
                  );
                  append($$anchor5, fragment_4);
                };
                add_svelte_meta(
                  () => if_block(node_4, ($$render) => {
                    if (get(d).valid && isValid(get(d).r)) $$render(consequent_1);
                  }),
                  "if",
                  Dot,
                  97,
                  20
                );
              }
              append($$anchor4, fragment_3);
            }),
            "each",
            Dot,
            96,
            16
          );
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (get(canvas)) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Dot,
          93,
          12
        );
      }
      reset(g);
      template_effect(() => set_class(g, 0, `dot ${(get(className) || "") ?? ""}`));
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "dot",
          required: ["x", "y"],
          channels: [
            "x",
            "y",
            "r",
            "symbol",
            "fill",
            "opacity",
            "stroke",
            "fillOpacity",
            "strokeOpacity"
          ],
          defaults: { x: 0, y: 0, r: 3, symbol: "circle" }
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Dot,
      75,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Dot = hmr(Dot);
  import.meta.hot.accept((module) => {
    Dot[HMR].update(module.default);
  });
}
var Dot_default = Dot;

// node_modules/svelteplot/dist/marks/DotX.svelte
DotX[FILENAME] = "node_modules/svelteplot/dist/marks/DotX.svelte";
function DotX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DotX);
  let data = prop($$props, "data", 19, () => [{}]), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "options");
  const args = tag(user_derived(() => recordizeX({ data: data(), ...options, y: 1 }, { withIndex: false })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Dot_default(node, spread_props(() => get(args))), "component", DotX, 19, 0, { componentTag: "Dot" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DotX = hmr(DotX);
  import.meta.hot.accept((module) => {
    DotX[HMR].update(module.default);
  });
}
var DotX_default = DotX;

// node_modules/svelteplot/dist/marks/DotY.svelte
DotY[FILENAME] = "node_modules/svelteplot/dist/marks/DotY.svelte";
function DotY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DotY);
  let data = prop($$props, "data", 19, () => [{}]), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "options");
  const args = tag(user_derived(() => recordizeY({ data: data(), ...options, x: 0 }, { withIndex: false })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Dot_default(node, spread_props(() => get(args))), "component", DotY, 18, 0, { componentTag: "Dot" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DotY = hmr(DotY);
  import.meta.hot.accept((module) => {
    DotY[HMR].update(module.default);
  });
}
var DotY_default = DotY;

// node_modules/svelteplot/dist/helpers/reduce.js
var niceReduceNames = {
  count: "Frequency",
  deviation: "Standard Deviation",
  mean: "Average"
};
var StaticReducer = {
  count: (d) => Array.from(d).length,
  min,
  max,
  mode,
  sum,
  mean,
  median,
  identity: (d) => d,
  variance,
  deviation,
  first: (d) => d[0],
  last: (d) => d.at(-1),
  difference: (d) => d.at(-1) - d[0],
  ratio: (d) => d.at(-1) / d[0]
  // TODO: proportion
  // TODO: proportion-facet
  // TODO: min-index
  // TODO: max-index
};
var Reducer = new Proxy(StaticReducer, {
  get(target, prop2) {
    if (String(prop2).charAt(0) === "p" && String(prop2).length === 3) {
      const p = +String(prop2).slice(1) / 100;
      return percentile(p);
    }
    return Reflect.get(target, prop2);
  },
  has(target, prop2) {
    if (String(prop2).charAt(0) === "p" && String(prop2).length === 3) {
      return true;
    }
    return Reflect.has(target, prop2);
  }
});
function percentile(p) {
  return (I, f) => quantile(I, p, f);
}
function isReducerName(r) {
  return typeof r === "string" && r in Reducer;
}
function mayberReducer(r) {
  if (typeof r === "function")
    return r;
  if (typeof r === "string" && isReducerName(r)) {
    return Reducer[r];
  }
  throw new Error("unknown reducer " + r);
}
function reduceOutputs(newDatum, data, options, outputs, channels, newChannels) {
  for (const k2 of outputs) {
    if (options[k2] != null) {
      const values = channels[k2] == null ? data : data.map((d) => resolveChannel(k2, d, channels));
      const reducer = mayberReducer(options[k2]);
      newDatum[`__${k2}`] = reducer(values);
      newChannels[k2] = `__${k2}`;
      if (typeof options[k2] === "string") {
        const reducerName = niceReduceNames[options[k2]] ?? `${String(options[k2]).charAt(0).toUpperCase()}${String(options[k2]).slice(1)}`;
        if (POSITION_CHANNELS.has(k2)) {
          if (typeof channels[k2] === "string") {
            newChannels[ORIGINAL_NAME_KEYS[k2]] = `${reducerName}(${channels[k2]})`;
          } else {
            newChannels[ORIGINAL_NAME_KEYS[k2]] = reducerName;
          }
        }
      }
    }
  }
}

// node_modules/svelteplot/dist/transforms/bin.js
var CHANNELS = {
  x: /* @__PURE__ */ Symbol("x"),
  x1: /* @__PURE__ */ Symbol("x1"),
  x2: /* @__PURE__ */ Symbol("x2"),
  y: /* @__PURE__ */ Symbol("y"),
  y1: /* @__PURE__ */ Symbol("y1"),
  y2: /* @__PURE__ */ Symbol("y2")
};
var ThresholdGenerators = {
  auto: thresholdScott,
  scott: thresholdScott,
  sturges: thresholdSturges,
  "freedman-diaconis": thresholdFreedmanDiaconis
};
function binBy(byDim, { data, ...channels }, options) {
  const { domain, thresholds = "auto", interval: interval2 } = options;
  const bin3 = bin();
  if (domain)
    bin3.domain(domain);
  if (interval2) {
    const [lo, hi] = extent(data.map((d) => resolveChannel(byDim, d, channels)));
    bin3.thresholds(maybeInterval(interval2).range(lo, hi));
  } else if (thresholds)
    bin3.thresholds(
      // use a generator
      typeof thresholds === "string" && ThresholdGenerators[thresholds] !== void 0 ? ThresholdGenerators[thresholds] : thresholds
    );
  bin3.value((d) => resolveChannel(byDim, d, channels));
  const outputs = [
    ...byDim === "x" ? ["y", "y1", "y2"] : ["x", "x1", "x2"],
    "fill",
    "stroke",
    "r",
    "opacity",
    "fillOpacity",
    "strokeOpacity"
  ];
  let newChannels = {
    [byDim === "x" ? "insetLeft" : "insetTop"]: 0.5,
    [byDim === "x" ? "insetRight" : "insetBottom"]: 0.5,
    ...channels,
    [`${byDim}`]: CHANNELS[byDim],
    // `__${byDim}`,
    [`${byDim}1`]: CHANNELS[`${byDim}1`],
    [`${byDim}2`]: CHANNELS[`${byDim}2`],
    [ORIGINAL_NAME_KEYS[byDim]]: typeof channels[byDim] === "string" ? channels[byDim] : null
  };
  const newData = [];
  let passedGroups = [];
  const bins = bin3(data);
  (options.cumulative < 0 ? bins.toReversed() : bins).forEach((group3) => {
    const itemBinProps = {
      [CHANNELS[`${byDim}1`]]: group3.x0,
      [CHANNELS[`${byDim}2`]]: group3.x1,
      [CHANNELS[`${byDim}`]]: isDate(group3.x0) ? new Date(Math.round((group3.x0.getTime() + group3.x1.getTime()) * 0.5)) : (group3.x0 + group3.x1) * 0.5
    };
    if (options.cumulative)
      passedGroups = [...passedGroups, ...group3];
    const newGroupChannels = groupFacetsAndZ(options.cumulative ? passedGroups : group3, channels, (items, itemGroupProps) => {
      const item = { ...itemBinProps, ...itemGroupProps };
      reduceOutputs(item, items, options, outputs, channels, newChannels);
      newData.push(item);
    });
    newChannels = { ...newChannels, ...newGroupChannels };
  });
  return { data: options.reverse ? newData.toReversed() : newData, ...newChannels };
}
function binX({ data, ...channels }, options = { thresholds: "auto", cumulative: false }) {
  return binBy("x", { data, ...channels }, options);
}
function binY({ data, ...channels }, options = { thresholds: "auto", cumulative: false }) {
  return binBy("y", { data, ...channels }, options);
}
function bin2({ data, ...channels }, options = { thresholds: "auto", cumulative: false }) {
  const { domain, thresholds = "auto", interval: interval2, cumulative = false } = options;
  const binX2 = bin();
  const binY2 = bin();
  if (domain) {
    binX2.domain(domain);
    binY2.domain(domain);
  }
  binX2.value((d) => resolveChannel("x", d, channels));
  binY2.value((d) => resolveChannel("y", d, channels));
  let yThresholds = [];
  if (interval2) {
    const [xlo, xhi] = extent(data.map((d) => resolveChannel("x", d, channels)));
    const [ylo, yhi] = extent(data.map((d) => resolveChannel("y", d, channels)));
    binX2.thresholds(maybeInterval(interval2).range(xlo, xhi));
    binY2.thresholds(yThresholds = maybeInterval(interval2).range(ylo, yhi));
  } else if (thresholds) {
    const t = typeof thresholds === "string" && ThresholdGenerators[thresholds] !== void 0 ? ThresholdGenerators[thresholds] : thresholds;
    binX2.thresholds(t);
    binY2.thresholds(t);
    yThresholds = binY2(data).slice(1).map((g) => g.x0);
    binY2.thresholds(yThresholds);
  }
  const outputs = ["fill", "stroke", "r", "opacity", "fillOpacity", "strokeOpacity"];
  let newChannels = {
    inset: 0.5,
    ...channels,
    x: CHANNELS.x,
    x1: CHANNELS.x1,
    x2: CHANNELS.x2,
    y: CHANNELS.y,
    y1: CHANNELS.y1,
    y2: CHANNELS.y2,
    [ORIGINAL_NAME_KEYS.x]: typeof channels.x === "string" ? channels.x : null,
    [ORIGINAL_NAME_KEYS.y]: typeof channels.y === "string" ? channels.y : null
  };
  const groupBy2 = channels.z ? "z" : channels.fill ? "fill" : channels.stroke ? "stroke" : true;
  const groupByPropName = groupBy2 !== true && typeof channels[groupBy2] === "string" ? channels[groupBy2] : "__group";
  if (groupBy2 !== true)
    newChannels[groupBy2] = groupByPropName;
  const newData = [];
  binX2(data).forEach((groupX2) => {
    const newRecordBaseX = {
      [CHANNELS.x1]: groupX2.x0,
      [CHANNELS.x2]: groupX2.x1,
      [CHANNELS.x]: isDate(groupX2.x0) ? new Date(Math.round((groupX2.x0.getTime() + groupX2.x1.getTime()) * 0.5)) : (groupX2.x0 + groupX2.x1) * 0.5
    };
    const [ylo, yhi] = extent(groupX2.map((d) => resolveChannel("y", d, channels)));
    const tExtentLo = yThresholds.filter((d) => d < ylo).at(-1);
    const tExtentHi = yThresholds.filter((d) => d > yhi).at(0);
    binY2(groupX2).forEach((groupY2, i) => {
      if (groupY2.length === 0)
        return;
      const y12 = groupY2.x0 === ylo ? tExtentLo : groupY2.x0;
      const y2 = groupY2.x1 === yhi ? tExtentHi : groupY2.x1;
      const newRecordBaseY = {
        ...newRecordBaseX,
        [CHANNELS.y1]: y12,
        [CHANNELS.y2]: y2,
        [CHANNELS.y]: isDate(y12) ? new Date(Math.round((y12.getTime() + y2.getTime()) * 0.5)) : (y12 + y2) * 0.5
      };
      const newGroupChannels = groupFacetsAndZ(groupY2, channels, (items, itemGroupProps) => {
        const newRecord = {
          ...newRecordBaseY,
          ...itemGroupProps
        };
        reduceOutputs(newRecord, items, options, outputs, channels, newChannels);
        newData.push(newRecord);
      });
      newChannels = { ...newChannels, ...newGroupChannels };
    });
  });
  return { data: options.reverse ? newData.toReversed() : newData, ...newChannels };
}

// node_modules/svelteplot/dist/transforms/bollinger.js
function bollingerX(args, options = {}) {
  return bollingerDim("x", args, options);
}
function bollingerY(args, options = {}) {
  return bollingerDim("y", args, options);
}
function bollingerDim(dim, { data, ...channels }, options = {}) {
  const { n = 20, k: k2 = 2 } = options;
  const bands = bollinger(data.map((datum) => resolveChannel(dim, datum, channels)), n, [-k2, 0, k2]);
  const otherDim = dim === "x" ? "y" : "x";
  return {
    data: data.map((datum, i) => ({
      __x: resolveChannel(otherDim, datum, channels),
      __lo: bands[0][i],
      __avg: bands[1][i],
      __hi: bands[2][i]
    })),
    ...channels,
    [otherDim]: "__x",
    [dim]: "__avg",
    [`${otherDim}1`]: "__x",
    [`${dim}1`]: "__lo",
    [`${dim}2`]: "__hi"
  };
}
function bollinger(values, N, K2) {
  let i = 0;
  let sum4 = 0;
  let sumSquared = 0;
  const bands = K2.map(() => new Float64Array(values.length).fill(NaN));
  for (let n = Math.min(N - 1, values.length); i < n; ++i) {
    const value = values[i];
    sum4 += value, sumSquared += value ** 2;
  }
  for (let n = values.length, m = bands.length; i < n; ++i) {
    const value = values[i];
    sum4 += value, sumSquared += value ** 2;
    const mean3 = sum4 / N;
    const deviation2 = Math.sqrt((sumSquared - sum4 ** 2 / N) / (N - 1));
    for (let j = 0; j < K2.length; ++j) {
      bands[j][i] = mean3 + deviation2 * K2[j];
    }
    const value0 = values[i - N + 1];
    sum4 -= value0, sumSquared -= value0 ** 2;
  }
  return bands;
}

// node_modules/svelteplot/dist/transforms/centroid.js
var CENTROID = /* @__PURE__ */ Symbol("centroid");
function geoCentroid({ data, ...options }) {
  const transformedData = data.map((d) => ({
    ...d,
    [CENTROID]: centroid_default(resolveProp(options.geometry, d, d))
  }));
  const newOptions = { ...options };
  return {
    data: transformedData,
    ...newOptions,
    x: (d) => d[CENTROID][0],
    y: (d) => d[CENTROID][1]
  };
}

// node_modules/svelteplot/dist/transforms/density.js
var KERNEL = {
  uniform(u) {
    if (u <= 1 && u >= -1)
      return 0.5;
    return 0;
  },
  triangular(u) {
    if (u <= 1 && u >= -1)
      return 1 - Math.abs(u);
    return 0;
  },
  epanechnikov(u) {
    if (u <= 1 && u >= -1)
      return 0.75 * (1 - u * u);
    return 0;
  },
  quartic(u) {
    if (u <= 1 && u >= -1) {
      const tmp = 1 - u * u;
      return 15 / 16 * tmp * tmp;
    }
    return 0;
  },
  triweight(u) {
    if (u <= 1 && u >= -1) {
      const tmp = 1 - u * u;
      return 35 / 32 * tmp * tmp * tmp;
    }
    return 0;
  },
  gaussian(u) {
    return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * u * u);
  },
  cosine(u) {
    if (u <= 1 && u >= -1)
      return Math.PI / 4 * Math.cos(Math.PI / 2 * u);
    return 0;
  }
};
function densityX(args, options) {
  return density1d("x", args, options);
}
function densityY(args, options) {
  return density1d("y", args, options);
}
var CHANNELS2 = {
  x: /* @__PURE__ */ Symbol("x"),
  y: /* @__PURE__ */ Symbol("y")
};
var BANDWIDTH_FACTOR = {
  gaussian: 0.9,
  epanechnikov: 2.34,
  uniform: 1.06,
  triangular: 1.34,
  quartic: 2.78,
  triweight: 3.15,
  cosine: 1.06
};
function bandwidthSilverman(x2) {
  const iqr = quantileSorted(x2, 0.75) - quantileSorted(x2, 0.25);
  const xvar = variance(x2);
  const hi = Math.sqrt(xvar);
  let lo;
  if (!(lo = Math.min(hi, iqr / 1.34))) {
    (lo = hi) || (lo = Math.abs(x2[1])) || (lo = 1);
  }
  return lo * Math.pow(x2.length, -0.2);
}
var VALUE = /* @__PURE__ */ Symbol("value");
var WEIGHT = /* @__PURE__ */ Symbol("weight");
function roundToTerminating(x2, sig = 2) {
  if (!isFinite(x2) || x2 === 0)
    return x2;
  const exp2 = Math.floor(Math.log10(Math.abs(x2)));
  const decimals = Math.max(0, sig - 1 - exp2);
  const factor = 10 ** decimals;
  return Math.round(x2 * factor) / factor;
}
function density1d(independent, { data, weight, ...channels }, options = {}) {
  const densityChannel = independent === "x" ? "y" : "x";
  const { kernel, bandwidth, interval: interval2, trim: trim2, channel, cumulative } = {
    kernel: "epanechnikov",
    bandwidth: bandwidthSilverman,
    interval: void 0,
    trim: false,
    cumulative: false,
    channel: densityChannel,
    ...options
  };
  const k2 = maybeKernel(kernel || KERNEL.epanechnikov);
  const outData = [];
  const isRawDataArray = Array.isArray(data) && !isDataRecord_default(data[0]) && channels[independent] == null;
  const resolvedData = (isRawDataArray ? data.map((d) => ({
    [VALUE]: d,
    [WEIGHT]: typeof weight === "function" ? weight(d) : 1
  })) : data.map((d) => ({
    [VALUE]: resolveChannel(independent, d, channels),
    [WEIGHT]: typeof weight === "function" ? weight(d) : 1,
    ...d
  }))).filter((d) => isValid(d[VALUE]) && isValid(d[WEIGHT]) && d[WEIGHT] >= 0);
  const values = resolvedData.map((d) => d[VALUE]);
  const bw = typeof bandwidth === "function" ? (BANDWIDTH_FACTOR[kernel] ?? 1) * bandwidth(values.toSorted((a2, b) => a2 - b)) : bandwidth;
  const I = maybeInterval(interval2 ?? roundToTerminating(bw / 5));
  let [min3, max3] = extent(values);
  if (!trim2) {
    const r = max3 - min3;
    min3 = I.floor(min3 - r * 0.2);
    max3 = I.floor(max3 + r * 0.2);
  }
  const atValues = I.range(I.floor(min3), I.offset(max3)).map((d) => +d.toFixed(5));
  const res = groupFacetsAndZ(resolvedData, channels, (items, groupProps) => {
    const values2 = items.map((d) => d[VALUE]);
    const weights = items.map((d) => d[WEIGHT]);
    let kdeValues = kde1d(values2, weights, atValues, k2, bw, cumulative).filter(([x2, density]) => x2 != null && !isNaN(density)).sort((a2, b) => a2[0] - b[0]);
    if (!trim2) {
      const firstNonZero = kdeValues.findIndex(([x2, v]) => v > 0);
      const lastNonZero = kdeValues.length - 1 - [...kdeValues].reverse().findIndex(([x2, v]) => v > 0);
      kdeValues = kdeValues.slice(firstNonZero < 1 ? 0 : firstNonZero - 1, lastNonZero < 0 ? kdeValues.length : lastNonZero + 1);
    }
    outData.push(...kdeValues.map(([x2, density]) => ({
      ...groupProps,
      [CHANNELS2.x]: independent === "x" ? x2 : density,
      [CHANNELS2.y]: independent === "y" ? x2 : density
    })));
  });
  return {
    [independent]: CHANNELS2[independent],
    [channel]: CHANNELS2[densityChannel],
    ...res,
    [ORIGINAL_NAME_KEYS[densityChannel]]: cumulative === false ? "Density" : "CDF",
    [ORIGINAL_NAME_KEYS[independent]]: typeof channels[independent] === "string" ? channels[independent] : void 0,
    sort: [{ channel: CHANNELS2[independent], order: "ascending" }],
    data: outData
  };
}
function kde1d(values, weights, atValues, kernel, bw, cumulative) {
  const n = values.length;
  const weightSum = weights.reduce((a2, b) => a2 + b, 0);
  const densities = atValues.map((x2) => {
    let sum4 = 0;
    for (let i = 0; i < n; i++) {
      const u = (x2 - values[i]) / bw;
      sum4 += weights[i] * kernel(u);
    }
    return [x2, sum4 / (weightSum * bw)];
  });
  if (!cumulative)
    return densities;
  const totalArea = densities.reduce((acc, curr, i) => {
    if (i === 0)
      return acc;
    const dx = densities[i][0] - densities[i - 1][0];
    return acc + (densities[i - 1][1] + curr[1]) / 2 * dx;
  }, 0);
  if (totalArea === 0)
    return densities;
  if (cumulative === -1) {
    let area2 = 0;
    const cdf2 = new Array(densities.length);
    for (let i = densities.length - 1; i >= 0; i--) {
      if (i < densities.length - 1) {
        const dx = densities[i + 1][0] - densities[i][0];
        area2 += (densities[i + 1][1] + densities[i][1]) / 2 * dx;
      }
      cdf2[i] = [densities[i][0], area2 / totalArea];
    }
    return cdf2;
  }
  let area = 0;
  const cdf = new Array(densities.length);
  for (let i = 0; i < densities.length; i++) {
    if (i > 0) {
      const dx = densities[i][0] - densities[i - 1][0];
      area += (densities[i - 1][1] + densities[i][1]) / 2 * dx;
    }
    cdf[i] = [densities[i][0], area / totalArea];
  }
  return cdf;
}
function maybeKernel(kernel) {
  if (typeof kernel === "function")
    return kernel;
  return KERNEL[kernel] || KERNEL.epanechnikov;
}

// node_modules/svelteplot/dist/transforms/map.js
function map4(args, options) {
  const { data, ...channels } = sort2(args);
  const newChannels = {};
  const newData = [];
  groupFacetsAndZ(data, channels, (groupedData) => {
    for (const [channel, map5] of Object.entries(options)) {
      const mapper = maybeMap(map5);
      const values = groupedData.map((d) => resolveChannel(channel, d, channels));
      const indices = groupedData.map((d, i) => i);
      const mappedValues = new Array(values.length);
      mapper.mapIndex(indices, values, mappedValues);
      newChannels[channel] = `__${channel}`;
      for (let i = 0; i < values.length; ++i) {
        const datum = { ...groupedData[i], [`__${channel}`]: mappedValues[i] };
        newData.push(datum);
      }
    }
  });
  return { data: newData, ...channels, ...newChannels };
}
function mapX(args, mapper) {
  let { x: x2, x1: x12, x2: x22 } = args;
  if (x2 === void 0 && x12 === void 0 && x22 === void 0)
    args = { ...args, x: identity5 };
  const outputs = {};
  if (x2 != null)
    outputs.x = mapper;
  if (x12 != null)
    outputs.x1 = mapper;
  if (x22 != null)
    outputs.x2 = mapper;
  return map4(args, outputs);
}
function mapY(args, mapper) {
  let { y: y2, y1: y12, y2: y22 } = args;
  if (y2 === void 0 && y12 === void 0 && y22 === void 0)
    args = { ...args, y: identity5 };
  const outputs = {};
  if (y2 != null)
    outputs.y = mapper;
  if (y12 != null)
    outputs.y1 = mapper;
  if (y22 != null)
    outputs.y2 = mapper;
  return map4(args, outputs);
}
function maybeMap(map5) {
  if (map5 == null)
    throw new Error("missing map");
  if (typeof map5 === "object" && typeof map5.mapIndex === "function")
    return map5;
  if (typeof map5 === "function")
    return mapFunction(map5);
  switch (`${map5}`.toLowerCase()) {
    case "cumsum":
      return mapCumsum;
    case "rank":
      return mapFunction((I, V) => rank(I, (i) => V[i]));
    case "quantile":
      return mapFunction((I, V) => rankQuantile(I, (i) => V[i]));
  }
  throw new Error(`invalid map: ${map5}`);
}
function rankQuantile(I, f) {
  const n = count(I, f) - 1;
  return rank(I, f).map((r) => r / n);
}
function mapFunction(f) {
  return {
    mapIndex(I, S2, T) {
      const M2 = f(I, S2);
      if (M2.length !== I.length)
        throw new Error("map function returned a mismatched length");
      for (let i = 0, n = I.length; i < n; ++i)
        T[I[i]] = M2[i];
    }
  };
}
var mapCumsum = {
  mapIndex(I, S2, T) {
    let sum4 = 0;
    for (const i of I)
      T[i] = sum4 += S2[i];
  }
};

// node_modules/svelteplot/dist/transforms/normalize.js
function normalizeX(args, basis2) {
  return mapX(args, normalize2(basis2));
}
function normalizeY(args, basis2) {
  return mapY(args, normalize2(basis2));
}
function normalize2(basis2) {
  if (basis2 === void 0)
    return normalizeFirst;
  if (typeof basis2 === "function")
    return normalizeBasis(basis2);
  switch (`${basis2}`.toLowerCase()) {
    case "deviation":
      return normalizeDeviation;
    case "first":
      return normalizeFirst;
    case "last":
      return normalizeLast;
    case "max":
      return normalizeMax;
    case "mean":
      return normalizeMean;
    case "median":
      return normalizeMedian;
    case "min":
      return normalizeMin;
    case "sum":
      return normalizeSum;
    case "extent":
      return normalizeExtent;
  }
  throw new Error(`invalid basis: ${basis2}`);
}
function normalizeBasis(basis2) {
  return {
    mapIndex(I, S2, T) {
      const b = +basis2(I, S2);
      for (const i of I) {
        T[i] = S2[i] === null ? NaN : S2[i] / b;
      }
    }
  };
}
function normalizeAccessor(f) {
  return normalizeBasis((I, S2) => f(I, (i) => S2[i]));
}
var normalizeExtent = {
  mapIndex(I, S2, T) {
    const [s1, s2] = extent(I, (i) => S2[i]);
    const d = s2 - s1;
    for (const i of I) {
      T[i] = S2[i] === null ? NaN : (S2[i] - s1) / d;
    }
  }
};
var normalizeFirst = normalizeBasis((I, S2) => {
  for (let i = 0; i < I.length; ++i) {
    const s2 = S2[I[i]];
    if (s2 != null && isFinite(s2))
      return s2;
  }
});
var normalizeLast = normalizeBasis((I, S2) => {
  for (let i = I.length - 1; i >= 0; --i) {
    const s2 = S2[I[i]];
    if (s2 != null && isFinite(s2))
      return s2;
  }
});
var normalizeDeviation = {
  mapIndex(I, S2, T) {
    const m = mean(I, (i) => S2[i]);
    const d = deviation(I, (i) => S2[i]);
    for (const i of I) {
      T[i] = S2[i] === null ? NaN : d ? (S2[i] - m) / d : 0;
    }
  }
};
var normalizeMax = normalizeAccessor(max);
var normalizeMean = normalizeAccessor(mean);
var normalizeMedian = normalizeAccessor(median);
var normalizeMin = normalizeAccessor(min);
var normalizeSum = normalizeAccessor(sum);
function normalizeParallelY(args, basis2) {
  return sort2({
    ...normalizeY({
      ...args,
      // use x as the grouping variable for normalization to normalize
      // each axis independently
      z: args.x
    }, basis2),
    // restore original grouping by line
    z: args.z,
    // sort by original order
    sort: args.z
  });
}
function normalizeParallelX(args, basis2) {
  return sort2({
    ...normalizeX({
      ...args,
      // use x as the grouping variable for normalization to normalize
      // each axis independently
      z: args.y
    }, basis2),
    // restore original grouping by line
    z: args.z,
    // sort by original order
    sort: args.z
  });
}

// node_modules/svelteplot/dist/transforms/group.js
function group2({ data, ...channels }, options = {}) {
  if (channels.x == null || channels.y == null)
    throw new Error("you must provide an x and y channel to group on");
  const groups2 = groups(data.filter((d) => testFilter(d, channels)), (d) => resolveChannel("x", d, channels), (d) => resolveChannel("y", d, channels));
  const newData = [];
  const xChannel = typeof channels.x === "string" ? channels.x : "__x";
  const yChannel = typeof channels.y === "string" ? channels.y : "__y";
  let newChannels = omit({ ...channels, x: xChannel, y: yChannel }, "filter");
  const outputs = ["fill", "stroke", "r", "opacity", "fillOpacity", "strokeOpacity"];
  groups2.forEach(([xGroupKey, xGroups]) => {
    xGroups.forEach(([yGroupKey, items]) => {
      const baseRecord = { [xChannel]: xGroupKey, [yChannel]: yGroupKey };
      options.copy?.forEach((prop2) => {
        baseRecord[prop2] = items[0][prop2];
      });
      const newGroupChannels = groupFacetsAndZ(items, channels, (items2, itemGroupProps) => {
        const item = { ...baseRecord, ...itemGroupProps };
        reduceOutputs(item, items2, options, outputs, channels, newChannels);
        newData.push(item);
      });
      newChannels = { ...newChannels, ...newGroupChannels };
    });
  });
  return { data: newData, ...newChannels };
}
function groupX(input, options = {}) {
  return groupXYZ("x", input, options);
}
function groupY(input, options = {}) {
  return groupXYZ("y", input, options);
}
function groupZ(input, options = {}) {
  return groupXYZ("z", input, options);
}
var groupDimRaw = /* @__PURE__ */ Symbol("groupDimRaw");
function groupXYZ(dim, { data, ...channels }, options = {}) {
  if ((dim === "z" ? channels.z || channels.fill || channels.stroke || channels.fx || channels.fy : channels[dim]) == null)
    throw new Error("you must provide a channel to group on " + dim);
  const propName = options[`${dim}PropName`] != null ? options[`${dim}PropName`] : typeof channels[dim] === "string" && !options.interval ? channels[dim] : `__${dim}`;
  const interval2 = options.interval ? maybeInterval(options.interval) : null;
  const groups2 = dim === "z" ? [[null, data]] : groups(data.filter((d) => testFilter(d, channels)).map((d) => ({ ...d, [groupDimRaw]: resolveChannel(dim, d, channels) })).filter((d) => isValid(d[groupDimRaw])), (d) => {
    return interval2 ? interval2.floor(d[groupDimRaw]) : d[groupDimRaw];
  });
  const newData = [];
  let newChannels = omit({ ...channels }, "filter");
  if (dim !== "z")
    newChannels[dim] = propName;
  const outputs = [
    ...dim === "x" ? ["y", "y1", "y2"] : dim === "y" ? ["x", "x1", "x2"] : ["x", "x1", "x2", "y", "y1", "y2"],
    "fill",
    "stroke",
    "r",
    "opacity",
    "fillOpacity",
    "strokeOpacity"
  ];
  groups2.forEach(([groupKey, items]) => {
    const baseRecord = dim === "z" ? {} : { [propName]: groupKey };
    const newGroupChannels = groupFacetsAndZ(items, channels, (items2, itemGroupProps) => {
      const copiedProps = {};
      options.copy?.forEach((prop2) => {
        copiedProps[prop2] = items2[0][prop2];
      });
      const item = { ...baseRecord, ...copiedProps, ...itemGroupProps };
      reduceOutputs(item, items2, options, outputs, channels, newChannels);
      newData.push(item);
    });
    newChannels = { ...newChannels, ...newGroupChannels };
  });
  return { data: newData, ...newChannels };
}

// node_modules/svelteplot/dist/transforms/interval.js
function intervalX(args, { plot }) {
  return interval("x", plot, args);
}
function intervalY(args, { plot }) {
  return interval("y", plot, args);
}
function interval(dim, plot, { data, ...options }) {
  if (options.interval && options[dim] && options[`${dim}1`] == null && options[`${dim}2`] == null) {
    const interval2 = maybeInterval(options.interval);
    const newData = data.map((row) => {
      const val = resolveChannel(dim, row, options);
      return {
        ...row,
        [`__${dim}1`]: interval2.floor(val),
        [`__${dim}2`]: interval2.offset(interval2.floor(val))
      };
    });
    return {
      data: newData,
      // set default inset
      [`inset${dim === "x" ? "Right" : "Bottom"}`]: 1,
      ...options,
      [`${dim}1`]: `__${dim}1`,
      [`${dim}2`]: `__${dim}2`
    };
  }
  return { data, ...options };
}

// node_modules/svelteplot/dist/transforms/jitter.js
var JITTER = {
  x: /* @__PURE__ */ Symbol("jitterX"),
  x1: /* @__PURE__ */ Symbol("jitterX1"),
  x2: /* @__PURE__ */ Symbol("jitterX2"),
  y: /* @__PURE__ */ Symbol("jitterY"),
  y1: /* @__PURE__ */ Symbol("jitterY1"),
  y2: /* @__PURE__ */ Symbol("jitterY2")
};
function jitterX(args, options) {
  return jitter(args, { x: options });
}
function jitterY(args, options) {
  return jitter(args, { y: options });
}
function jitter({ data, ...channels }, options) {
  const jitterChannels = Object.keys(options).filter((ch) => channels[ch]);
  if (!jitterChannels.length)
    return {
      data,
      ...channels
    };
  const jitterFns = Object.fromEntries(Object.entries(options).map(([key2, opts]) => {
    opts.type = opts.type ?? "uniform";
    const width = opts?.type === "uniform" ? parseNumber(opts?.width ?? 0.35) : 0;
    const std = opts?.type === "normal" ? parseNumber(opts?.std ?? 0.15) : 0;
    const rng = opts?.source ?? Math.random;
    const random2 = opts?.type === "uniform" ? uniform_default.source(rng)(-width, width) : normal_default.source(rng)(0, std);
    return [key2, random2];
  }));
  return {
    data: data.map((row) => {
      let newRow = { ...row };
      jitterChannels.forEach((channel) => {
        const value = resolveChannel(channel, row, channels);
        const random2 = jitterFns[channel];
        const accKey = JITTER[channel];
        newRow = {
          ...newRow,
          [accKey]: typeof value === "number" ? value + random2() : isDate(value) ? new Date(value.getTime() + random2()) : value
        };
      });
      return newRow;
    }),
    ...channels,
    // point the jittered channels to new accessor symbols
    ...Object.fromEntries(jitterChannels.map((channel) => [channel, JITTER[channel]]))
  };
}
function parseNumber(value) {
  if (typeof value === "number")
    return value;
  if (typeof value === "string") {
    try {
      const [name, period] = parseTimeInterval(value);
      return (durations.get(name) ?? 0) * period;
    } catch (err) {
      return 0;
    }
  }
  return 0;
}

// node_modules/svelteplot/dist/transforms/select.js
function select({ data, ...channels }, options) {
  const newData = [];
  groupFacetsAndZ(data, channels, (items) => {
    if (typeof options === "string") {
      if (options !== "first" && options !== "last")
        throw new Error("unknown sort option: " + options);
      newData.push(options === "first" ? items[0] : items.at(-1));
    } else {
      const sortOptions = Object.entries(options);
      if (!sortOptions.length)
        throw new Error("must provide the channel to sort by");
      if (sortOptions.length > 1)
        throw new Error("cannot sort by more than one channel");
      if (sortOptions[0][1] !== "min" && sortOptions[0][1] !== "max")
        throw new Error("unknown sort option: " + sortOptions[0][1]);
      const selected = items.map((item) => ({
        ...item,
        __sortby: resolveChannel(sortOptions[0][0], item, channels)
      })).sort((a2, b) => a2.__sortby > b.__sortby ? 1 : a2.__sortby < b.__sortby ? -1 : 0).at(sortOptions[0][1] === "min" ? 0 : -1);
      newData.push(selected);
    }
  });
  return { data: newData, ...channels };
}
function selectFirst(args) {
  return select(args, "first");
}
function selectLast(args) {
  return select(args, "last");
}
function selectMinX(args) {
  return select(args, { x: "min" });
}
function selectMaxX(args) {
  return select(args, { x: "max" });
}
function selectMinY(args) {
  return select(args, { y: "min" });
}
function selectMaxY(args) {
  return select(args, { y: "max" });
}

// node_modules/svelteplot/dist/transforms/shift.js
function shiftX({ data, ...channels }, shiftBy) {
  if (typeof shiftBy === "number" || typeof shiftBy === "string") {
    shiftBy = { x: shiftBy };
  }
  if (shiftBy) {
    if (shiftBy)
      return shiftChannels("x", shiftBy, { data, ...channels });
  }
  return { data, ...channels };
}
function shiftY({ data, ...channels }, shiftBy) {
  if (typeof shiftBy === "number" || typeof shiftBy === "string") {
    shiftBy = { y: shiftBy };
  }
  if (shiftBy)
    return shiftChannels("y", shiftBy, { data, ...channels });
  return { data, ...channels };
}
function shiftChannels(shiftDim, shiftBy, { data, ...channels }) {
  return {
    data: data.map((d) => {
      const newRow = { ...d };
      for (const [channel, shift] of Object.entries(shiftBy)) {
        const shiftFrom = channels[channel] != null ? channel : shiftDim;
        if (typeof shift === "number") {
          newRow[`__shift_${channel}`] = resolveChannel(shiftFrom, d, channels) + shift;
        } else if (typeof shift === "string") {
          const [, sign3, value, unit2] = shift.match(/^([+-])?(\d+)? ?([a-z]+)$/);
          const step = (sign3 === "-" ? -1 : 1) * (value || 1);
          const interval2 = maybeTimeInterval(unit2);
          if (!interval2)
            throw new Error(`Invalid shift interval: ${shift}`);
          newRow[`__shift_${channel}`] = interval2.offset(resolveChannel(shiftFrom, d, channels), step);
        }
      }
      return newRow;
    }),
    ...channels,
    ...Object.fromEntries(Object.keys(shiftBy).map((key2) => [key2, `__shift_${key2}`]))
  };
}

// node_modules/svelteplot/dist/transforms/window.js
function windowX(args, options) {
  return windowDim("x", args, options);
}
function windowY(args, options) {
  return windowDim("y", args, options);
}
function windowDim(dim, { data, ...channels }, options) {
  const { anchor = "middle", reduce: reduce2 = "mean", strict = false } = options;
  let { k: k2, interval: interval2 } = options;
  interval2 = maybeInterval(interval2, "time");
  if (!((k2 = Math.floor(k2)) > 0))
    throw new Error(`invalid k: ${k2}`);
  const reduceFn = mayberReducer(reduce2);
  const groupBy2 = channels.z != null ? "z" : channels.fill != null ? "fill" : channels.stroke != null ? "stroke" : false;
  const groups2 = groupBy2 ? groups(data, (d) => resolveChannel(groupBy2, d, channels)).map(([, v]) => v) : [data];
  const out = [];
  const reduceChannels = [dim, `${dim}1`, `${dim}2`].filter((d) => channels[d] != null);
  const shift = anchor === "start" ? 0 : anchor === "end" ? k2 - 1 : k2 - 1 >> 1;
  for (const values of groups2) {
    const X3 = values.map((d) => Object.fromEntries(reduceChannels.map((channel) => [channel, resolveChannel(channel, d, channels)])));
    const Y3 = interval2 ? values.map((d, index3) => ({
      index: index3,
      value: resolveChannel(dim === "x" ? "y" : "x", d, channels)
    })) : [];
    const L = values.length;
    for (let i = 0; i < L; i++) {
      const s0 = Math.max(0, i - shift);
      const newDatum = { ...values[i] };
      let yWindow = /* @__PURE__ */ new Set();
      if (interval2) {
        const minDate = interval2.offset(Y3[i].value, -shift);
        const maxDate = interval2.offset(Y3[i].value, -shift + k2);
        yWindow = new Set(Y3.filter(({ value }) => value >= minDate && value <= maxDate).map(({ index: index3 }) => index3));
      }
      for (const channel of reduceChannels) {
        const window2 = (interval2 ? (
          // we select X values based on the interval
          X3.filter((d, i2) => yWindow.has(i2))
        ) : X3.slice(s0, Math.min(L, i - shift + k2))).map((d) => d[channel]).filter(isValid);
        const reduced = strict && window2.length < (strict === true ? k2 : strict) ? null : reduceFn(window2);
        newDatum[`__reduced_${channel}__`] = reduced;
      }
      out.push(newDatum);
    }
  }
  return {
    data: out,
    ...channels,
    ...Object.fromEntries(reduceChannels.map((channel) => [channel, `__reduced_${channel}__`]))
  };
}

// node_modules/svelteplot/dist/marks/helpers/GeoCanvas.svelte
GeoCanvas[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/GeoCanvas.svelte";
function GeoCanvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GeoCanvas);
  const plot = usePlot();
  function maybeOpacity(value) {
    return equals(value, null) ? 1 : +value;
  }
  const render = (canvas) => {
    const context = canvas.getContext("2d");
    user_effect(() => {
      $$props.path.context(context);
      if (context) {
        context.resetTransform();
        context.scale(devicePixelRatio.current ?? 1, devicePixelRatio.current ?? 1);
        let currentColor;
        for (const d of $$props.data) {
          if (!d.valid) continue;
          const geometry = resolveProp($$props.mark.options.geometry, d.datum, d.datum);
          let { stroke, fill: fill2, ...restStyles } = resolveScaledStyleProps(d.datum, $$props.mark.options, $$props.usedScales, plot, GEOJSON_PREFER_STROKE.has(geometry.type) ? "stroke" : "fill");
          const opacity = maybeOpacity(restStyles["opacity"]);
          const fillOpacity = maybeOpacity(restStyles["fill-opacity"]);
          const strokeOpacity = maybeOpacity(restStyles["stroke-opacity"]);
          if (strict_equals(`${fill2}`.toLowerCase(), "currentcolor")) fill2 = currentColor || (currentColor = getComputedStyle(canvas?.parentElement?.parentElement).getPropertyValue("color"));
          if (strict_equals(`${stroke}`.toLowerCase(), "currentcolor")) stroke = currentColor || (currentColor = getComputedStyle(canvas?.parentElement?.parentElement).getPropertyValue("color"));
          if (CSS_VAR.test(fill2)) fill2 = getComputedStyle(canvas).getPropertyValue(fill2.slice(4, -1));
          if (CSS_VAR.test(stroke)) stroke = getComputedStyle(canvas).getPropertyValue(stroke.slice(4, -1));
          if (stroke && strict_equals(stroke, "none", false)) {
            const strokeWidth = resolveProp($$props.mark.options.strokeWidth, d.datum, 1);
            context.lineWidth = strokeWidth ?? 1;
          }
          context.fillStyle = fill2 ? fill2 : "none";
          context.strokeStyle = stroke ? stroke : "none";
          context.lineJoin = "round";
          context.beginPath();
          $$props.path(geometry);
          context.closePath();
          if (equals(opacity, null, false)) context.globalAlpha = opacity;
          if (equals(fillOpacity, null, false)) context.globalAlpha = opacity * fillOpacity;
          if (fill2 && strict_equals(fill2, "none", false)) context.fill();
          if (equals(strokeOpacity, null, false)) context.globalAlpha = opacity * strokeOpacity;
          if (stroke && strict_equals(stroke, "none", false)) context.stroke();
        }
      }
      $$props.path.context(null);
      return () => {
        context?.clearRect(0, 0, plot.width * (devicePixelRatio.current ?? 1), plot.height * (devicePixelRatio.current ?? 1));
      };
    });
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => CanvasLayer_default(node, { [createAttachmentKey()]: render }), "component", GeoCanvas, 113, 0, { componentTag: "CanvasLayer" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  GeoCanvas = hmr(GeoCanvas);
  import.meta.hot.accept((module) => {
    GeoCanvas[HMR].update(module.default);
  });
}
var GeoCanvas_default = GeoCanvas;

// node_modules/svelteplot/dist/marks/Geo.svelte
Geo[FILENAME] = "node_modules/svelteplot/dist/marks/Geo.svelte";
var root_73 = add_locations(from_svg(`<title> </title>`), Geo[FILENAME], [[119, 43]]);
var root_64 = add_locations(from_svg(`<path><!></path>`), Geo[FILENAME], [[109, 28]]);
var root_117 = add_locations(from_svg(`<g aria-label="geo" style="fill:currentColor"><!></g>`), Geo[FILENAME], [[90, 8]]);
function Geo($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Geo);
  const plot = usePlot();
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().geo };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), canvas = tag(user_derived(() => fallback(get($$d).canvas, false)), "canvas"), geoType = tag(user_derived(() => get($$d).geoType), "geoType"), dragRotate = tag(user_derived(() => get($$d).dragRotate), "dragRotate"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "canvas", "geoType", "dragRotate", "class"])), "options");
  const path2 = tag(
    user_derived(() => callWithProps_default(path_default, [plot.scales.projection], {
      ...get(options).r ? {
        pointRadius: (d) => plot.scales.r.fn(resolveChannel("r", d, get(options)))
      } : { pointRadius: 3 }
    })),
    "path"
  );
  const args = tag(
    user_derived(() => sort2(recordize({
      data: get(data),
      ...get(options).r ? { sort: { channel: "-r" } } : {},
      ...get(options)
    }))),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Geo, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_117();
      var node_1 = child(g);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          add_svelte_meta(
            () => GeoCanvas_default(node_2, {
              get data() {
                return scaledData();
              },
              get path() {
                return get(path2);
              },
              get mark() {
                return mark();
              },
              get usedScales() {
                return usedScales();
              }
            }),
            "component",
            Geo,
            95,
            16,
            { componentTag: "GeoCanvas" }
          );
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(
            () => each(node_3, 17, scaledData, index, ($$anchor4, d) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_4 = comment();
                  var node_5 = first_child(fragment_4);
                  add_svelte_meta(
                    () => Anchor_default(node_5, {
                      get options() {
                        return get(options);
                      },
                      get datum() {
                        return get(d).datum;
                      },
                      children: wrap_snippet(Geo, ($$anchor6, $$slotProps) => {
                        const title = tag(user_derived(() => resolveProp(get(args).title, get(d).datum, "")), "title");
                        get(title);
                        const geometry = tag(user_derived(() => resolveProp(get(args).geometry, get(d).datum, get(d).datum)), "geometry");
                        get(geometry);
                        const computed_const = tag(
                          user_derived(() => {
                            const [style, styleClass] = resolveStyles(plot, get(d), get(args), GEOJSON_PREFER_STROKE.has(get(geometry).type) ? "stroke" : "fill", usedScales());
                            return { style, styleClass };
                          }),
                          "[@const]"
                        );
                        get(computed_const);
                        var path_1 = root_64();
                        var node_6 = child(path_1);
                        {
                          var consequent_1 = ($$anchor7) => {
                            var title_1 = root_73();
                            var text2 = child(title_1, true);
                            reset(title_1);
                            template_effect(() => set_text(text2, get(title)));
                            append($$anchor7, title_1);
                          };
                          add_svelte_meta(
                            () => if_block(node_6, ($$render) => {
                              if (get(title)) $$render(consequent_1);
                            }),
                            "if",
                            Geo,
                            119,
                            32
                          );
                        }
                        reset(path_1);
                        attach(path_1, () => addEventHandlers({ plot, options: get(args), datum: get(d)?.datum }));
                        template_effect(
                          ($0, $1) => {
                            set_attribute(path_1, "d", $0);
                            set_style(path_1, get(computed_const).style);
                            set_class(path_1, 0, clsx([get(computed_const).styleClass]));
                            set_attribute(path_1, "filter", $1);
                          },
                          [
                            () => get(path2)(get(geometry)),
                            () => resolveProp(get(args).svgFilter, get(d).datum, void 0)
                          ]
                        );
                        append($$anchor6, path_1);
                      }),
                      $$slots: { default: true }
                    }),
                    "component",
                    Geo,
                    99,
                    24,
                    { componentTag: "Anchor" }
                  );
                  append($$anchor5, fragment_4);
                };
                add_svelte_meta(
                  () => if_block(node_4, ($$render) => {
                    if (get(d).valid) $$render(consequent_2);
                  }),
                  "if",
                  Geo,
                  98,
                  20
                );
              }
              append($$anchor4, fragment_3);
            }),
            "each",
            Geo,
            97,
            16
          );
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (get(canvas)) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Geo,
          94,
          12
        );
      }
      reset(g);
      template_effect(() => set_class(g, 0, clsx([
        "geo",
        get(geoType) && `geo-${get(geoType)}`,
        get(className)
      ])));
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "geo",
          channels: [
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity",
            "r"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Geo,
      85,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Geo = hmr(Geo);
  import.meta.hot.accept((module) => {
    Geo[HMR].update(module.default);
  });
}
var Geo_default = Geo;

// node_modules/svelteplot/dist/marks/Graticule.svelte
Graticule[FILENAME] = "node_modules/svelteplot/dist/marks/Graticule.svelte";
function Graticule($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Graticule);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { step: 10, ...getPlotDefaults().graticule };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["class"])), "options");
  const graticule2 = tag(
    user_derived(() => {
      const graticule3 = graticule();
      graticule3.stepMinor([
        get(options).stepX ?? get(options).step ?? DEFAULTS.step,
        get(options).stepY ?? get(options).step ?? DEFAULTS.step
      ]);
      return graticule3;
    }),
    "graticule"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => [get(graticule2)()]);
    add_svelte_meta(
      () => Geo_default(node, spread_props(
        {
          get data() {
            return get($0);
          }
        },
        () => get(options),
        { geoType: "graticule" }
      )),
      "component",
      Graticule,
      41,
      0,
      { componentTag: "Geo" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Graticule = hmr(Graticule);
  import.meta.hot.accept((module) => {
    Graticule[HMR].update(module.default);
  });
}
var Graticule_default = Graticule;

// node_modules/svelteplot/dist/marks/Image.svelte
Image[FILENAME] = "node_modules/svelteplot/dist/marks/Image.svelte";
var root_39 = add_locations(from_svg(`<title> </title>`), Image[FILENAME], [[73, 28]]);
var root_213 = add_locations(from_svg(`<image><!></image>`), Image[FILENAME], [[64, 12]]);
function Image($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Image);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    width: 20,
    preserveAspectRatio: "xMidYMin slice",
    ...getPlotDefaults().image
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), width = tag(user_derived(() => get($$d).width), "width"), height = tag(user_derived(() => get($$d).height), "height"), src = tag(user_derived(() => get($$d).src), "src"), title = tag(user_derived(() => get($$d).title), "title"), imageClass = tag(user_derived(() => get($$d).imageClass), "imageClass"), preserveAspectRatio = tag(user_derived(() => get($$d).preserveAspectRatio), "preserveAspectRatio"), options = tag(
    user_derived(() => exclude_from_object(get($$d), [
      "data",
      "width",
      "height",
      "src",
      "title",
      "imageClass",
      "preserveAspectRatio"
    ])),
    "options"
  );
  const args = tag(user_derived(() => sort2({ data: get(data), ...get(options) })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const mark = wrap_snippet(Image, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let record = () => $$arg0?.().record;
      record();
      let index3 = () => $$arg0?.().index;
      index3();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      const w = tag(
        user_derived(() => strict_equals(record().r, void 0, false) ? record().r * 2 : resolveProp(get(width), record().datum, 20)),
        "w"
      );
      get(w);
      const h = tag(
        user_derived(() => strict_equals(record().r, void 0, false) ? record().r * 2 : resolveProp(get(height) || get(width), record().datum, 20)),
        "h"
      );
      get(h);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => Anchor_default(node_1, {
          get options() {
            return get(options);
          },
          get datum() {
            return record().datum;
          },
          children: wrap_snippet(Image, ($$anchor3, $$slotProps) => {
            var image = root_213();
            var node_2 = child(image);
            {
              var consequent = ($$anchor4) => {
                var title_1 = root_39();
                var text2 = child(title_1, true);
                reset(title_1);
                template_effect(($0) => set_text(text2, $0), [() => resolveProp(get(title), record().datum, "")]);
                append($$anchor4, title_1);
              };
              add_svelte_meta(
                () => if_block(node_2, ($$render) => {
                  if (get(title)) $$render(consequent);
                }),
                "if",
                Image,
                73,
                17
              );
            }
            reset(image);
            template_effect(
              ($0, $1) => {
                set_class(image, 0, $0);
                set_attribute(image, "href", $1);
                set_attribute(image, "x", record().x - get(w) * 0.5);
                set_attribute(image, "y", record().y - get(h) * 0.5);
                set_attribute(image, "preserveAspectRatio", get(preserveAspectRatio));
                set_attribute(image, "clip-path", strict_equals(record().r, void 0, false) ? `circle(${record().r}px)` : null);
                set_attribute(image, "width", get(w));
                set_attribute(image, "height", get(h));
              },
              [
                () => clsx(resolveProp(get(imageClass), record().datum, null)),
                () => resolveProp(get(src), record().datum, "")
              ]
            );
            append($$anchor3, image);
          }),
          $$slots: { default: true }
        }),
        "component",
        Image,
        63,
        8,
        { componentTag: "Anchor" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(() => CustomMark_default(node, spread_props({ type: "image" }, () => get(args), { mark, $$slots: { mark: true } })), "component", Image, 58, 0, { componentTag: "CustomMark" });
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Image = hmr(Image);
  import.meta.hot.accept((module) => {
    Image[HMR].update(module.default);
  });
}
var Image_default = Image;

// node_modules/svelteplot/dist/marks/helpers/Marker.svelte
Marker[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/Marker.svelte";
var root_118 = add_locations(from_svg(`<circle></circle>`), Marker[FILENAME], [[90, 8]]);
var root_214 = add_locations(from_svg(`<path></path>`), Marker[FILENAME], [[92, 8]]);
var root10 = add_locations(from_svg(`<marker><!></marker>`), Marker[FILENAME], [[81, 0]]);
function Marker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Marker);
  const tickMarker = (orient) => ({
    viewBox: "-3 -3 6 6",
    path: "M0,-3v6",
    width: 6,
    height: 6,
    orient,
    color: "stroke"
  });
  const MARKERS = {
    circle: {
      width: 6.67,
      height: 6.67,
      orient: 0,
      color: "fill",
      bg: "stroke"
    },
    dot: { width: 6.67, height: 6.67, orient: 0, color: "fill" },
    "circle-stroke": {
      width: 6.67,
      height: 6.67,
      orient: 0,
      color: "stroke",
      bg: "fill"
    },
    tick: tickMarker("auto"),
    "tick-x": tickMarker(90),
    "tick-y": tickMarker(0),
    arrow: {
      path: "M-1.5,-3l3,3l-3,3",
      width: 6.67,
      height: 6.67,
      orient: "auto",
      color: "stroke"
    },
    "arrow-reverse": {
      path: "M1.5,-3l-3,3l3,3",
      width: 6.67,
      height: 6.67,
      orient: "auto",
      color: "stroke"
    }
  };
  const defaultDotRadius = getPlotDefaults().markerDotRadius;
  const markerColors = tag(
    user_derived(() => ({
      fill: "none",
      [MARKERS[$$props.shape].color]: $$props.color,
      ...MARKERS[$$props.shape].bg ? { [MARKERS[$$props.shape].bg]: "var(--svp-bg)" } : {}
    })),
    "markerColors"
  );
  var $$exports = { ...legacy_api() };
  var marker = root10();
  attribute_effect(marker, () => ({
    id: $$props.id,
    viewBox: MARKERS[$$props.shape].viewBox || "-5 -5 10 10",
    markerWidth: MARKERS[$$props.shape].width,
    orient: MARKERS[$$props.shape].orient,
    markerHeight: MARKERS[$$props.shape].height,
    "stroke-width": "1.5",
    ...get(markerColors)
  }));
  var node = child(marker);
  {
    var consequent = ($$anchor2) => {
      var circle = root_118();
      template_effect(() => set_attribute(circle, "r", defaultDotRadius));
      append($$anchor2, circle);
    };
    var alternate = ($$anchor2) => {
      var path2 = root_214();
      template_effect(() => set_attribute(path2, "d", MARKERS[$$props.shape].path));
      append($$anchor2, path2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals($$props.shape, "dot") || strict_equals($$props.shape, "circle") || strict_equals($$props.shape, "circle-stroke")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Marker,
      89,
      4
    );
  }
  reset(marker);
  append($$anchor, marker);
  return pop($$exports);
}
if (import.meta.hot) {
  Marker = hmr(Marker);
  import.meta.hot.accept((module) => {
    Marker[HMR].update(module.default);
  });
}
var Marker_default = Marker;

// node_modules/svelteplot/dist/marks/helpers/MarkerPath.svelte
MarkerPath[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/MarkerPath.svelte";
var root_54 = add_locations(from_svg(`<path></path>`), MarkerPath[FILENAME], [[115, 8]]);
var root_65 = add_locations(from_svg(`<path stroke="none" fill="none"></path><text dy="-3"><textPath> </textPath></text>`, 1), MarkerPath[FILENAME], [[136, 8], [137, 8, [[138, 12]]]]);
var root11 = add_locations(from_svg(`<g><!><!><path></path><!></g>`), MarkerPath[FILENAME], [[93, 0, [[120, 4]]]]);
var $$css14 = {
  hash: "s-ekt9GSKJ2m4G",
  code: "\n    text.s-ekt9GSKJ2m4G {\n        font-size: 12px;\n        paint-order: stroke fill;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFya2VyUGF0aC5zdmVsdGUiLCJzb3VyY2VzIjpbIk1hcmtlclBhdGguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS1cbiAgICBAY29tcG9uZW50XG4gICAgSGVscGVyIGNvbXBvbmVudCBmb3IgcGF0aHMgd2l0aCBtYXJrZXJzIGFuZCBvcHRpb25hbCB0ZXh0IGFsb25nIHRoZSBwYXRoLlxuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiIGdlbmVyaWNzPVwiRGF0dW0gZXh0ZW5kcyBEYXRhUmVjb3JkXCI+XG4gICAgaW1wb3J0IE1hcmtlciwgeyB0eXBlIE1hcmtlclNoYXBlIH0gZnJvbSAnLi9NYXJrZXIuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBpc1NuaXBwZXQsIHJhbmRvbUlkIH0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgcmVzb2x2ZVByb3AgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Jlc29sdmUuanMnO1xuICAgIGltcG9ydCB0eXBlIHtcbiAgICAgICAgQmFzZU1hcmtQcm9wcyxcbiAgICAgICAgQ29uc3RhbnRBY2Nlc3NvcixcbiAgICAgICAgRGF0YVJlY29yZCxcbiAgICAgICAgTWFyayxcbiAgICAgICAgUGxvdFNjYWxlc1xuICAgIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IGFkZEV2ZW50SGFuZGxlcnMgfSBmcm9tICcuL2V2ZW50cy5qcyc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uLy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIHR5cGUgTWFya2VyUGF0aFByb3BzID0gQmFzZU1hcmtQcm9wczxEYXR1bT4gJiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgZGF0dW0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcGF0aCwgdXN1YWxseSB0aGUgZmlyc3RcbiAgICAgICAgICogZWxlbWVudCBvZiB0aGUgZGF0YSBhcnJheSBncm91cFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0dW06IERhdHVtO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIG1hcmtlciBzaGFwZSB0byB1c2UgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXRoLCBkZWZhdWx0cyB0b1xuICAgICAgICAgKiBjaXJjbGVcbiAgICAgICAgICovXG4gICAgICAgIG1hcmtlclN0YXJ0PzogYm9vbGVhbiB8IE1hcmtlclNoYXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIG1hcmtlciBzaGFwZSB0byB1c2UgYXQgdGhlIG1pZGRsZSBvZiB0aGUgcGF0aCwgZGVmYXVsdHMgdG8gY2lyY2xlXG4gICAgICAgICAqL1xuICAgICAgICBtYXJrZXJNaWQ/OiBib29sZWFuIHwgTWFya2VyU2hhcGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgbWFya2VyIHNoYXBlIHRvIHVzZSBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoLCBkZWZhdWx0cyB0byBjaXJjbGVcbiAgICAgICAgICovXG4gICAgICAgIG1hcmtlckVuZD86IGJvb2xlYW4gfCBNYXJrZXJTaGFwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNob3J0aGFuZCBmb3Igc2V0dGluZyBhbGwgbWFya2Vyc1xuICAgICAgICAgKi9cbiAgICAgICAgbWFya2VyPzogYm9vbGVhbiB8IE1hcmtlclNoYXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogcGF0aCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGQ6IHN0cmluZztcbiAgICAgICAgc3R5bGU6IHN0cmluZztcbiAgICAgICAgc3RhcnRPZmZzZXQ6IHN0cmluZztcbiAgICAgICAgdGV4dFN0eWxlOiBzdHJpbmc7XG4gICAgICAgIHRleHRTdHlsZUNsYXNzPzogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgdGV4dDogc3RyaW5nO1xuICAgICAgICB0cmFuc2Zvcm06IHN0cmluZztcbiAgICAgICAgY29sb3I6IHN0cmluZztcbiAgICAgICAgc3Ryb2tlV2lkdGg6IENvbnN0YW50QWNjZXNzb3I8bnVtYmVyPjtcbiAgICAgICAgbWFyazogTWFyazxCYXNlTWFya1Byb3BzPERhdHVtPj47XG4gICAgICAgIHNjYWxlczogUGxvdFNjYWxlcztcbiAgICB9O1xuXG4gICAgbGV0IHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIG1hcmtlclN0YXJ0LFxuICAgICAgICBtYXJrZXJNaWQsXG4gICAgICAgIG1hcmtlckVuZCxcbiAgICAgICAgbWFya2VyLFxuICAgICAgICBkLFxuICAgICAgICBkSW52LFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzTmFtZSA9IG51bGwsXG4gICAgICAgIHRleHRTdHlsZUNsYXNzID0gbnVsbCxcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIHRleHRTdHlsZSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIG1hcmtcbiAgICB9OiBNYXJrZXJQYXRoUHJvcHMgPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGlkID0gcmFuZG9tSWQoKTtcblxuICAgIGNvbnN0IHBsb3QgPSB1c2VQbG90KCk7XG5cbiAgICBjb25zdCBwb2ludHMgPSAkZGVyaXZlZCh0ZXh0ICYmIGQgIT0gbnVsbCA/IGQuc3BsaXQoL1tMTUNdLykuc2xpY2UoMSkgOiBbXSk7XG4gICAgY29uc3QgaGFzUGF0aCA9ICRkZXJpdmVkKHBvaW50cy5sZW5ndGggPiAwKTtcbiAgICBjb25zdCBmaXJzdFB0ID0gJGRlcml2ZWQodGV4dCAmJiBoYXNQYXRoID8gcG9pbnRzLmF0KDApLnNwbGl0KCcsJykubWFwKE51bWJlcikgOiBbXSk7XG4gICAgY29uc3QgbGFzdFB0ID0gJGRlcml2ZWQodGV4dCAmJiBoYXNQYXRoID8gcG9pbnRzLmF0KC0xKS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpIDogW10pO1xuICAgIGNvbnN0IGxlZnRUb1JpZ2h0ID0gJGRlcml2ZWQodGV4dCAmJiBoYXNQYXRoID8gZmlyc3RQdFswXSA8IGxhc3RQdC5hdCgtMikgOiB0cnVlKTtcblxuICAgIC8vIHVzZSByZXZlcnNlZCBwYXRoIGlmIHRoZSBwYXRoIGlzIG5vdCBsZWZ0IHRvIHJpZ2h0XG4gICAgY29uc3QgdGV4dFBhdGggPSAkZGVyaXZlZCghdGV4dCB8fCBsZWZ0VG9SaWdodCA/IGQgOiBkSW52KTtcbiAgICBjb25zdCBzdHJva2VXaWR0aF8gPSAkZGVyaXZlZChyZXNvbHZlUHJvcChzdHJva2VXaWR0aCwgZGF0dW0sIDEuNCkpO1xuPC9zY3JpcHQ+XG5cbjxnXG4gICAge3RyYW5zZm9ybX1cbiAgICBjbGFzcz17Y2xhc3NOYW1lfVxuICAgIHN0cm9rZS13aWR0aD17c3Ryb2tlV2lkdGhffVxuICAgIHtAYXR0YWNoIGFkZEV2ZW50SGFuZGxlcnMoe1xuICAgICAgICBwbG90LFxuICAgICAgICBvcHRpb25zOiBtYXJrLm9wdGlvbnMsXG4gICAgICAgIGRhdHVtOiBkYXR1bVxuICAgIH0pfT5cbiAgICB7I2VhY2ggT2JqZWN0LmVudHJpZXMoIHsgc3RhcnQ6IG1hcmtlclN0YXJ0LCBtaWQ6IG1hcmtlck1pZCwgZW5kOiBtYXJrZXJFbmQsIGFsbDogbWFya2VyIH0gKSBhcyBba2V5LCBtYXJrZXJdIChrZXkpfVxuICAgICAgICB7QGNvbnN0IG1hcmtlcklkID0gYG1hcmtlci0ke2tleSA9PT0gJ2FsbCcgPyAnJyA6IGAke2tleX0tYH0ke2lkfWB9XG4gICAgICAgIHsjaWYgaXNTbmlwcGV0KG1hcmtlcil9XG4gICAgICAgICAgICB7QHJlbmRlciBtYXJrZXIobWFya2VySWQsIGNvbG9yKX1cbiAgICAgICAgezplbHNlIGlmIG1hcmtlcn1cbiAgICAgICAgICAgIDxNYXJrZXJcbiAgICAgICAgICAgICAgICBpZD17bWFya2VySWR9XG4gICAgICAgICAgICAgICAgc2hhcGU9e21hcmtlciA9PT0gdHJ1ZSA/ICdjaXJjbGUnIDogcmVzb2x2ZVByb3AobWFya2VyLCBkYXR1bSl9XG4gICAgICAgICAgICAgICAge2NvbG9yfSAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbiAgICB7I2lmIG1hcmsub3B0aW9ucy5vbm1vdXNlZW50ZXIgfHwgbWFyay5vcHRpb25zLm9uY2xpY2t9XG4gICAgICAgIDwhLS0gYWRkIGludmlzaWJsZSBwYXRoIGluIGJnIGZvciBlYXNpZXIgbW91c2UgYWNjZXNzIC0tPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgICAge2R9XG4gICAgICAgICAgICBzdHlsZT1cImZpbGw6bm9uZTtzdHJva2Utd2lkdGg6IHsoc3Ryb2tlV2lkdGggfHwgMSkgK1xuICAgICAgICAgICAgICAgIDEwfTsgc3Ryb2tlOiB0cmFuc3BhcmVudDsgc3Ryb2tlLW9wYWNpdHk6MFwiIC8+XG4gICAgey9pZn1cbiAgICA8cGF0aFxuICAgICAgICBtYXJrZXItc3RhcnQ9e21hcmtlclN0YXJ0IHx8IG1hcmtlclxuICAgICAgICAgICAgPyBgdXJsKCNtYXJrZXItJHttYXJrZXJTdGFydCA/ICdzdGFydC0nIDogJyd9JHtpZH0pYFxuICAgICAgICAgICAgOiBudWxsfVxuICAgICAgICBtYXJrZXItbWlkPXttYXJrZXJNaWQgfHwgbWFya2VyID8gYHVybCgjbWFya2VyLSR7bWFya2VyTWlkID8gJ21pZC0nIDogJyd9JHtpZH0pYCA6IG51bGx9XG4gICAgICAgIG1hcmtlci1lbmQ9e21hcmtlckVuZCB8fCBtYXJrZXIgPyBgdXJsKCNtYXJrZXItJHttYXJrZXJFbmQgPyAnZW5kLScgOiAnJ30ke2lkfSlgIDogbnVsbH1cbiAgICAgICAge2R9XG4gICAgICAgIHtzdHlsZX1cbiAgICAgICAge0BhdHRhY2ggYWRkRXZlbnRIYW5kbGVycyh7XG4gICAgICAgICAgICBwbG90LFxuICAgICAgICAgICAgb3B0aW9uczogbWFyay5vcHRpb25zLFxuICAgICAgICAgICAgZGF0dW06IGRhdHVtXG4gICAgICAgIH0pfSAvPlxuICAgIHsjaWYgdGV4dH1cbiAgICAgICAgPCEtLSBzaW5jZSB0ZXh0UGF0aC5zaWRlIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLCB3ZSBoYXZlIHRvIHVzZSBhbiBpbnZpc2libGVcbiAgICAgICAgICAgIHBhdGggaW4gb3JkZXIgdG8ga2VlcCB0aGUgdGV4dCBmcm9tIHR1cm5pbmcgdXBzaWRlIGRvd24gLS0+XG4gICAgICAgIDxwYXRoIGQ9e3RleHRQYXRofSB7aWR9IHN0cm9rZT1cIm5vbmVcIiBmaWxsPVwibm9uZVwiIC8+XG4gICAgICAgIDx0ZXh0IGR5PVwiLTNcIiBzdHlsZT17dGV4dFN0eWxlfSBjbGFzcz17dGV4dFN0eWxlQ2xhc3N9PlxuICAgICAgICAgICAgPHRleHRQYXRoIHtzdGFydE9mZnNldH0gaHJlZj1cIiN7aWR9XCI+e3RleHR9PC90ZXh0UGF0aD5cbiAgICAgICAgPC90ZXh0PlxuICAgIHsvaWZ9XG48L2c+XG5cbjxzdHlsZT5cbiAgICB0ZXh0IHtcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgICBwYWludC1vcmRlcjogc3Ryb2tlIGZpbGw7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function MarkerPath($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MarkerPath);
  append_styles($$anchor, $$css14);
  let className = prop($$props, "class", 3, null), textStyleClass = prop($$props, "textStyleClass", 3, null);
  const id = randomId();
  const plot = usePlot();
  const points2 = tag(user_derived(() => $$props.text && equals($$props.d, null, false) ? $$props.d.split(/[LMC]/).slice(1) : []), "points");
  const hasPath = tag(user_derived(() => get(points2).length > 0), "hasPath");
  const firstPt = tag(user_derived(() => $$props.text && get(hasPath) ? get(points2).at(0).split(",").map(Number) : []), "firstPt");
  const lastPt = tag(user_derived(() => $$props.text && get(hasPath) ? get(points2).at(-1).split(",").map(Number) : []), "lastPt");
  const leftToRight = tag(user_derived(() => $$props.text && get(hasPath) ? get(firstPt)[0] < get(lastPt).at(-2) : true), "leftToRight");
  const textPath = tag(user_derived(() => !$$props.text || get(leftToRight) ? $$props.d : $$props.dInv), "textPath");
  const strokeWidth_ = tag(user_derived(() => resolveProp($$props.strokeWidth, $$props.datum, 1.4)), "strokeWidth_");
  var $$exports = { ...legacy_api() };
  var g = root11();
  var node = child(g);
  validate_each_keys(
    () => Object.entries({
      start: $$props.markerStart,
      mid: $$props.markerMid,
      end: $$props.markerEnd,
      all: $$props.marker
    }),
    ([key2, marker]) => key2
  );
  add_svelte_meta(
    () => each(
      node,
      17,
      () => Object.entries({
        start: $$props.markerStart,
        mid: $$props.markerMid,
        end: $$props.markerEnd,
        all: $$props.marker
      }),
      ([key2, marker]) => key2,
      ($$anchor2, $$item, $$index, $$array) => {
        var $$array_1 = user_derived(() => to_array(get($$item), 2));
        let key2 = () => get($$array_1)[0];
        key2();
        let marker = () => get($$array_1)[1];
        marker();
        const markerId = tag(user_derived(() => `marker-${strict_equals(key2(), "all") ? "" : `${key2()}-`}${id}`), "markerId");
        get(markerId);
        var fragment = comment();
        var node_1 = first_child(fragment);
        {
          var consequent = ($$anchor3) => {
            var fragment_1 = comment();
            var node_2 = first_child(fragment_1);
            add_svelte_meta(() => snippet(node_2, marker, () => get(markerId), () => $$props.color), "render", MarkerPath, 105, 12);
            append($$anchor3, fragment_1);
          };
          var alternate = ($$anchor3) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            {
              var consequent_1 = ($$anchor4) => {
                var fragment_3 = comment();
                var node_4 = first_child(fragment_3);
                {
                  let $0 = user_derived(() => strict_equals(marker(), true) ? "circle" : resolveProp(marker(), $$props.datum));
                  add_svelte_meta(
                    () => Marker_default(node_4, {
                      get id() {
                        return get(markerId);
                      },
                      get shape() {
                        return get($0);
                      },
                      get color() {
                        return $$props.color;
                      }
                    }),
                    "component",
                    MarkerPath,
                    107,
                    12,
                    { componentTag: "Marker" }
                  );
                }
                append($$anchor4, fragment_3);
              };
              add_svelte_meta(
                () => if_block(
                  node_3,
                  ($$render) => {
                    if (marker()) $$render(consequent_1);
                  },
                  true
                ),
                "if",
                MarkerPath,
                106,
                8
              );
            }
            append($$anchor3, fragment_2);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if (isSnippet(marker())) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            MarkerPath,
            104,
            8
          );
        }
        append($$anchor2, fragment);
      }
    ),
    "each",
    MarkerPath,
    102,
    4
  );
  var node_5 = sibling(node);
  {
    var consequent_2 = ($$anchor2) => {
      var path2 = root_54();
      template_effect(() => {
        set_attribute(path2, "d", $$props.d);
        set_style(path2, `fill:none;stroke-width: ${($$props.strokeWidth || 1) + 10}; stroke: transparent; stroke-opacity:0`);
      });
      append($$anchor2, path2);
    };
    add_svelte_meta(
      () => if_block(node_5, ($$render) => {
        if ($$props.mark.options.onmouseenter || $$props.mark.options.onclick) $$render(consequent_2);
      }),
      "if",
      MarkerPath,
      113,
      4
    );
  }
  var path_1 = sibling(node_5);
  attach(path_1, () => addEventHandlers({ plot, options: $$props.mark.options, datum: $$props.datum }));
  var node_6 = sibling(path_1);
  {
    var consequent_3 = ($$anchor2) => {
      var fragment_4 = root_65();
      var path_2 = first_child(fragment_4);
      var text_1 = sibling(path_2);
      var textPath_1 = child(text_1);
      var text_2 = child(textPath_1, true);
      reset(textPath_1);
      reset(text_1);
      template_effect(() => {
        set_attribute(path_2, "d", get(textPath));
        set_attribute(path_2, "id", id);
        set_style(text_1, $$props.textStyle);
        set_class(text_1, 0, clsx(textStyleClass()), "s-ekt9GSKJ2m4G");
        set_attribute(textPath_1, "startOffset", $$props.startOffset);
        set_attribute(textPath_1, "href", `#${id ?? ""}`);
        set_text(text_2, $$props.text);
      });
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node_6, ($$render) => {
        if ($$props.text) $$render(consequent_3);
      }),
      "if",
      MarkerPath,
      133,
      4
    );
  }
  reset(g);
  attach(g, () => addEventHandlers({ plot, options: $$props.mark.options, datum: $$props.datum }));
  template_effect(() => {
    set_attribute(g, "transform", $$props.transform);
    set_class(g, 0, clsx(className()));
    set_attribute(g, "stroke-width", get(strokeWidth_));
    set_attribute(path_1, "marker-start", $$props.markerStart || $$props.marker ? `url(#marker-${$$props.markerStart ? "start-" : ""}${id})` : null);
    set_attribute(path_1, "marker-mid", $$props.markerMid || $$props.marker ? `url(#marker-${$$props.markerMid ? "mid-" : ""}${id})` : null);
    set_attribute(path_1, "marker-end", $$props.markerEnd || $$props.marker ? `url(#marker-${$$props.markerEnd ? "end-" : ""}${id})` : null);
    set_attribute(path_1, "d", $$props.d);
    set_style(path_1, $$props.style);
  });
  append($$anchor, g);
  return pop($$exports);
}
if (import.meta.hot) {
  MarkerPath = hmr(MarkerPath);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-ekt9GSKJ2m4G");
    MarkerPath[HMR].update(module.default);
  });
}
var MarkerPath_default = MarkerPath;

// node_modules/svelteplot/dist/marks/helpers/LineCanvas.svelte
LineCanvas[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/LineCanvas.svelte";
function LineCanvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LineCanvas);
  const plot = usePlot();
  function maybeOpacity(value) {
    return equals(value, null) ? 1 : +value;
  }
  const render = (canvas) => {
    const context = canvas.getContext("2d");
    user_effect(() => {
      if (context) {
        $$props.linePath.context(context);
        context.resetTransform();
        context.scale(devicePixelRatio.current ?? 1, devicePixelRatio.current ?? 1);
        context.lineJoin = "round";
        context.lineCap = "round";
        for (const group3 of $$props.groupedLineData) {
          if (group3.length < 2) continue;
          const firstPoint = group3[0];
          if (!firstPoint || !firstPoint.valid) continue;
          let { stroke, ...restStyles } = resolveScaledStyleProps(firstPoint.datum, $$props.mark.options, $$props.usedScales, plot, "stroke");
          const opacity = maybeOpacity(restStyles["opacity"]);
          const strokeOpacity = maybeOpacity(restStyles["stroke-opacity"]);
          const strokeWidth = resolveProp($$props.mark.options.strokeWidth, firstPoint.datum, 1.4);
          if ($$props.mark.options.outlineStroke) {
            const outlineStroke = resolveColor($$props.mark.options.outlineStroke, canvas);
            const outlineStrokeWidth = $$props.mark.options.outlineStrokeWidth ?? strokeWidth + 2;
            const outlineStrokeOpacity = $$props.mark.options.outlineStrokeOpacity ?? 1;
            context.lineWidth = outlineStrokeWidth;
            context.strokeStyle = outlineStroke;
            context.globalAlpha = opacity * outlineStrokeOpacity;
            context.beginPath();
            $$props.linePath(group3);
            context.stroke();
          }
          stroke = resolveColor(stroke, canvas);
          if (stroke && strict_equals(stroke, "none", false)) {
            context.lineWidth = strokeWidth ?? 1.4;
          }
          context.strokeStyle = stroke ? stroke : "currentColor";
          context.globalAlpha = opacity * strokeOpacity;
          context.beginPath();
          $$props.linePath(group3);
          context.stroke();
        }
        $$props.linePath.context(null);
      }
      return () => {
        context?.clearRect(0, 0, plot.width * (devicePixelRatio.current ?? 1), plot.height * (devicePixelRatio.current ?? 1));
      };
    });
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => CanvasLayer_default(node, { [createAttachmentKey()]: render }), "component", LineCanvas, 114, 0, { componentTag: "CanvasLayer" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  LineCanvas = hmr(LineCanvas);
  import.meta.hot.accept((module) => {
    LineCanvas[HMR].update(module.default);
  });
}
var LineCanvas_default = LineCanvas;

// node_modules/svelteplot/dist/marks/Line.svelte
Line[FILENAME] = "node_modules/svelteplot/dist/marks/Line.svelte";
var root_84 = add_locations(from_svg(`<path></path>`), Line[FILENAME], [[172, 36]]);
var root_74 = add_locations(from_svg(`<!><!>`, 1), Line[FILENAME], []);
var root_46 = add_locations(from_svg(`<g></g>`), Line[FILENAME], [[147, 16]]);
function Line($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Line);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    curve: "auto",
    tension: 0,
    canvas: false,
    class: null,
    lineClass: null,
    ...getPlotDefaults().line
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), curve = tag(user_derived(() => get($$d).curve), "curve"), tension = tag(user_derived(() => get($$d).tension), "tension"), text2 = tag(user_derived(() => get($$d).text), "text"), canvas = tag(user_derived(() => get($$d).canvas), "canvas"), className = tag(user_derived(() => get($$d).class), "className"), lineClass = tag(user_derived(() => get($$d).lineClass), "lineClass"), options = tag(
    user_derived(() => exclude_from_object(get($$d), [
      "data",
      "curve",
      "tension",
      "text",
      "canvas",
      "class",
      "lineClass"
    ])),
    "options"
  );
  const args = tag(user_derived(() => sort2(recordizeXY({ data: get(data), ...get(options) }))), "args");
  function groupIndex(data2, groupByKey2) {
    if (!groupByKey2) return [data2];
    let group3 = [];
    const groups2 = [group3];
    let lastGroupValue;
    for (const d of data2) {
      const groupValue = resolveProp(groupByKey2, d.datum);
      if (strict_equals(groupValue, lastGroupValue)) {
        group3.push(d);
      } else {
        group3 = [d];
        groups2.push(group3);
        lastGroupValue = groupValue;
      }
    }
    return groups2;
  }
  const groupByKey = tag(user_derived(() => get(args).z || get(args).stroke), "groupByKey");
  const plot = usePlot();
  const linePath = tag(
    user_derived(() => plot.scales.projection && strict_equals(get(curve), "auto") ? sphereLine(plot.scales.projection) : callWithProps_default(line_default, [], {
      curve: maybeCurve(strict_equals(get(curve), "auto") ? "linear" : get(curve), get(tension)),
      x: (d) => d.x,
      y: (d) => d.y,
      defined: (d) => isValid(d.x) && isValid(d.y)
    })),
    "linePath"
  );
  function sphereLine(projection2) {
    const path2 = path_default(projection2);
    const fn = (lineData) => {
      let line = [];
      const lines = [line];
      for (const { x: x2, y: y2 } of lineData) {
        if (!isValid(x2) || !isValid(y2)) {
          line = [];
          lines.push(line);
        } else {
          line.push([x2, y2]);
        }
      }
      return path2({ type: "MultiLineString", coordinates: lines });
    };
    fn.context = path2.context;
    return fn;
  }
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Line, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent_3 = ($$anchor3) => {
          const groupedLineData = tag(user_derived(() => groupIndex(scaledData(), get(groupByKey))), "groupedLineData");
          get(groupedLineData);
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              add_svelte_meta(
                () => LineCanvas_default(node_3, {
                  get groupedLineData() {
                    return get(groupedLineData);
                  },
                  get mark() {
                    return mark();
                  },
                  get usedScales() {
                    return usedScales();
                  },
                  get linePath() {
                    return get(linePath);
                  },
                  get groupByKey() {
                    return get(groupByKey);
                  }
                }),
                "component",
                Line,
                145,
                16,
                { componentTag: "LineCanvas" }
              );
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var g = root_46();
              add_svelte_meta(
                () => each(g, 21, () => get(groupedLineData), index, ($$anchor5, lineData) => {
                  const pathString = tag(user_derived(() => get(linePath)(get(lineData))), "pathString");
                  get(pathString);
                  var fragment_4 = comment();
                  var node_4 = first_child(fragment_4);
                  {
                    var consequent_2 = ($$anchor6) => {
                      var fragment_5 = comment();
                      var node_5 = first_child(fragment_5);
                      {
                        let $0 = user_derived(() => resolveProp(get(lineClass), get(lineData)[0]));
                        add_svelte_meta(
                          () => GroupMultiple_default(node_5, {
                            get class() {
                              return get($0);
                            },
                            children: wrap_snippet(Line, ($$anchor7, $$slotProps) => {
                              const computed_const = tag(
                                user_derived(() => {
                                  const [style, styleClass] = resolveStyles(
                                    plot,
                                    get(lineData)[0],
                                    {
                                      strokeWidth: 1.4,
                                      strokeLinejoin: "round",
                                      ...get(args),
                                      stroke: get(lineData)[0].stroke
                                    },
                                    "stroke",
                                    usedScales()
                                  );
                                  return { style, styleClass };
                                }),
                                "[@const]"
                              );
                              get(computed_const);
                              const computed_const_1 = tag(
                                user_derived(() => {
                                  const [textStyle, textStyleClass] = resolveStyles(
                                    plot,
                                    get(lineData)[0],
                                    {
                                      textAnchor: "middle",
                                      ...pick(get(args), ["fontSize", "fontWeight", "fontStyle", "textAnchor"]),
                                      strokeWidth: get(args).textStrokeWidth ? get(args).textStrokeWidth : get(args).textStroke ? 2 : 0,
                                      fill: get(args).textFill || get(lineData)[0].stroke,
                                      stroke: get(args).textStroke
                                    },
                                    "fill",
                                    usedScales(),
                                    true
                                  );
                                  return { textStyle, textStyleClass };
                                }),
                                "[@const]"
                              );
                              get(computed_const_1);
                              var fragment_6 = root_74();
                              var node_6 = first_child(fragment_6);
                              {
                                var consequent_1 = ($$anchor8) => {
                                  const computed_const_2 = tag(
                                    user_derived(() => {
                                      const [outlineStyle, outlineStyleClass] = resolveStyles(
                                        plot,
                                        { ...get(lineData)[0], stroke: get(options).outlineStroke },
                                        {
                                          strokeLinejoin: "round",
                                          ...get(args),
                                          stroke: get(options).outlineStroke,
                                          strokeOpacity: get(options).outlineStrokeOpacity ?? 1,
                                          strokeWidth: get(options).outlineStrokeWidth || resolveProp(get(options).strokeWidth, get(lineData)[0].datum, 1.4) + 2
                                        },
                                        "stroke",
                                        usedScales()
                                      );
                                      return { outlineStyle, outlineStyleClass };
                                    }),
                                    "[@const]"
                                  );
                                  get(computed_const_2);
                                  var path_1 = root_84();
                                  template_effect(() => {
                                    set_attribute(path_1, "d", get(pathString));
                                    set_style(path_1, get(computed_const_2).outlineStyle);
                                    set_class(path_1, 0, clsx(["is-outline", get(computed_const_2).outlineStyleClass]));
                                  });
                                  append($$anchor8, path_1);
                                };
                                add_svelte_meta(
                                  () => if_block(node_6, ($$render) => {
                                    if (get(options).outlineStroke) $$render(consequent_1);
                                  }),
                                  "if",
                                  Line,
                                  152,
                                  32
                                );
                              }
                              var node_7 = sibling(node_6);
                              {
                                let $02 = user_derived(() => get(text2) ? get(linePath)(get(lineData).toReversed()) : null);
                                let $1 = user_derived(() => get(lineData)[0].stroke || "currentColor");
                                let $2 = user_derived(() => get(text2) ? resolveProp(get(text2), get(lineData)[0].datum) : null);
                                let $3 = user_derived(() => resolveProp(get(args).textStartOffset, get(lineData)[0].datum, "50%"));
                                add_svelte_meta(
                                  () => MarkerPath_default(node_7, {
                                    get mark() {
                                      return mark();
                                    },
                                    get scales() {
                                      return plot.scales;
                                    },
                                    get markerStart() {
                                      return get(args).markerStart;
                                    },
                                    get markerMid() {
                                      return get(args).markerMid;
                                    },
                                    get markerEnd() {
                                      return get(args).markerEnd;
                                    },
                                    get marker() {
                                      return get(args).marker;
                                    },
                                    get strokeWidth() {
                                      return get(args).strokeWidth;
                                    },
                                    get datum() {
                                      return get(lineData)[0].datum;
                                    },
                                    get d() {
                                      return get(pathString);
                                    },
                                    get dInv() {
                                      return get($02);
                                    },
                                    get color() {
                                      return get($1);
                                    },
                                    get style() {
                                      return get(computed_const).style;
                                    },
                                    get class() {
                                      return get(computed_const).styleClass;
                                    },
                                    get text() {
                                      return get($2);
                                    },
                                    get startOffset() {
                                      return get($3);
                                    },
                                    get textStyle() {
                                      return get(computed_const_1).textStyle;
                                    },
                                    get textStyleClass() {
                                      return get(computed_const_1).textStyleClass;
                                    }
                                  }),
                                  "component",
                                  Line,
                                  212,
                                  32,
                                  { componentTag: "MarkerPath" }
                                );
                              }
                              append($$anchor7, fragment_6);
                            }),
                            $$slots: { default: true }
                          }),
                          "component",
                          Line,
                          151,
                          28,
                          { componentTag: "GroupMultiple" }
                        );
                      }
                      append($$anchor6, fragment_5);
                    };
                    add_svelte_meta(
                      () => if_block(node_4, ($$render) => {
                        if (get(pathString)) $$render(consequent_2);
                      }),
                      "if",
                      Line,
                      150,
                      24
                    );
                  }
                  append($$anchor5, fragment_4);
                }),
                "each",
                Line,
                148,
                20
              );
              reset(g);
              template_effect(() => set_class(g, 0, clsx(["lines", get(className)])));
              append($$anchor4, g);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (get(canvas)) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Line,
              144,
              12
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (scaledData().length > 0) $$render(consequent_3);
          }),
          "if",
          Line,
          142,
          8
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "line",
          channels: ["x", "y", "opacity", "stroke", "strokeOpacity"],
          required: ["x", "y"]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Line,
      136,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Line = hmr(Line);
  import.meta.hot.accept((module) => {
    Line[HMR].update(module.default);
  });
}
var Line_default = Line;

// node_modules/svelteplot/dist/marks/LineX.svelte
LineX[FILENAME] = "node_modules/svelteplot/dist/marks/LineX.svelte";
function LineX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LineX);
  let data = prop($$props, "data", 19, () => [{}]), rest2 = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "rest");
  let args = tag(user_derived(() => recordizeX({ data: data(), ...rest2 })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Line_default(node, spread_props(() => get(args))), "component", LineX, 18, 0, { componentTag: "Line" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  LineX = hmr(LineX);
  import.meta.hot.accept((module) => {
    LineX[HMR].update(module.default);
  });
}
var LineX_default = LineX;

// node_modules/svelteplot/dist/marks/LineY.svelte
LineY[FILENAME] = "node_modules/svelteplot/dist/marks/LineY.svelte";
function LineY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LineY);
  let data = prop($$props, "data", 19, () => [{}]), rest2 = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "rest");
  let args = tag(user_derived(() => recordizeY({ data: data(), ...rest2 })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Line_default(node, spread_props(() => get(args))), "component", LineY, 18, 0, { componentTag: "Line" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  LineY = hmr(LineY);
  import.meta.hot.accept((module) => {
    LineY[HMR].update(module.default);
  });
}
var LineY_default = LineY;

// node_modules/svelteplot/dist/marks/Link.svelte
Link[FILENAME] = "node_modules/svelteplot/dist/marks/Link.svelte";
var root_119 = add_locations(from_svg(`<g></g>`), Link[FILENAME], [[152, 8]]);
function Link($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().link };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), curve = tag(user_derived(() => fallback(get($$d).curve, "auto")), "curve"), tension = tag(user_derived(() => fallback(get($$d).tension, 0)), "tension"), text2 = tag(user_derived(() => get($$d).text), "text"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "curve", "tension", "text", "class"])), "options");
  const plot = usePlot();
  const args = tag(
    user_derived(() => replaceChannels(
      sort2({
        data: indexData(get(data)),
        stroke: "currentColor",
        ...get(options)
      }),
      { y: ["y1", "y2"], x: ["x1", "x2"] }
    )),
    "args"
  );
  const sphericalLine = tag(user_derived(() => plot.scales.projection && strict_equals(get(curve), "auto")), "sphericalLine");
  const linePath = tag(
    user_derived(() => {
      const fn = callWithProps_default(line_default, [], {
        curve: maybeCurve(strict_equals(get(curve), "auto") ? "linear" : get(curve), get(tension)),
        x: (d) => d[0],
        y: (d) => d[1]
      });
      return (d, reversed = false) => fn(reversed ? [[d.x2, d.y2], [d.x1, d.y1]] : [[d.x1, d.y1], [d.x2, d.y2]]);
    }),
    "linePath"
  );
  const sphericalLinePath = tag(
    user_derived(() => {
      const fn = sphereLine(plot.scales.projection);
      return (d, reversed = false) => {
        const x12 = resolveChannel("x1", d.datum, get(args));
        const y12 = resolveChannel("y1", d.datum, get(args));
        const x2 = resolveChannel("x2", d.datum, get(args));
        const y2 = resolveChannel("y2", d.datum, get(args));
        return reversed ? fn(x2, y2, x12, y12) : fn(x12, y12, x2, y2);
      };
    }),
    "sphericalLinePath"
  );
  function sphereLine(projection2) {
    const path2 = path_default(projection2);
    return (x12, y12, x2, y2) => {
      return path2({ type: "LineString", coordinates: [[x12, y12], [x2, y2]] });
    };
  }
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Link, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_119();
      add_svelte_meta(
        () => each(g, 21, scaledData, index, ($$anchor3, d) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              const computed_const = tag(
                user_derived(() => {
                  const [style, styleClass] = resolveStyles(plot, get(d), { strokeWidth: 1.6, ...get(args) }, "stroke", usedScales());
                  return { style, styleClass };
                }),
                "[@const]"
              );
              get(computed_const);
              const computed_const_1 = tag(
                user_derived(() => {
                  const [textStyle, textStyleClass] = resolveStyles(
                    plot,
                    get(d),
                    {
                      textAnchor: "middle",
                      ...pick(get(args), ["fontSize", "fontWeight", "fontStyle", "textAnchor"]),
                      fill: get(args).textFill || get(args).stroke,
                      stroke: get(args).textStroke,
                      strokeWidth: get(args).textStrokeWidth
                    },
                    "fill",
                    usedScales()
                  );
                  return { textStyle, textStyleClass };
                }),
                "[@const]"
              );
              get(computed_const_1);
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              {
                let $0 = user_derived(() => ({ ...mark(), options: get(args) }));
                let $1 = user_derived(() => get(sphericalLine) ? get(sphericalLinePath)(get(d)) : get(linePath)(get(d)));
                let $2 = user_derived(() => get(sphericalLine) ? get(sphericalLinePath)(get(d), true) : get(linePath)(get(d), true));
                let $3 = user_derived(() => get(text2) ? resolveProp(get(text2), get(d).datum) : null);
                let $4 = user_derived(() => resolveProp(get(args).textStartOffset, get(d).datum, "50%"));
                add_svelte_meta(
                  () => MarkerPath_default(node_2, {
                    get mark() {
                      return get($0);
                    },
                    get scales() {
                      return plot.scales;
                    },
                    get markerStart() {
                      return get(args).markerStart;
                    },
                    get markerEnd() {
                      return get(args).markerEnd;
                    },
                    get marker() {
                      return get(args).marker;
                    },
                    get class() {
                      return get(computed_const).styleClass;
                    },
                    get strokeWidth() {
                      return get(args).strokeWidth;
                    },
                    get datum() {
                      return get(d).datum;
                    },
                    get color() {
                      return get(d).stroke;
                    },
                    get d() {
                      return get($1);
                    },
                    get dInv() {
                      return get($2);
                    },
                    get style() {
                      return get(computed_const).style;
                    },
                    get text() {
                      return get($3);
                    },
                    get startOffset() {
                      return get($4);
                    },
                    get textStyle() {
                      return get(computed_const_1).textStyle;
                    },
                    get textStyleClass() {
                      return get(computed_const_1).textStyleClass;
                    }
                  }),
                  "component",
                  Link,
                  176,
                  20,
                  { componentTag: "MarkerPath" }
                );
              }
              append($$anchor4, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (get(d).valid || true) $$render(consequent);
              }),
              "if",
              Link,
              154,
              16
            );
          }
          append($$anchor3, fragment_1);
        }),
        "each",
        Link,
        153,
        12
      );
      reset(g);
      template_effect(() => {
        set_class(g, 0, clsx(["link", get(className)]));
        set_attribute(g, "data-use-x", usedScales().x ? 1 : 0);
      });
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "link",
          required: ["x1", "x2", "y1", "y2"],
          channels: ["x1", "y1", "x2", "y2", "opacity", "stroke", "strokeOpacity"]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Link,
      146,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Link = hmr(Link);
  import.meta.hot.accept((module) => {
    Link[HMR].update(module.default);
  });
}
var Link_default = Link;

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
  return add(this.cover(x2, y2), x2, y2, d);
}
function add(tree, x2, y2, d) {
  if (isNaN(x2) || isNaN(y2)) return tree;
  var parent, node = tree._root, leaf = { data: d }, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x2 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom = y2 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x2 === xp && y2 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x2 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom = y2 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  var d, i, n = data.length, x2, y2, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, d = data[i])) || isNaN(y2 = +this._y.call(null, d))) continue;
    xz[i] = x2;
    yz[i] = y2;
    if (x2 < x06) x06 = x2;
    if (x2 > x12) x12 = x2;
    if (y2 < y06) y06 = y2;
    if (y2 > y12) y12 = y2;
  }
  if (x06 > x12 || y06 > y12) return this;
  this.cover(x06, y06).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2)) return this;
  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x06)) {
    x12 = (x06 = Math.floor(x2)) + 1;
    y12 = (y06 = Math.floor(y2)) + 1;
  } else {
    var z = x12 - x06 || 1, node = this._root, parent, i;
    while (x06 > x2 || x2 >= x12 || y06 > y2 || y2 >= y12) {
      i = (y2 < y06) << 1 | x2 < x06;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x06 + z, y12 = y06 + z;
          break;
        case 1:
          x06 = x12 - z, y12 = y06 + z;
          break;
        case 2:
          x12 = x06 + z, y06 = y12 - z;
          break;
        case 3:
          x06 = x12 - z, y06 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default2(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x06, y06, x12, y12) {
  this.node = node;
  this.x0 = x06;
  this.y0 = y06;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x2, y2, radius) {
  var data, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
  if (node) quads.push(new quad_default(node, x06, y06, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x06 = x2 - radius, y06 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06) continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x12, ym, xm, y22),
        new quad_default(node[1], xm, y12, x22, ym),
        new quad_default(node[0], x12, y12, xm, ym)
      );
      if (i = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x06 = x2 - d, y06 = y2 - d;
        x3 = x2 + d, y3 = y2 + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d))) return this;
  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right, bottom, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x2 >= (xm = (x06 + x12) / 2)) x06 = xm;
    else x12 = xm;
    if (bottom = y2 >= (ym = (y06 + y12) / 2)) y06 = ym;
    else y12 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child2, x06, y06, x12, y12;
  if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child2 = node[3]) quads.push(new quad_default(child2, xm, ym, x12, y12));
      if (child2 = node[2]) quads.push(new quad_default(child2, x06, ym, xm, y12));
      if (child2 = node[1]) quads.push(new quad_default(child2, xm, y06, x12, ym));
      if (child2 = node[0]) quads.push(new quad_default(child2, x06, y06, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child2, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child2 = node[0]) quads.push(new quad_default(child2, x06, y06, xm, ym));
      if (child2 = node[1]) quads.push(new quad_default(child2, xm, y06, x12, ym));
      if (child2 = node[2]) quads.push(new quad_default(child2, x06, ym, xm, y12));
      if (child2 = node[3]) quads.push(new quad_default(child2, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x2, y2) {
  var tree = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x2, y2, x06, y06, x12, y12) {
  this._x = x2;
  this._y = y2;
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy3 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child2;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child2 = node.source[i]) {
        if (child2.length) nodes.push({ source: child2, target: node.target[i] = new Array(4) });
        else node.target[i] = leaf_copy(child2);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default2;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/svelteplot/dist/marks/Pointer.svelte
Pointer[FILENAME] = "node_modules/svelteplot/dist/marks/Pointer.svelte";
var root_120 = add_locations(from_svg(`<g class="pointer"><!></g>`), Pointer[FILENAME], [[149, 4]]);
function Pointer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pointer);
  const plot = usePlot();
  const POINTER_X = /* @__PURE__ */ Symbol("pointerX");
  const POINTER_Y = /* @__PURE__ */ Symbol("pointerY");
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().pointer };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), children = tag(user_derived(() => get($$d).children), "children"), x2 = tag(user_derived(() => get($$d).x), "x"), y2 = tag(user_derived(() => get($$d).y), "y"), z = tag(user_derived(() => get($$d).z), "z"), fx = tag(user_derived(() => get($$d).fx), "fx"), fy = tag(user_derived(() => get($$d).fy), "fy"), maxDistance = tag(user_derived(() => fallback(get($$d).maxDistance, 15)), "maxDistance"), tolerance = tag(user_derived(() => fallback(get($$d).tolerance, () => Number.NEGATIVE_INFINITY, true)), "tolerance"), onupdate = tag(user_derived(() => fallback(get($$d).onupdate, null)), "onupdate");
  let selectedData = tag(state(proxy([])), "selectedData");
  function onPointerMove(evt) {
    let facetEl = evt.target;
    while (facetEl && !facetEl.classList.contains("facet")) {
      facetEl = facetEl.parentElement;
    }
    const facetRect = (facetEl?.firstChild ?? plot.body).getBoundingClientRect();
    const relativeX = evt.clientX - facetRect.left + (plot.options.marginLeft ?? 0);
    const relativeY = evt.clientY - facetRect.top + (plot.options.marginTop ?? 0);
    updateSelection(relativeX, relativeY);
  }
  function onPointerLeave() {
    set(selectedData, [], true);
    if (get(onupdate)) get(onupdate)(get(selectedData));
  }
  function updateSelection(ex, ey) {
    const points2 = get(trees).map((tree) => tree.find(equals(get(x2), null, false) ? ex : 0, equals(get(y2), null, false) ? ey : 0, get(maxDistance)));
    const otherPoints = get(trees).flatMap((tree, i) => {
      return tree.data().filter((d) => strict_equals(d, points2[i], false)).filter((d) => (!isFinite(d[POINTER_X]) || Math.abs(d[POINTER_X] - points2[i]?.[POINTER_X]) < get(tolerance)) && (!isFinite(d[POINTER_Y]) || Math.abs(d[POINTER_Y] - points2[i]?.[POINTER_Y]) < get(tolerance)));
    });
    set(selectedData, [...points2, ...otherPoints].filter((d) => equals(d, null, false)), true);
    if (get(onupdate)) get(onupdate)(get(selectedData));
  }
  user_effect(() => {
    plot.body?.addEventListener("pointermove", onPointerMove);
    plot.body?.addEventListener("pointerleave", onPointerLeave);
    return () => {
      plot.body?.removeEventListener("pointermove", onPointerMove);
      plot.body?.removeEventListener("pointerleave", onPointerLeave);
    };
  });
  const groups2 = tag(
    user_derived(() => {
      const groups3 = [];
      groupFacetsAndZ(
        indexData(get(data)),
        {
          x: get(x2),
          y: get(y2),
          z: get(z),
          fx: get(fx),
          fy: get(fy)
        },
        (d) => groups3.push(d)
      );
      return groups3;
    }),
    "groups"
  );
  const trees = tag(
    user_derived(() => get(groups2).map((items) => quadtree().x(equals(get(x2), null, false) ? (d) => d[POINTER_X] : () => 0).y(equals(get(y2), null, false) ? (d) => d[POINTER_Y] : () => 0).addAll(items?.map((d) => {
      const [px, py] = projectXY(plot.scales, resolveChannel("x", d, { x: get(x2) }), resolveChannel("y", d, { y: get(y2) }), true, true);
      return {
        ...isDataRecord_default(d) ? d : { [RAW_VALUE]: d },
        [POINTER_X]: px,
        [POINTER_Y]: py
      };
    }) ?? []))),
    "trees"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var g = root_120();
      var node_1 = child(g);
      add_svelte_meta(() => snippet(node_1, () => get(children), () => ({ data: get(selectedData) })), "render", Pointer, 150, 8);
      reset(g);
      append($$anchor2, g);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(children)) $$render(consequent);
      }),
      "if",
      Pointer,
      148,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Pointer = hmr(Pointer);
  import.meta.hot.accept((module) => {
    Pointer[HMR].update(module.default);
  });
}
var Pointer_default = Pointer;

// node_modules/svelteplot/dist/marks/RectX.svelte
RectX[FILENAME] = "node_modules/svelteplot/dist/marks/RectX.svelte";
function RectX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RectX);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().rect, ...getPlotDefaults().rectX };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), stack = tag(user_derived(() => get($$d).stack), "stack"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "stack"])), "options");
  const plot = usePlot();
  const args = tag(user_derived(() => stackX(intervalY(recordizeX({ data: get(data), ...get(options) }), { plot }), get(stack))), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Rect_default(node, spread_props(() => get(args))), "component", RectX, 39, 0, { componentTag: "Rect" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RectX = hmr(RectX);
  import.meta.hot.accept((module) => {
    RectX[HMR].update(module.default);
  });
}
var RectX_default = RectX;

// node_modules/svelteplot/dist/marks/RectY.svelte
RectY[FILENAME] = "node_modules/svelteplot/dist/marks/RectY.svelte";
function RectY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RectY);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().rect, ...getPlotDefaults().rectY };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), stack = tag(user_derived(() => get($$d).stack), "stack"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "stack"])), "options");
  const plot = usePlot();
  const args = tag(user_derived(() => stackY(intervalX(recordizeY({ data: get(data), ...get(options) }), { plot }), get(stack))), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Rect_default(node, spread_props(() => get(args))), "component", RectY, 37, 0, { componentTag: "Rect" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RectY = hmr(RectY);
  import.meta.hot.accept((module) => {
    RectY[HMR].update(module.default);
  });
}
var RectY_default = RectY;

// node_modules/svelteplot/dist/regression/utils/points.js
function points(data, x2, y2, sort3) {
  data = data.filter((d2, i) => {
    let u = x2(d2, i), v = y2(d2, i);
    return u != null && isFinite(u) && v != null && isFinite(v);
  });
  if (sort3) {
    data.sort((a2, b) => x2(a2) - x2(b));
  }
  const n = data.length, X3 = new Float64Array(n), Y3 = new Float64Array(n);
  let ux = 0, uy = 0, xv, yv, d;
  for (let i = 0; i < n; ) {
    d = data[i];
    X3[i] = xv = +x2(d, i, data);
    Y3[i] = yv = +y2(d, i, data);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (let i = 0; i < n; ++i) {
    X3[i] -= ux;
    Y3[i] -= uy;
  }
  return [X3, Y3, ux, uy];
}
function visitPoints(data, x2, y2, cb) {
  let iterations2 = 0;
  for (let i = 0; i < data.length; i++) {
    const d = data[i];
    const dx = +x2(d, i, data);
    const dy = +y2(d, i, data);
    if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
      cb(dx, dy, iterations2++);
    }
  }
}

// node_modules/svelteplot/dist/regression/utils/determination.js
function determination(data, x2, y2, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data, x2, y2, (dx, dy) => {
    const sse = dy - predict(dx);
    const sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}

// node_modules/svelteplot/dist/regression/utils/ols.js
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}

// node_modules/svelteplot/dist/regression/linear.js
function linear3() {
  let x2 = (d) => d[0], y2 = (d) => d[1], domain;
  const linearRegression = function(data) {
    let n = 0, X3 = 0, Y3 = 0, XY = 0, X23 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data, x2, y2, (dx, dy) => {
      ++n;
      X3 += (dx - X3) / n;
      Y3 += (dy - Y3) / n;
      XY += (dx * dy - XY) / n;
      X23 += (dx * dx - X23) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    const [intercept, slope] = ols(X3, Y3, XY, X23);
    const fn = (xx) => slope * xx + intercept;
    const out = [
      [xmin, fn(xmin)],
      [xmax, fn(xmax)]
    ];
    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = determination(data, x2, y2, Y3, fn);
    return out;
  };
  linearRegression.domain = function(arr) {
    if (!arguments.length)
      return domain;
    domain = arr;
    return linearRegression;
  };
  linearRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return linearRegression;
  };
  linearRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return linearRegression;
  };
  return linearRegression;
}

// node_modules/svelteplot/dist/regression/utils/geometry.js
function angle(line) {
  return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * (180 / Math.PI);
}
function midpoint(line) {
  return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];
}

// node_modules/svelteplot/dist/regression/utils/interpose.js
function interpose(xmin, xmax, predict) {
  const l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
  const precision = Math.pow(10, -l / 2 - 1);
  const maxIter = 1e4;
  let points2 = [px(xmin), px(xmax)];
  let iter = 0;
  while (find(points2) && iter < maxIter)
    ;
  return points2;
  function px(x2) {
    return [x2, predict(x2)];
  }
  function find(points3) {
    iter++;
    const n = points3.length;
    let found = false;
    for (let i = 0; i < n - 1; i++) {
      const p0 = points3[i];
      const p1 = points3[i + 1];
      const m = midpoint([p0, p1]);
      const mp = px(m[0]);
      const a0 = angle([p0, m]);
      const a1 = angle([p0, mp]);
      const a2 = Math.abs(a0 - a1);
      if (a2 > precision) {
        points3.splice(i + 1, 0, mp);
        found = true;
      }
    }
    return found;
  }
}

// node_modules/svelteplot/dist/regression/quadratic.js
function quadratic() {
  let x2 = (d) => d[0], y2 = (d) => d[1], domain;
  const quadraticRegression = function quadraticRegression2(data) {
    const [xv, yv, ux, uy] = points(data, (dd) => x2(dd), (dd) => y2(dd));
    const n = xv.length;
    let X23 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
    for (i = 0; i < n; ) {
      dx = xv[i];
      dy = yv[i++];
      x22 = dx * dx;
      X23 += (x22 - X23) / i;
      X3 += (x22 * dx - X3) / i;
      X4 += (x22 * x22 - X4) / i;
      XY += (dx * dy - XY) / i;
      X2Y += (x22 * dy - X2Y) / i;
    }
    let Y3 = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data, x2, y2, (dx2, dy2) => {
      n0++;
      Y3 += (dy2 - Y3) / n0;
      if (!domain) {
        if (dx2 < xmin)
          xmin = dx2;
        if (dx2 > xmax)
          xmax = dx2;
      }
    });
    const X2X2 = X4 - X23 * X23;
    const d = X23 * X2X2 - X3 * X3;
    const a2 = (X2Y * X23 - XY * X3) / d;
    const b = (XY * X2X2 - X2Y * X3) / d;
    const c4 = -a2 * X23;
    const fn = (xx) => {
      const shifted = xx - ux;
      return a2 * shifted * shifted + b * shifted + c4 + uy;
    };
    const out = interpose(xmin, xmax, fn);
    out.a = a2;
    out.b = b - 2 * a2 * ux;
    out.c = c4 - b * ux + a2 * ux * ux + uy;
    out.predict = fn;
    out.rSquared = determination(data, x2, y2, Y3, fn);
    return out;
  };
  quadraticRegression.domain = function(arr) {
    if (!arguments.length)
      return domain;
    domain = arr;
    return quadraticRegression;
  };
  quadraticRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return quadraticRegression;
  };
  quadraticRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return quadraticRegression;
  };
  return quadraticRegression;
}

// node_modules/svelteplot/dist/regression/polynomial.js
function polynomial() {
  let x2 = (d) => d[0], y2 = (d) => d[1], order = 3, domain;
  const polynomialRegression = function polynomialRegression2(data) {
    if (order === 1) {
      const o = linear3().x(x2).y(y2).domain(domain)(data);
      const result = [o[0], o[1]];
      result.coefficients = [o.b, o.a];
      result.predict = o.predict;
      result.rSquared = o.rSquared;
      return result;
    }
    if (order === 2) {
      const o = quadratic().x(x2).y(y2).domain(domain)(data);
      const result = [o[0], o[1]];
      result.coefficients = [o.c, o.b, o.a];
      result.predict = o.predict;
      result.rSquared = o.rSquared;
      return result;
    }
    const [xv, yv, ux, uy] = points(data, x2, y2);
    const n = xv.length;
    const k2 = order + 1;
    const lhs = [];
    const rhs = [];
    let Y3 = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data, x2, y2, (dx, dy) => {
      n0++;
      Y3 += (dy - Y3) / n0;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    for (let i = 0; i < k2; i++) {
      let v = 0;
      for (let l = 0; l < n; l++) {
        v += Math.pow(xv[l], i) * yv[l];
      }
      lhs.push(v);
      const c4 = new Float64Array(k2);
      for (let j = 0; j < k2; j++) {
        let v2 = 0;
        for (let l = 0; l < n; l++) {
          v2 += Math.pow(xv[l], i + j);
        }
        c4[j] = v2;
      }
      rhs.push(c4);
    }
    rhs.push(new Float64Array(lhs));
    const coef = gaussianElimination(rhs);
    const fn = (xx) => {
      let shifted = xx - ux;
      let val = uy + coef[0];
      for (let i = 1; i < k2; i++) {
        val += coef[i] * Math.pow(shifted, i);
      }
      return val;
    };
    const out = interpose(xmin, xmax, fn);
    out.coefficients = uncenter(k2, coef, -ux, uy);
    out.predict = fn;
    out.rSquared = determination(data, x2, y2, Y3, fn);
    return out;
  };
  polynomialRegression.domain = function(arr) {
    if (!arguments.length)
      return domain;
    domain = arr;
    return polynomialRegression;
  };
  polynomialRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return polynomialRegression;
  };
  polynomialRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return polynomialRegression;
  };
  polynomialRegression.order = function(n) {
    if (!arguments.length)
      return order;
    order = n;
    return polynomialRegression;
  };
  return polynomialRegression;
}
function uncenter(k2, a2, x2, y2) {
  const z = new Array(k2).fill(0);
  for (let i = k2 - 1; i >= 0; --i) {
    let v = a2[i];
    z[i] += v;
    let c4 = 1;
    for (let j = 1; j <= i; ++j) {
      c4 *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x2, j) * c4;
    }
  }
  z[0] += y2;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1;
  const coef = new Array(n);
  for (let i = 0; i < n; i++) {
    let r = i;
    for (let j = i + 1; j < n; j++) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (let k2 = i; k2 < n + 1; k2++) {
      const t = matrix[k2][i];
      matrix[k2][i] = matrix[k2][r];
      matrix[k2][r] = t;
    }
    for (let j = i + 1; j < n; j++) {
      for (let k2 = n; k2 >= i; k2--) {
        matrix[k2][j] -= matrix[k2][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (let j = n - 1; j >= 0; j--) {
    let t = 0;
    for (let k2 = j + 1; k2 < n; k2++) {
      t += matrix[k2][j] * coef[k2];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}

// node_modules/svelteplot/dist/regression/exponential.js
function exponential2() {
  let y2 = (d) => d[1], x2 = (d) => d[0], domain;
  const exponentialRegression = function(data) {
    let n = 0, Y3 = 0, YL = 0, XY = 0, XYL = 0, X2Y = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data, x2, y2, (dx, dy) => {
      const ly = Math.log(dy), xy = dx * dy;
      ++n;
      Y3 += (dy - Y3) / n;
      XY += (xy - XY) / n;
      X2Y += (dx * xy - X2Y) / n;
      YL += (dy * ly - YL) / n;
      XYL += (xy * ly - XYL) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    let [a2, b] = ols(XY / Y3, YL / Y3, XYL / Y3, X2Y / Y3);
    a2 = Math.exp(a2);
    const fn = (xx) => a2 * Math.exp(b * xx);
    const out = interpose(xmin, xmax, fn);
    out.a = a2;
    out.b = b;
    out.predict = fn;
    out.rSquared = determination(data, x2, y2, Y3, fn);
    return out;
  };
  exponentialRegression.domain = function(arr) {
    if (!arguments.length)
      return domain;
    domain = arr;
    return exponentialRegression;
  };
  exponentialRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return exponentialRegression;
  };
  exponentialRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return exponentialRegression;
  };
  return exponentialRegression;
}

// node_modules/svelteplot/dist/regression/logarithmic.js
function logarithmic() {
  let x2 = (d) => d[0], y2 = (d) => d[1], base = Math.E, domain;
  const logarithmicRegression = function(data) {
    let n = 0, X3 = 0, Y3 = 0, XY = 0, X23 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity, lb = Math.log(base);
    visitPoints(data, x2, y2, (dx, dy) => {
      const lx = Math.log(dx) / lb;
      ++n;
      X3 += (lx - X3) / n;
      Y3 += (dy - Y3) / n;
      XY += (lx * dy - XY) / n;
      X23 += (lx * lx - X23) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    const [intercept, slope] = ols(X3, Y3, XY, X23);
    const fn = (xx) => slope * Math.log(xx) / lb + intercept;
    const out = interpose(xmin, xmax, fn);
    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = determination(data, x2, y2, Y3, fn);
    return out;
  };
  logarithmicRegression.domain = function(arr) {
    if (!arguments.length)
      return domain;
    domain = arr;
    return logarithmicRegression;
  };
  logarithmicRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return logarithmicRegression;
  };
  logarithmicRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return logarithmicRegression;
  };
  logarithmicRegression.base = function(b) {
    if (!arguments.length)
      return base;
    base = b;
    return logarithmicRegression;
  };
  return logarithmicRegression;
}

// node_modules/svelteplot/dist/regression/power.js
function power() {
  let x2 = (d) => d[0], y2 = (d) => d[1], domain;
  const powerRegression = function powerRegression2(data) {
    let n = 0, X3 = 0, Y3 = 0, XY = 0, X23 = 0, YS = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data, x2, y2, (dx, dy) => {
      const lx = Math.log(dx), ly = Math.log(dy);
      ++n;
      X3 += (lx - X3) / n;
      Y3 += (ly - Y3) / n;
      XY += (lx * ly - XY) / n;
      X23 += (lx * lx - X23) / n;
      YS += (dy - YS) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    let [a2, b] = ols(X3, Y3, XY, X23);
    a2 = Math.exp(a2);
    const fn = (xx) => a2 * Math.pow(xx, b);
    const out = interpose(xmin, xmax, fn);
    out.a = a2;
    out.b = b;
    out.predict = fn;
    out.rSquared = determination(data, x2, y2, YS, fn);
    return out;
  };
  powerRegression.domain = function(arr) {
    if (!arguments.length)
      return domain;
    domain = arr;
    return powerRegression;
  };
  powerRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return powerRegression;
  };
  powerRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return powerRegression;
  };
  return powerRegression;
}

// node_modules/svelteplot/dist/regression/utils/median.js
function median3(arr) {
  arr.sort((a2, b) => a2 - b);
  var i = arr.length / 2;
  return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
}

// node_modules/svelteplot/dist/regression/loess.js
var maxiters = 2;
var epsilon5 = 1e-12;
function loess() {
  let x2 = (d) => d[0], y2 = (d) => d[1], bandwidth = 0.3;
  const loessRegression = function loessRegression2(data) {
    const [xv, yv, ux, uy] = points(data, (dd) => x2(dd), (dd) => y2(dd), true);
    const n = xv.length;
    const bw = Math.max(2, ~~(bandwidth * n));
    const yhat = new Float64Array(n);
    const residuals = new Float64Array(n);
    const robustWeights = new Float64Array(n).fill(1);
    for (let iter = -1; ++iter <= maxiters; ) {
      const interval2 = [0, bw - 1];
      for (let i = 0; i < n; ++i) {
        const dx = xv[i];
        const i0 = interval2[0];
        const i1 = interval2[1];
        const edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
        let W = 0, X3 = 0, Y3 = 0, XY = 0, X23 = 0;
        const denom = 1 / Math.abs(xv[edge] - dx || 1);
        for (let k2 = i0; k2 <= i1; ++k2) {
          const xk = xv[k2];
          const yk = yv[k2];
          const w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k2];
          const xkw = xk * w;
          W += w;
          X3 += xkw;
          Y3 += yk * w;
          XY += yk * xkw;
          X23 += xk * xkw;
        }
        const [a2, b] = ols(X3 / W, Y3 / W, XY / W, X23 / W);
        yhat[i] = a2 + b * dx;
        residuals[i] = Math.abs(yv[i] - yhat[i]);
        updateInterval(xv, i + 1, interval2);
      }
      if (iter === maxiters) {
        break;
      }
      const medianResidual = median3(residuals);
      if (Math.abs(medianResidual) < epsilon5)
        break;
      for (let i = 0, arg, w; i < n; ++i) {
        arg = residuals[i] / (6 * medianResidual);
        robustWeights[i] = arg >= 1 ? epsilon5 : (w = 1 - arg * arg) * w;
      }
    }
    return output(xv, yhat, ux, uy);
  };
  loessRegression.bandwidth = function(bw) {
    if (!arguments.length)
      return bandwidth;
    bandwidth = bw;
    return loessRegression;
  };
  loessRegression.x = function(fn) {
    if (!arguments.length)
      return x2;
    x2 = fn;
    return loessRegression;
  };
  loessRegression.y = function(fn) {
    if (!arguments.length)
      return y2;
    y2 = fn;
    return loessRegression;
  };
  return loessRegression;
}
function tricube(x2) {
  return (x2 = 1 - x2 * x2 * x2) * x2 * x2;
}
function updateInterval(xv, i, interval2) {
  let val = xv[i], left = interval2[0], right = interval2[1] + 1;
  if (right >= xv.length)
    return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval2[0] = ++left;
    interval2[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}

// node_modules/svelteplot/dist/helpers/math.js
function normdev(p) {
  if (p < 0 || p > 1)
    return false;
  if (p == 0)
    return -Infinity;
  if (p == 1)
    return Infinity;
  const a0 = 3.3871328727963665, a1 = 133.14166789178438, a2 = 1971.5909503065513, a3 = 13731.69376550946, a4 = 45921.95393154987, a5 = 67265.7709270087, a6 = 33430.57558358813, a7 = 2509.0809287301227, b1 = 42.31333070160091, b2 = 687.1870074920579, b3 = 5394.196021424751, b4 = 21213.794301586597, b5 = 39307.89580009271, b6 = 28729.085735721943, b7 = 5226.495278852854, c0 = 1.4234371107496835, c1 = 4.630337846156546, c22 = 5.769497221460691, c32 = 3.6478483247632045, c4 = 1.2704582524523684, c5 = 0.2417807251774506, c6 = 0.022723844989269184, c7 = 7745450142783414e-19, d1 = 2.053191626637759, d2 = 1.6763848301838038, d3 = 0.6897673349851, d4 = 0.14810397642748008, d5 = 0.015198666563616457, d6 = 5475938084995345e-19, d7 = 10507500716444169e-25, e0 = 6.657904643501103, e1 = 5.463784911164114, e22 = 1.7848265399172913, e3 = 0.29656057182850487, e4 = 0.026532189526576124, e52 = 0.0012426609473880784, e6 = 27115555687434876e-21, e7 = 20103343992922881e-23, f1 = 0.599832206555888, f2 = 0.1369298809227358, f3 = 0.014875361290850615, f4 = 7868691311456133e-19, f5 = 18463183175100548e-21, f6 = 1421511758316446e-22, f7 = 20442631033899397e-31;
  const q = p - 0.5;
  let r, z;
  if (Math.abs(q) <= 0.425) {
    r = 0.180625 - q * q;
    z = q * (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3) * r + a2) * r + a1) * r + a0) / (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3) * r + b2) * r + b1) * r + 1);
    return z;
  }
  if (q > 0)
    r = 1 - p;
  else
    r = p;
  r = Math.sqrt(-Math.log(r));
  if (r <= 5) {
    r += -1.6;
    z = (((((((c7 * r + c6) * r + c5) * r + c4) * r + c32) * r + c22) * r + c1) * r + c0) / (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3) * r + d2) * r + d1) * r + 1);
  } else {
    r += -5;
    z = (((((((e7 * r + e6) * r + e52) * r + e4) * r + e3) * r + e22) * r + e1) * r + e0) / (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3) * r + f2) * r + f1) * r + 1);
  }
  if (q < 0)
    z = -z;
  return z;
}
function inverseT(p, df) {
  const { sin: sin3, cos: cos3, sqrt: sqrt5, pow: pow3, exp: exp2, PI: PI2 } = Math;
  if (df == 1)
    return cos3(p * PI2 / 2) / sin3(p * PI2 / 2);
  if (df == 2)
    return sqrt5(2 / (p * (2 - p)) - 2);
  const a2 = 1 / (df - 0.5);
  const b = 48 / (a2 * a2);
  let c4 = ((20700 * a2 / b - 98) * a2 - 16) * a2 + 96.36;
  const d = ((94.5 / (b + c4) - 3) / b + 1) * sqrt5(a2 * PI2 * 0.5) * df;
  let x2 = d * p;
  let y2 = pow3(x2, 2 / df);
  if (y2 > 0.05 + a2) {
    const _x = normdev(p / 2);
    if (_x === false) {
      throw new Error("normdev returned false for p/2 in inverseT");
    } else {
      x2 = _x;
    }
    y2 = x2 * x2;
    if (df < 5)
      c4 = c4 + 0.3 * (df - 4.5) * (x2 + 0.6);
    c4 = (((0.05 * d * x2 - 5) * x2 - 7) * x2 - 2) * x2 + b + c4;
    y2 = (((((0.4 * y2 + 6.3) * y2 + 36) * y2 + 94.5) / c4 - y2 - 3) / b + 1) * x2;
    y2 = a2 * y2 * y2;
    if (y2 > 2e-3)
      y2 = exp2(y2) - 1;
    else
      y2 = 0.5 * y2 * y2 + y2;
  } else {
    y2 = ((1 / (((df + 6) / (df * y2) - 0.089 * d - 0.822) * (df + 2) * 3) + 0.5 / (df + 4)) * y2 - 1) * (df + 1) / (df + 2) + 1 / y2;
  }
  return sqrt5(df * y2);
}
function confidenceInterval(data, predict, confidenceLevel) {
  const mean3 = sum(data, (d) => d.x) / data.length;
  let a2 = 0, b = 0;
  for (let i = 0; i < data.length; ++i) {
    a2 += Math.pow(data[i].x - mean3, 2);
    b += Math.pow(data[i].y - predict(data[i].x), 2);
  }
  const sy = Math.sqrt(b / (data.length - 2));
  const t = inverseT(+confidenceLevel, data.length - 2);
  return function(x2) {
    const Y3 = predict(x2);
    const se = sy * Math.sqrt(1 / data.length + Math.pow(x2 - mean3, 2) / a2);
    return { x: x2, left: Y3 - t * se, right: Y3 + t * se };
  };
}

// node_modules/svelteplot/dist/marks/helpers/Regression.svelte
Regression[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/Regression.svelte";
var root_121 = add_locations(from_svg(`<g><!><!></g>`), Regression[FILENAME], [[154, 4]]);
function Regression($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Regression);
  const regressions = /* @__PURE__ */ new Map([
    ["linear", linear3],
    ["quad", quadratic],
    ["poly", polynomial],
    ["exp", exponential2],
    ["log", logarithmic],
    ["pow", power],
    ["loess", loess]
  ]);
  function maybeRegression(name) {
    name = `${name}`.toLowerCase();
    if (regressions.has(name)) return regressions.get(name);
    throw new Error("unknown regression " + name);
  }
  const plot = usePlot();
  let type = prop($$props, "type", 3, "linear"), order = prop($$props, "order", 3, 3), base = prop($$props, "base", 3, 2.71828), span = prop($$props, "span", 3, 0.3), confidence = prop($$props, "confidence", 3, 0.99), className = prop($$props, "class", 3, null), options = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "data",
      "dependent",
      "type",
      "order",
      "base",
      "span",
      "confidence",
      "class"
    ],
    "options"
  );
  const { getTestFacet } = getContext("svelteplot/facet");
  let testFacet = tag(user_derived(getTestFacet), "testFacet");
  let filteredData = tag(user_derived(() => $$props.data.filter((d) => get(testFacet)(d, options))), "filteredData");
  let independent = tag(user_derived(() => strict_equals($$props.dependent, "x") ? "y" : "x"), "independent");
  let regressionFn = tag(user_derived(() => maybeRegression(type())), "regressionFn");
  let regression = tag(
    user_derived(() => callWithProps_default(get(regressionFn), [], {
      x: (d) => resolveChannel(get(independent), d, options),
      y: (d) => resolveChannel($$props.dependent, d, options),
      ...strict_equals(type(), "poly") ? { order: order() } : {},
      ...strict_equals(type(), "log") ? { base: base() } : {},
      ...!type().startsWith("loess") ? { domain: plot.scales[get(independent)].domain } : {},
      ...strict_equals(type(), "loess") ? { bandwidth: span() } : {}
    })(get(filteredData))),
    "regression"
  );
  let regrPoints = tag(
    user_derived(() => [
      .../* @__PURE__ */ new Set([
        plot.scales[get(independent)].domain[0],
        ...plot.scales[get(independent)].fn.ticks(40),
        plot.scales[get(independent)].domain[1]
      ])
    ]),
    "regrPoints"
  );
  let regrData = tag(
    user_derived(() => get(regression).predictMany ? get(regression).predictMany(get(regrPoints)).map((__y, i) => ({ __x: get(regrPoints)[i], __y })) : get(regression).predict ? get(regrPoints).map((__x) => {
      const __y = get(regression).predict(__x);
      return { __x, __y };
    }) : get(regression).map(([__x, __y]) => ({
      __x: strict_equals(plot.scales[get(independent)].type, "time") ? new Date(__x) : __x,
      __y
    }))),
    "regrData"
  );
  let stroke = tag(
    user_derived(() => equals($$props.stroke, null, false) ? resolveChannel("stroke", get(filteredData)[0], options) : null),
    "stroke"
  );
  let confBandGen = tag(
    user_derived(() => strict_equals(confidence(), false, false) && get(regression).predict ? confidenceInterval(
      $$props.data.map((d) => ({
        x: resolveChannel(get(independent), d, options),
        y: resolveChannel($$props.dependent, d, options)
      })).filter(({ x: x2, y: y2 }) => (Number.isFinite(x2) || isDate(x2)) && Number.isFinite(y2)),
      get(regression).predict,
      1 - confidence()
    ) : null),
    "confBandGen"
  );
  let confBandData = tag(
    user_derived(() => strict_equals(confidence(), false, false) && get(regression).predict ? get(regrPoints).map((x2) => {
      const { x: __x, left, right } = get(confBandGen)(x2);
      return { __x, __y1: left, __y2: right };
    }) : []),
    "confBandData"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var g = root_121();
      var node_1 = child(g);
      {
        let $0 = user_derived(() => ({
          ...options,
          fx: null,
          fy: null,
          stroke: get(stroke),
          x: strict_equals($$props.dependent, "y") ? "__x" : "__y",
          y: strict_equals($$props.dependent, "y") ? "__y" : "__x"
        }));
        add_svelte_meta(
          () => Line_default(node_1, spread_props(
            {
              get data() {
                return get(regrData);
              }
            },
            () => get($0)
          )),
          "component",
          Regression,
          155,
          8,
          { componentTag: "Line" }
        );
      }
      var node_2 = sibling(node_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = comment();
          var node_3 = first_child(fragment_1);
          {
            let $0 = user_derived(() => get(stroke) || "currentColor");
            add_svelte_meta(
              () => Area_default(node_3, spread_props(
                {
                  get data() {
                    return get(confBandData);
                  }
                },
                () => strict_equals($$props.dependent, "y") ? { x1: "__x", y1: "__y1", y2: "__y2" } : { y1: "__x", x1: "__y1", x2: "__y2" },
                {
                  get fill() {
                    return get($0);
                  },
                  opacity: 0.15
                }
              )),
              "component",
              Regression,
              166,
              12,
              { componentTag: "Area" }
            );
          }
          append($$anchor3, fragment_1);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (get(confBandData).length) $$render(consequent);
          }),
          "if",
          Regression,
          165,
          8
        );
      }
      reset(g);
      template_effect(() => set_class(g, 0, `regression-${get(independent) ?? ""} ${(className() || "") ?? ""}`));
      append($$anchor2, g);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(filteredData).length) $$render(consequent_1);
      }),
      "if",
      Regression,
      153,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Regression = hmr(Regression);
  import.meta.hot.accept((module) => {
    Regression[HMR].update(module.default);
  });
}
var Regression_default = Regression;

// node_modules/svelteplot/dist/marks/RegressionX.svelte
RegressionX[FILENAME] = "node_modules/svelteplot/dist/marks/RegressionX.svelte";
function RegressionX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RegressionX);
  let data = prop($$props, "data", 19, () => [{}]), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "options");
  let groupBy2 = equals($$props.stroke, null, false) ? "stroke" : equals($$props.z, null, false) ? "z" : null;
  let groups2 = tag(
    user_derived(() => strict_equals(groupBy2, null, false) ? groups(data(), (d) => resolveChannel(groupBy2, d, options)).map((g) => g[1]) : [data()]),
    "groups"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => Mark_default(node, {
      type: "regression",
      children: wrap_snippet(RegressionX, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(
          () => each(node_1, 17, () => get(groups2), index, ($$anchor3, group3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(
              () => Regression_default(node_2, spread_props(
                {
                  get data() {
                    return get(group3);
                  },
                  dependent: "x"
                },
                () => options
              )),
              "component",
              RegressionX,
              32,
              8,
              { componentTag: "Regression" }
            );
            append($$anchor3, fragment_2);
          }),
          "each",
          RegressionX,
          31,
          4
        );
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    RegressionX,
    30,
    0,
    { componentTag: "Mark" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RegressionX = hmr(RegressionX);
  import.meta.hot.accept((module) => {
    RegressionX[HMR].update(module.default);
  });
}
var RegressionX_default = RegressionX;

// node_modules/svelteplot/dist/marks/RegressionY.svelte
RegressionY[FILENAME] = "node_modules/svelteplot/dist/marks/RegressionY.svelte";
function RegressionY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RegressionY);
  let data = prop($$props, "data", 19, () => [{}]), options = rest_props($$props, ["$$slots", "$$events", "$$legacy", "data"], "options");
  let groupBy2 = equals($$props.stroke, null, false) ? "stroke" : equals($$props.z, null, false) ? "z" : null;
  let groups2 = tag(
    user_derived(() => strict_equals(groupBy2, null, false) ? groups(data(), (d) => resolveChannel(groupBy2, d, options)).map((g) => g[1]) : [data()]),
    "groups"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => Mark_default(node, {
      type: "regression",
      children: wrap_snippet(RegressionY, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(
          () => each(node_1, 17, () => get(groups2), index, ($$anchor3, group3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(
              () => Regression_default(node_2, spread_props(
                {
                  get data() {
                    return get(group3);
                  },
                  dependent: "y"
                },
                () => options
              )),
              "component",
              RegressionY,
              31,
              8,
              { componentTag: "Regression" }
            );
            append($$anchor3, fragment_2);
          }),
          "each",
          RegressionY,
          30,
          4
        );
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    RegressionY,
    29,
    0,
    { componentTag: "Mark" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RegressionY = hmr(RegressionY);
  import.meta.hot.accept((module) => {
    RegressionY[HMR].update(module.default);
  });
}
var RegressionY_default = RegressionY;

// node_modules/svelteplot/dist/marks/RuleX.svelte
RuleX[FILENAME] = "node_modules/svelteplot/dist/marks/RuleX.svelte";
var root_310 = add_locations(from_svg(`<line></line>`), RuleX[FILENAME], [[58, 16]]);
function RuleX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RuleX);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().rule, ...getPlotDefaults().ruleX };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  const plot = usePlot();
  const args = tag(user_derived(() => recordizeX({ data: get(data), ...get(options) }, { withIndex: false })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(RuleX, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => get(className) || "");
        let $1 = user_derived(() => get(className) ? 2 : scaledData().length);
        add_svelte_meta(
          () => GroupMultiple_default(node_1, {
            get class() {
              return `rule-x ${get($0) ?? ""}`;
            },
            get length() {
              return get($1);
            },
            children: wrap_snippet(RuleX, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                  const inset = tag(user_derived(() => resolveProp(get(args).inset, get(d).datum, 0)), "inset");
                  get(inset);
                  const insetTop = tag(user_derived(() => resolveProp(get(args).insetTop, get(d).datum, 0)), "insetTop");
                  get(insetTop);
                  const insetBottom = tag(user_derived(() => resolveProp(get(args).insetBottom, get(d).datum, 0)), "insetBottom");
                  get(insetBottom);
                  const computed_const = tag(
                    user_derived(() => {
                      const [style, styleClass] = resolveStyles(plot, get(d), get(args), "stroke", usedScales());
                      return { style, styleClass };
                    }),
                    "[@const]"
                  );
                  get(computed_const);
                  var line = root_310();
                  template_effect(() => {
                    set_attribute(line, "transform", `translate(${get(d).x ?? ""}, 0)`);
                    set_style(line, get(computed_const).style);
                    set_class(line, 0, clsx([get(computed_const).styleClass]));
                    set_attribute(line, "y1", (get(inset) || get(insetTop)) + (equals(get(d).y1, null, false) ? get(d).y1 : plot.options.marginTop + get(d).dy));
                    set_attribute(line, "y2", (equals(get(d).y2, null, false) ? get(d).y2 : plot.facetHeight + plot.options.marginTop + get(d).dy) - (get(inset) || get(insetBottom)));
                  });
                  append($$anchor4, line);
                }),
                "each",
                RuleX,
                53,
                12
              );
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }),
          "component",
          RuleX,
          52,
          8,
          { componentTag: "GroupMultiple" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "ruleX",
          channels: ["x", "y1", "y2", "stroke", "opacity", "strokeOpacity"]
        },
        () => markProps,
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      RuleX,
      46,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RuleX = hmr(RuleX);
  import.meta.hot.accept((module) => {
    RuleX[HMR].update(module.default);
  });
}
var RuleX_default = RuleX;

// node_modules/svelteplot/dist/marks/RuleY.svelte
RuleY[FILENAME] = "node_modules/svelteplot/dist/marks/RuleY.svelte";
var root_311 = add_locations(from_svg(`<line></line>`), RuleY[FILENAME], [[58, 16]]);
function RuleY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, RuleY);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().rule, ...getPlotDefaults().ruleY };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  const plot = usePlot();
  const args = tag(user_derived(() => recordizeY({ data: get(data), ...get(options) }, { withIndex: false })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(RuleY, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => get(className) || "");
        let $1 = user_derived(() => get(className) ? 2 : get(args).data.length);
        add_svelte_meta(
          () => GroupMultiple_default(node_1, {
            get class() {
              return `rule-y ${get($0) ?? ""}`;
            },
            get length() {
              return get($1);
            },
            children: wrap_snippet(RuleY, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                  const inset = tag(user_derived(() => resolveProp(get(args).inset, get(d).datum, 0)), "inset");
                  get(inset);
                  const insetLeft = tag(user_derived(() => resolveProp(get(args).insetLeft, get(d).datum, 0)), "insetLeft");
                  get(insetLeft);
                  const insetRight = tag(user_derived(() => resolveProp(get(args).insetRight, get(d).datum, 0)), "insetRight");
                  get(insetRight);
                  const computed_const = tag(
                    user_derived(() => {
                      const [style, styleClass] = resolveStyles(plot, get(d), get(args), "stroke", usedScales());
                      return { style, styleClass };
                    }),
                    "[@const]"
                  );
                  get(computed_const);
                  var line = root_311();
                  template_effect(() => {
                    set_attribute(line, "transform", `translate(0, ${get(d).y ?? ""})`);
                    set_style(line, get(computed_const).style);
                    set_class(line, 0, clsx([get(computed_const).styleClass]));
                    set_attribute(line, "x1", (get(inset) || get(insetLeft)) + (equals(get(d).x1, null, false) ? get(d).x1 : plot.options.marginLeft + get(d).dx));
                    set_attribute(line, "x2", (equals(get(d).x2, null, false) ? get(d).x2 : plot.facetWidth + plot.options.marginLeft + get(d).dx) - (get(inset) || get(insetRight)));
                  });
                  append($$anchor4, line);
                }),
                "each",
                RuleY,
                53,
                12
              );
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }),
          "component",
          RuleY,
          52,
          8,
          { componentTag: "GroupMultiple" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "ruleY",
          channels: ["y", "x1", "x2", "stroke", "opacity", "strokeOpacity"]
        },
        () => markProps,
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      RuleY,
      46,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RuleY = hmr(RuleY);
  import.meta.hot.accept((module) => {
    RuleY[HMR].update(module.default);
  });
}
var RuleY_default = RuleY;

// node_modules/svelteplot/dist/marks/Sphere.svelte
Sphere[FILENAME] = "node_modules/svelteplot/dist/marks/Sphere.svelte";
function Sphere($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Sphere);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().sphere };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), options = tag(user_derived(() => exclude_from_object(get($$d), [])), "options");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => Geo_default(node, spread_props({ data: [{ type: "Sphere" }] }, () => get(options), { geoType: "sphere" })), "component", Sphere, 24, 0, { componentTag: "Geo" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Sphere = hmr(Sphere);
  import.meta.hot.accept((module) => {
    Sphere[HMR].update(module.default);
  });
}
var Sphere_default = Sphere;

// node_modules/svelteplot/dist/marks/Vector.svelte
Vector[FILENAME] = "node_modules/svelteplot/dist/marks/Vector.svelte";
var root_215 = add_locations(from_svg(`<text x="30" y="30" style="color:red">implement canvas rendering for vector mark</text>`), Vector[FILENAME], [[174, 16]]);
var root_55 = add_locations(from_svg(`<path></path>`), Vector[FILENAME], [[192, 24]]);
var root_123 = add_locations(from_svg(`<g class="vector"><!></g>`), Vector[FILENAME], [[172, 8]]);
var $$css15 = {
  hash: "s-5bY8Tosk7eYR",
  code: "\n    path.s-5bY8Tosk7eYR {\n        stroke-width: 1.5px;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmVjdG9yLnN2ZWx0ZSIsInNvdXJjZXMiOlsiVmVjdG9yLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tXG4gICAgQGNvbXBvbmVudFxuICAgIFRoZSB2ZWN0b3IgbWFyayBsZXRzIHlvdSBwbGFjZSBzaGFwZXMgKGxpa2UgYXJyb3dzKSBvbiB5b3VyIHBsb3QuXG4tLT5cbjxzY3JpcHQgbGFuZz1cInRzXCIgbW9kdWxlPlxuICAgIHR5cGUgRDNQYXRoID0gUmV0dXJuVHlwZTx0eXBlb2YgaW1wb3J0KCdkMy1wYXRoJykucGF0aD47XG4gICAgZXhwb3J0IHR5cGUgU2hhcGVSZW5kZXJlciA9IHtcbiAgICAgICAgZHJhdyhjb250ZXh0OiBEM1BhdGgsIGw6IG51bWJlciwgcjogbnVtYmVyKTogdm9pZDtcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJEYXR1bSBleHRlbmRzIERhdGFSZWNvcmRcIj5cbiAgICBpbnRlcmZhY2UgVmVjdG9yTWFya1Byb3BzIGV4dGVuZHMgQmFzZU1hcmtQcm9wczxEYXR1bT4ge1xuICAgICAgICBkYXRhOiBEYXR1bVtdO1xuICAgICAgICB4OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICB5OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICByPzogbnVtYmVyO1xuICAgICAgICBsZW5ndGg/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICByb3RhdGU/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgd2hlcmUgdGhlIHZlY3RvciBpcyBhbmNob3JlZCBpbiByZWxhdGlvbiB0byB0aGUgeCwgeSBwb3NpdGlvbi5cbiAgICAgICAgICogSWYgc2V0IHRvICdzdGFydCcsIHRoZSBhcnJvdyB3aWxsIHN0YXJ0IGF0IHRoZSB4LCB5IHBvc2l0aW9uLiBJZiBzZXQgdG9cbiAgICAgICAgICogJ21pZGRsZScsIHRoZSBhcnJvdyB3aWxsIGJlIGNlbnRlcmVkIGF0IHRoZSB4LCB5IHBvc2l0aW9uLiBJZiBzZXQgdG9cbiAgICAgICAgICogJ2VuZCcsIHRoZSBhcnJvdyB3aWxsIGVuZCBhdCB0aGUgeCwgeSBwb3NpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGFuY2hvcj86ICdzdGFydCcgfCAnbWlkZGxlJyB8ICdlbmQnO1xuICAgICAgICBzaGFwZT86ICdhcnJvdycgfCAnc3Bpa2UnIHwgJ2Fycm93LWZpbGxlZCcgfCBTaGFwZVJlbmRlcmVyO1xuICAgICAgICBjaGlsZHJlbj86IFNuaXBwZXQ7XG4gICAgICAgIGNhbnZhcz86IGJvb2xlYW47XG4gICAgfVxuICAgIGltcG9ydCB0eXBlIHtcbiAgICAgICAgRGF0YVJlY29yZCxcbiAgICAgICAgQmFzZU1hcmtQcm9wcyxcbiAgICAgICAgQ2hhbm5lbEFjY2Vzc29yLFxuICAgICAgICBGYWNldENvbnRleHRcbiAgICB9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuICAgIGltcG9ydCB7IGdldENvbnRleHQsIHR5cGUgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgcGF0aFJvdW5kIGFzIHBhdGggfSBmcm9tICdkMy1wYXRoJztcblxuICAgIGltcG9ydCB7IHJlc29sdmVDaGFubmVsLCByZXNvbHZlUHJvcCwgcmVzb2x2ZVN0eWxlcyB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZS5qcyc7XG4gICAgaW1wb3J0IHsgc29ydCB9IGZyb20gJy4uL2luZGV4LmpzJztcbiAgICBpbXBvcnQgTWFyayBmcm9tICcuLi9NYXJrLnN2ZWx0ZSc7XG4gICAgLy9pbXBvcnQgRG90Q2FudmFzIGZyb20gJy4vaGVscGVycy9Eb3RDYW52YXMuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBpc1ZhbGlkIH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgYWRkRXZlbnRIYW5kbGVycyB9IGZyb20gJy4vaGVscGVycy9ldmVudHMuanMnO1xuICAgIGltcG9ydCB7IGluZGV4RGF0YSB9IGZyb20gJy4uL3RyYW5zZm9ybXMvcmVjb3JkaXplLmpzJztcbiAgICBpbXBvcnQgeyBnZXRQbG90RGVmYXVsdHMgfSBmcm9tICcuLi9ob29rcy9wbG90RGVmYXVsdHMuanMnO1xuICAgIGltcG9ydCB7IHVzZVBsb3QgfSBmcm9tICcuLi9ob29rcy91c2VQbG90LnN2ZWx0ZS5qcyc7XG5cbiAgICBjb25zdCBkZWZhdWx0UmFkaXVzID0gMy41O1xuXG4gICAgLy8gVGhlIHNpemUgb2YgdGhlIGFycm93aGVhZCBpcyBwcm9wb3J0aW9uYWwgdG8gaXRzIGxlbmd0aCwgYnV0IHdlIHN0aWxsIGFsbG93XG4gICAgLy8gdGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGhlYWQgdG8gYmUgY29udHJvbGxlZCB2aWEgdGhlIG1hcmsncyB3aWR0aCBvcHRpb247XG4gICAgLy8gZG91YmxpbmcgdGhlIGRlZmF1bHQgcmFkaXVzIHdpbGwgcHJvZHVjZSBhbiBhcnJvd2hlYWQgdGhhdCBpcyB0d2ljZSBhcyBiaWcuXG4gICAgLy8gVGhhdCBzYWlkLCB3ZSdsbCBwcm9iYWJseSB3YW50IGEgYXJyb3cgd2l0aCBhIGZpeGVkIGhlYWQgc2l6ZSwgdG9vLlxuICAgIGNvbnN0IHdpbmdSYXRpbyA9IGRlZmF1bHRSYWRpdXMgKiA1O1xuXG4gICAgbGV0IG1hcmtQcm9wczogVmVjdG9yTWFya1Byb3BzID0gJHByb3BzKCk7XG4gICAgY29uc3QgREVGQVVMVFMgPSB7XG4gICAgICAgIC4uLmdldFBsb3REZWZhdWx0cygpLnZlY3RvclxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgICBkYXRhID0gW3t9XSxcbiAgICAgICAgY2FudmFzLFxuICAgICAgICBzaGFwZSA9ICdhcnJvdycsXG4gICAgICAgIGFuY2hvciA9ICdtaWRkbGUnLFxuICAgICAgICByID0gZGVmYXVsdFJhZGl1cyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgIH06IFZlY3Rvck1hcmtQcm9wcyA9ICRkZXJpdmVkKHtcbiAgICAgICAgLi4uREVGQVVMVFMsXG4gICAgICAgIC4uLm1hcmtQcm9wc1xuICAgIH0pO1xuXG4gICAgY29uc3QgcGxvdCA9IHVzZVBsb3QoKTtcblxuICAgIGNvbnN0IHsgZ2V0VGVzdEZhY2V0IH0gPSBnZXRDb250ZXh0PEZhY2V0Q29udGV4dD4oJ3N2ZWx0ZXBsb3QvZmFjZXQnKTtcbiAgICBjb25zdCB0ZXN0RmFjZXQgPSAkZGVyaXZlZChnZXRUZXN0RmFjZXQoKSk7XG5cbiAgICBjb25zdCBzaGFwZUFycm93OiBTaGFwZVJlbmRlcmVyID0ge1xuICAgICAgICBkcmF3KGNvbnRleHQ6IEQzUGF0aCwgbDogbnVtYmVyLCByOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpbmcgPSAobCAqIHIpIC8gd2luZ1JhdGlvO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAtbCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygtd2luZywgd2luZyAtIGwpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgLWwpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2luZywgd2luZyAtIGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNoYXBlU3Bpa2U6IFNoYXBlUmVuZGVyZXIgPSB7XG4gICAgICAgIGRyYXcoY29udGV4dDogRDNQYXRoLCBsOiBudW1iZXIsIHI6IG51bWJlcikge1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oLXIsIDApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgLWwpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ociwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2hhcGVBcnJvd0ZpbGxlZDogU2hhcGVSZW5kZXJlciA9IHtcbiAgICAgICAgZHJhdyhjb250ZXh0OiBEM1BhdGgsIGw6IG51bWJlciwgcjogbnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBjb25zdCB3aW5nID0gKGwgKiByKSAvIHdpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRMZW5ndGggPSBNYXRoLm1heCgzLCBsICogMC4zKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRTcGlrZSA9IGhlYWRMZW5ndGggKiAwLjI7XG4gICAgICAgICAgICBjb25zdCBoZWFkV2lkdGggPSBNYXRoLm1heCgyLCBsICogMC4zKTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWxXaWR0aCA9IE1hdGgubWF4KDIsIGwgKiAwLjMpICogMC4zO1xuXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odGFpbFdpZHRoICogMC41LCAtbCArIGhlYWRMZW5ndGggLSBoZWFkU3Bpa2UpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaGVhZFdpZHRoICogMC41LCAtbCArIGhlYWRMZW5ndGgpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgLWwpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLWhlYWRXaWR0aCAqIDAuNSwgLWwgKyBoZWFkTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC10YWlsV2lkdGggKiAwLjUsIC1sICsgaGVhZExlbmd0aCAtIGhlYWRTcGlrZSk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2hhcGVzID0gbmV3IE1hcChbXG4gICAgICAgIFsnYXJyb3cnLCBzaGFwZUFycm93XSxcbiAgICAgICAgWydhcnJvdy1maWxsZWQnLCBzaGFwZUFycm93RmlsbGVkXSxcbiAgICAgICAgWydzcGlrZScsIHNoYXBlU3Bpa2VdXG4gICAgXSk7XG5cbiAgICBmdW5jdGlvbiBpc1NoYXBlT2JqZWN0KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBTaGFwZVJlbmRlcmVyIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5kcmF3ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heWJlU2hhcGUoc2hhcGU6ICdhcnJvdycgfCAnc3Bpa2UnIHwgJ2Fycm93LWZpbGxlZCcgfCBTaGFwZVJlbmRlcmVyKSB7XG4gICAgICAgIGlmIChpc1NoYXBlT2JqZWN0KHNoYXBlKSkgcmV0dXJuIHNoYXBlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHNoYXBlcy5nZXQoYCR7c2hhcGV9YC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHZhbHVlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzaGFwZTogJHtzaGFwZX1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFwZVBhdGgoXG4gICAgICAgIHNoYXBlOiAnYXJyb3cnIHwgJ3NwaWtlJyB8ICdhcnJvdy1maWxsZWQnIHwgU2hhcGVSZW5kZXJlcixcbiAgICAgICAgbDogbnVtYmVyLFxuICAgICAgICByOiBudW1iZXJcbiAgICApIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHBhdGgoKTtcbiAgICAgICAgbWF5YmVTaGFwZShzaGFwZSkuZHJhdyhjb250ZXh0LCBsLCByKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gJGRlcml2ZWQoXG4gICAgICAgIHNvcnQoe1xuICAgICAgICAgICAgZGF0YTogaW5kZXhEYXRhKGRhdGEpLFxuICAgICAgICAgICAgLy8gc29ydCBieSBkZXNjZW5kaW5nIHJhZGl1cyBieSBkZWZhdWx0XG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pXG4gICAgKTtcbjwvc2NyaXB0PlxuXG48TWFya1xuICAgIHR5cGU9XCJ2ZWN0b3JcIlxuICAgIHJlcXVpcmVkPXtbJ3gnLCAneSddfVxuICAgIGNoYW5uZWxzPXtbXG4gICAgICAgICd4JyxcbiAgICAgICAgJ3knLFxuICAgICAgICAncicsXG4gICAgICAgICdsZW5ndGgnLFxuICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgJ2ZpbGwnLFxuICAgICAgICAnb3BhY2l0eScsXG4gICAgICAgICdzdHJva2UnLFxuICAgICAgICAnZmlsbE9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlT3BhY2l0eSdcbiAgICBdfVxuICAgIHsuLi5hcmdzfT5cbiAgICB7I3NuaXBwZXQgY2hpbGRyZW4oeyBtYXJrLCBzY2FsZWREYXRhLCB1c2VkU2NhbGVzIH0pfVxuICAgICAgICA8ZyBjbGFzcz1cInZlY3RvclwiIGRhdGEtbD17dXNlZFNjYWxlcy5sZW5ndGh9PlxuICAgICAgICAgICAgeyNpZiBjYW52YXN9XG4gICAgICAgICAgICAgICAgPHRleHQgeD1cIjMwXCIgeT1cIjMwXCIgc3R5bGU9XCJjb2xvcjpyZWRcIlxuICAgICAgICAgICAgICAgICAgICA+aW1wbGVtZW50IGNhbnZhcyByZW5kZXJpbmcgZm9yIHZlY3RvciBtYXJrPC90ZXh0PlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHsjZWFjaCBzY2FsZWREYXRhIGFzIGQsIGkgKGkpfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHIgPSByZXNvbHZlQ2hhbm5lbCgncicsIGQuZGF0dW0sIHsgcjogMywgLi4uYXJncyB9KX1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBkLnZhbGlkICYmIGlzVmFsaWQocil9XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFtzdHlsZSwgc3R5bGVDbGFzc10gPSByZXNvbHZlU3R5bGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZSA9PT0gJ2Fycm93LWZpbGxlZCcgPyAnZmlsbCcgOiAnc3Ryb2tlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkU2NhbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPXtzaGFwZVBhdGgoc2hhcGUsIGQubGVuZ3RoLCByKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoe2QueH0sIHtkLnl9KSByb3RhdGUoe3Jlc29sdmVQcm9wKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnJvdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5kYXR1bSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9KSB7YW5jaG9yID09PSAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbmNob3IgPT09ICdlbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgdHJhbnNsYXRlKDAsICR7ZC5sZW5ndGh9KWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGB0cmFuc2xhdGUoMCwgJHtkLmxlbmd0aCAvIDJ9KWB9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3R5bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge0BhdHRhY2ggYWRkRXZlbnRIYW5kbGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtOiBkPy5kYXR1bVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPXtbc3R5bGVDbGFzc119IC8+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9nPlxuICAgIHsvc25pcHBldH1cbjwvTWFyaz5cblxuPHN0eWxlPlxuICAgIHBhdGgge1xuICAgICAgICBzdHJva2Utd2lkdGg6IDEuNXB4O1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function Vector($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Vector);
  append_styles($$anchor, $$css15);
  const defaultRadius = 3.5;
  const wingRatio = defaultRadius * 5;
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().vector };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), canvas = tag(user_derived(() => get($$d).canvas), "canvas"), shape = tag(user_derived(() => fallback(get($$d).shape, "arrow")), "shape"), anchor = tag(user_derived(() => fallback(get($$d).anchor, "middle")), "anchor"), r = tag(user_derived(() => fallback(get($$d).r, defaultRadius)), "r"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "canvas", "shape", "anchor", "r"])), "options");
  const plot = usePlot();
  const { getTestFacet } = getContext("svelteplot/facet");
  const testFacet = tag(user_derived(getTestFacet), "testFacet");
  const shapeArrow = {
    draw(context, l, r2) {
      const wing = l * r2 / wingRatio;
      context.moveTo(0, 0);
      context.lineTo(0, -l);
      context.moveTo(-wing, wing - l);
      context.lineTo(0, -l);
      context.lineTo(wing, wing - l);
    }
  };
  const shapeSpike = {
    draw(context, l, r2) {
      context.moveTo(-r2, 0);
      context.lineTo(0, -l);
      context.lineTo(r2, 0);
    }
  };
  const shapeArrowFilled = {
    draw(context, l, r2) {
      const headLength = Math.max(3, l * 0.3);
      const headSpike = headLength * 0.2;
      const headWidth = Math.max(2, l * 0.3);
      const tailWidth = Math.max(2, l * 0.3) * 0.3;
      context.moveTo(0, 0);
      context.lineTo(tailWidth * 0.5, -l + headLength - headSpike);
      context.lineTo(headWidth * 0.5, -l + headLength);
      context.lineTo(0, -l);
      context.lineTo(-headWidth * 0.5, -l + headLength);
      context.lineTo(-tailWidth * 0.5, -l + headLength - headSpike);
      context.closePath();
    }
  };
  const shapes = /* @__PURE__ */ new Map([
    ["arrow", shapeArrow],
    ["arrow-filled", shapeArrowFilled],
    ["spike", shapeSpike]
  ]);
  function isShapeObject(value) {
    return value && strict_equals(typeof value.draw, "function");
  }
  function maybeShape(shape2) {
    if (isShapeObject(shape2)) return shape2;
    const value = shapes.get(`${shape2}`.toLowerCase());
    if (value) return value;
    throw new Error(`invalid shape: ${shape2}`);
  }
  function shapePath(shape2, l, r2) {
    const context = pathRound();
    maybeShape(shape2).draw(context, l, r2);
    return context.toString();
  }
  const args = tag(
    user_derived(() => sort2({
      data: indexData(get(data)),
      // sort by descending radius by default
      ...get(options)
    })),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Vector, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_123();
      var node_1 = child(g);
      {
        var consequent = ($$anchor3) => {
          var text2 = root_215();
          append($$anchor3, text2);
        };
        var alternate = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          add_svelte_meta(
            () => each(node_2, 17, scaledData, index, ($$anchor4, d, i, $$array) => {
              const r2 = tag(user_derived(() => resolveChannel("r", get(d).datum, { r: 3, ...get(args) })), "r");
              get(r2);
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              {
                var consequent_1 = ($$anchor5) => {
                  const computed_const = tag(
                    user_derived(() => {
                      const [style, styleClass] = resolveStyles(
                        plot,
                        get(d),
                        {
                          strokeWidth: 1.5,
                          strokeLinejoin: "round",
                          strokeLinecap: "round",
                          ...get(args)
                        },
                        strict_equals(get(shape), "arrow-filled") ? "fill" : "stroke",
                        usedScales()
                      );
                      return { style, styleClass };
                    }),
                    "[@const]"
                  );
                  get(computed_const);
                  var path_1 = root_55();
                  attach(path_1, () => addEventHandlers({ plot, options: get(args), datum: get(d)?.datum }));
                  template_effect(
                    ($0, $1) => {
                      set_attribute(path_1, "d", $0);
                      set_attribute(path_1, "transform", `translate(${get(d).x ?? ""}, ${get(d).y ?? ""}) rotate(${$1 ?? ""}) ${strict_equals(get(anchor), "start") ? "" : strict_equals(get(anchor), "end") ? `translate(0, ${get(d).length})` : `translate(0, ${get(d).length / 2})`}`);
                      set_style(path_1, get(computed_const).style);
                      set_class(path_1, 0, clsx([get(computed_const).styleClass]), "s-5bY8Tosk7eYR");
                    },
                    [
                      () => shapePath(get(shape), get(d).length, get(r2)),
                      () => resolveProp(get(args).rotate, get(d).datum, 0)
                    ]
                  );
                  append($$anchor5, path_1);
                };
                add_svelte_meta(
                  () => if_block(node_3, ($$render) => {
                    if (get(d).valid && isValid(get(r2))) $$render(consequent_1);
                  }),
                  "if",
                  Vector,
                  179,
                  20
                );
              }
              append($$anchor4, fragment_2);
            }),
            "each",
            Vector,
            177,
            16
          );
          append($$anchor3, fragment_1);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (get(canvas)) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Vector,
          173,
          12
        );
      }
      reset(g);
      template_effect(() => set_attribute(g, "data-l", usedScales().length));
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "vector",
          required: ["x", "y"],
          channels: [
            "x",
            "y",
            "r",
            "length",
            "symbol",
            "fill",
            "opacity",
            "stroke",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Vector,
      155,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Vector = hmr(Vector);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-5bY8Tosk7eYR");
    Vector[HMR].update(module.default);
  });
}
var Vector_default = Vector;

// node_modules/svelteplot/dist/marks/Spike.svelte
Spike[FILENAME] = "node_modules/svelteplot/dist/marks/Spike.svelte";
function Spike($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Spike);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    fill: "currentColor",
    fillOpacity: 0.3,
    strokeWidth: 1,
    anchor: "start",
    stroke: "currentColor",
    sort: { channel: "-y" },
    shape: "spike",
    ...getPlotDefaults().spike
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data"])), "options");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => Vector_default(node, spread_props(
      {
        get data() {
          return get(data);
        }
      },
      () => get(options)
    )),
    "component",
    Spike,
    41,
    0,
    { componentTag: "Vector" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Spike = hmr(Spike);
  import.meta.hot.accept((module) => {
    Spike[HMR].update(module.default);
  });
}
var Spike_default = Spike;

// node_modules/svelteplot/dist/marks/helpers/MultilineText.svelte
MultilineText[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/MultilineText.svelte";
var root_216 = add_locations(from_svg(`<tspan x="0"> </tspan>`), MultilineText[FILENAME], [[136, 41]]);
var root_312 = add_locations(from_svg(`<title> </title>`), MultilineText[FILENAME], [[141, 31]]);
var root_124 = add_locations(from_svg(`<text><!><!></text>`), MultilineText[FILENAME], [[122, 4]]);
var root_56 = add_locations(from_svg(`<title> </title>`), MultilineText[FILENAME], [[149, 34]]);
var root_47 = add_locations(from_svg(`<text> <!></text>`), MultilineText[FILENAME], [[144, 4]]);
var $$css16 = {
  hash: "s-QWlCaIWF2tgZ",
  code: "\n    text.s-QWlCaIWF2tgZ {\n        paint-order: stroke fill;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTXVsdGlsaW5lVGV4dC5zdmVsdGUiLCJzb3VyY2VzIjpbIk11bHRpbGluZVRleHQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gICAgaW1wb3J0IHsgcmVzb2x2ZVByb3AsIHJlc29sdmVTdHlsZXMgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Jlc29sdmUnO1xuICAgIGltcG9ydCB7IHR5cGUgQ29tcG9uZW50UHJvcHMgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB0eXBlIHsgU2NhbGVkRGF0YVJlY29yZCwgVXNlZFNjYWxlcyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJztcbiAgICBpbXBvcnQgdHlwZSBUZXh0IGZyb20gJy4uL1RleHQuc3ZlbHRlJztcbiAgICBpbXBvcnQgeyBDU1NfVkFSIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbiAgICBpbXBvcnQgeyBtYXliZUZyb21QaXhlbCwgbWF5YmVGcm9tUmVtIH0gZnJvbSAnLi4vLi4vaGVscGVycy9nZXRCYXNlU3R5bGVzJztcbiAgICBpbXBvcnQgeyB1c2VQbG90IH0gZnJvbSAnLi4vLi4vaG9va3MvdXNlUGxvdC5zdmVsdGUuanMnO1xuXG4gICAgY29uc3QgTElORV9BTkNIT1IgPSB7XG4gICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICBtaWRkbGU6ICdjZW50cmFsJyxcbiAgICAgICAgdG9wOiAnaGFuZ2luZydcbiAgICB9IGFzIGNvbnN0O1xuXG4gICAgY29uc3QgcGxvdCA9IHVzZVBsb3QoKTtcblxuICAgIGxldCB7XG4gICAgICAgIHRleHRMaW5lcyxcbiAgICAgICAgZCxcbiAgICAgICAgYXJncyxcbiAgICAgICAgdXNlZFNjYWxlc1xuICAgIH06IHtcbiAgICAgICAgdGV4dExpbmVzOiBzdHJpbmdbXTtcbiAgICAgICAgZDogU2NhbGVkRGF0YVJlY29yZDtcbiAgICAgICAgYXJnczogQ29tcG9uZW50UHJvcHM8dHlwZW9mIFRleHQ+O1xuICAgICAgICB1c2VkU2NhbGVzOiBVc2VkU2NhbGVzO1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IHRpdGxlID0gJGRlcml2ZWQocmVzb2x2ZVByb3AoYXJncy50aXRsZSwgZC5kYXR1bSwgJycpKTtcbiAgICBjb25zdCBmcmFtZUFuY2hvciA9ICRkZXJpdmVkKHJlc29sdmVQcm9wKGFyZ3MuZnJhbWVBbmNob3IsIGQuZGF0dW0pKTtcbiAgICBjb25zdCBpc0xlZnQgPSAkZGVyaXZlZChcbiAgICAgICAgZnJhbWVBbmNob3IgPT09ICdsZWZ0JyB8fCBmcmFtZUFuY2hvciA9PT0gJ3RvcC1sZWZ0JyB8fCBmcmFtZUFuY2hvciA9PT0gJ2JvdHRvbS1sZWZ0J1xuICAgICk7XG4gICAgY29uc3QgaXNSaWdodCA9ICRkZXJpdmVkKFxuICAgICAgICBmcmFtZUFuY2hvciA9PT0gJ3JpZ2h0JyB8fCBmcmFtZUFuY2hvciA9PT0gJ3RvcC1yaWdodCcgfHwgZnJhbWVBbmNob3IgPT09ICdib3R0b20tcmlnaHQnXG4gICAgKTtcbiAgICBjb25zdCBpc1RvcCA9ICRkZXJpdmVkKFxuICAgICAgICBmcmFtZUFuY2hvciA9PT0gJ3RvcCcgfHwgZnJhbWVBbmNob3IgPT09ICd0b3AtbGVmdCcgfHwgZnJhbWVBbmNob3IgPT09ICd0b3AtcmlnaHQnXG4gICAgKTtcbiAgICBjb25zdCBpc0JvdHRvbSA9ICRkZXJpdmVkKFxuICAgICAgICBmcmFtZUFuY2hvciA9PT0gJ2JvdHRvbScgfHwgZnJhbWVBbmNob3IgPT09ICdib3R0b20tbGVmdCcgfHwgZnJhbWVBbmNob3IgPT09ICdib3R0b20tcmlnaHQnXG4gICAgKTtcbiAgICBjb25zdCBsaW5lQW5jaG9yID0gJGRlcml2ZWQoXG4gICAgICAgIHJlc29sdmVQcm9wKFxuICAgICAgICAgICAgYXJncy5saW5lQW5jaG9yLFxuICAgICAgICAgICAgZC5kYXR1bSxcbiAgICAgICAgICAgIGFyZ3MueSAhPSBudWxsID8gJ21pZGRsZScgOiBpc1RvcCA/ICd0b3AnIDogaXNCb3R0b20gPyAnYm90dG9tJyA6ICdtaWRkbGUnXG4gICAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHRleHRDbGFzc05hbWUgPSAkZGVyaXZlZChyZXNvbHZlUHJvcChhcmdzLnRleHRDbGFzcywgZC5kYXR1bSwgbnVsbCkpO1xuICAgIGNvbnN0IFt4LCB5XSA9ICRkZXJpdmVkKFxuICAgICAgICBhcmdzLnggIT0gbnVsbCAmJiBhcmdzLnkgIT0gbnVsbFxuICAgICAgICAgICAgPyBbZC54LCBkLnldXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICAgIGFyZ3MueCAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgPyBkLnhcbiAgICAgICAgICAgICAgICAgICAgICA6IChpc0xlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc1JpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0ICsgcGxvdC5mYWNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0ICsgcGxvdC5mYWNldFdpZHRoICogMC41KSArIChkLmR4ID8/IDApLFxuICAgICAgICAgICAgICAgICAgYXJncy55ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICA/IGQueVxuICAgICAgICAgICAgICAgICAgICAgIDogKGlzVG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwbG90Lm9wdGlvbnMubWFyZ2luVG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpc0JvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwbG90Lm9wdGlvbnMubWFyZ2luVG9wICsgcGxvdC5mYWNldEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwbG90Lm9wdGlvbnMubWFyZ2luVG9wICsgcGxvdC5mYWNldEhlaWdodCAqIDAuNSkgKyAoZC5keSA/PyAwKVxuICAgICAgICAgICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IFtzdHlsZSwgc3R5bGVDbGFzc10gPSAkZGVyaXZlZChcbiAgICAgICAgcmVzb2x2ZVN0eWxlcyhcbiAgICAgICAgICAgIHBsb3QsXG4gICAgICAgICAgICB7IC4uLmQsIF9fdHNwYW5JbmRleDogMCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA1MDAsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEuNixcbiAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiBpc0xlZnQgPyAnc3RhcnQnIDogaXNSaWdodCA/ICdlbmQnIDogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgIHVzZWRTY2FsZXNcbiAgICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCBmb250U2l6ZSA9ICRkZXJpdmVkKFxuICAgICAgICB0ZXh0TGluZXMubGVuZ3RoID4gMSA/IChyZXNvbHZlUHJvcChhcmdzLmZvbnRTaXplLCBkLmRhdHVtKSA/PyAxMikgOiAwXG4gICAgKTtcbiAgICBsZXQgdGV4dEVsZW1lbnQ6IFNWR1RleHRFbGVtZW50IHwgbnVsbCA9ICRzdGF0ZShudWxsKTtcblxuICAgIGNvbnN0IHJvb3RGb250U2l6ZSA9ICRkZXJpdmVkKFxuICAgICAgICB0ZXh0RWxlbWVudD8ub3duZXJEb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50ICYmIHRleHRMaW5lcy5sZW5ndGggPiAxXG4gICAgICAgICAgICA/IG1heWJlRnJvbVBpeGVsKGdldENvbXB1dGVkU3R5bGUodGV4dEVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplKVxuICAgICAgICAgICAgOiAxNFxuICAgICk7XG5cbiAgICBjb25zdCBjb21wdXRlZEZvbnRTaXplID0gJGRlcml2ZWQoXG4gICAgICAgIHRleHRFbGVtZW50ICYmIHRleHRMaW5lcy5sZW5ndGggPiAxICYmIENTU19WQVIudGVzdChmb250U2l6ZSlcbiAgICAgICAgICAgID8gbWF5YmVGcm9tUmVtKFxuICAgICAgICAgICAgICAgICAgbWF5YmVGcm9tUGl4ZWwoXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0ZXh0RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYC0tJHtmb250U2l6ZS5tYXRjaChDU1NfVkFSKVsxXX1gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHJvb3RGb250U2l6ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGZvbnRTaXplXG4gICAgKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSAkZGVyaXZlZChcbiAgICAgICAgdGV4dExpbmVzLmxlbmd0aCA+IDEgPyAocmVzb2x2ZVByb3AoYXJncy5saW5lSGVpZ2h0LCBkLmRhdHVtKSA/PyAxLjIpIDogMFxuICAgICk7XG5cbiAgICBjb25zdCByb3RhdGUgPSAkZGVyaXZlZCgrcmVzb2x2ZVByb3AoYXJncy5yb3RhdGUsIGQuZGF0dW0sIDApKTtcbjwvc2NyaXB0PlxuXG57I2lmIHRleHRMaW5lcy5sZW5ndGggPiAxfVxuICAgIDwhLS0gbXVsdGlsaW5lIHRleHQtLT5cbiAgICA8dGV4dFxuICAgICAgICBiaW5kOnRoaXM9e3RleHRFbGVtZW50fVxuICAgICAgICBjbGFzcz17W3RleHRDbGFzc05hbWVdfVxuICAgICAgICBkb21pbmFudC1iYXNlbGluZT17TElORV9BTkNIT1JbbGluZUFuY2hvcl19XG4gICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSh7TWF0aC5yb3VuZCh4KX0se01hdGgucm91bmQoXG4gICAgICAgICAgICB5IC1cbiAgICAgICAgICAgICAgICAobGluZUFuY2hvciA9PT0gJ2JvdHRvbSdcbiAgICAgICAgICAgICAgICAgICAgPyB0ZXh0TGluZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVBbmNob3IgPT09ICdtaWRkbGUnXG4gICAgICAgICAgICAgICAgICAgICAgPyAodGV4dExpbmVzLmxlbmd0aCAtIDEpICogMC41XG4gICAgICAgICAgICAgICAgICAgICAgOiAwKSAqXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkRm9udFNpemUgKlxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0XG4gICAgICAgICl9KSByb3RhdGUoe3JvdGF0ZX0pXCJcbiAgICAgICAgPnsjZWFjaCB0ZXh0TGluZXMgYXMgbGluZSwgbCAobCl9PHRzcGFuXG4gICAgICAgICAgICAgICAgeD1cIjBcIlxuICAgICAgICAgICAgICAgIGR5PXtsID8gY29tcHV0ZWRGb250U2l6ZSAqIGxpbmVIZWlnaHQgOiAwfVxuICAgICAgICAgICAgICAgIGNsYXNzPXtzdHlsZUNsYXNzfVxuICAgICAgICAgICAgICAgIHtzdHlsZX0+e2xpbmV9PC90c3BhblxuICAgICAgICAgICAgPnsvZWFjaH17I2lmIHRpdGxlfTx0aXRsZT57dGl0bGV9PC90aXRsZT57L2lmfTwvdGV4dD5cbns6ZWxzZX1cbiAgICA8IS0tIHNpbmdsZWxpbmUgdGV4dC0tPlxuICAgIDx0ZXh0XG4gICAgICAgIGNsYXNzPXtbdGV4dENsYXNzTmFtZSwgc3R5bGVDbGFzc119XG4gICAgICAgIGRvbWluYW50LWJhc2VsaW5lPXtMSU5FX0FOQ0hPUltsaW5lQW5jaG9yXX1cbiAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHtNYXRoLnJvdW5kKHgpfSx7TWF0aC5yb3VuZCh5KX0pIHJvdGF0ZSh7cm90YXRlfSlcIlxuICAgICAgICB7c3R5bGV9XG4gICAgICAgID57dGV4dExpbmVzWzBdfXsjaWYgdGl0bGV9PHRpdGxlPnt0aXRsZX08L3RpdGxlPnsvaWZ9PC90ZXh0Plxuey9pZn1cblxuPHN0eWxlPlxuICAgIHRleHQge1xuICAgICAgICBwYWludC1vcmRlcjogc3Ryb2tlIGZpbGw7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function MultilineText($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MultilineText);
  append_styles($$anchor, $$css16);
  const LINE_ANCHOR = { bottom: "auto", middle: "central", top: "hanging" };
  const plot = usePlot();
  const title = tag(user_derived(() => resolveProp($$props.args.title, $$props.d.datum, "")), "title");
  const frameAnchor = tag(user_derived(() => resolveProp($$props.args.frameAnchor, $$props.d.datum)), "frameAnchor");
  const isLeft = tag(user_derived(() => strict_equals(get(frameAnchor), "left") || strict_equals(get(frameAnchor), "top-left") || strict_equals(get(frameAnchor), "bottom-left")), "isLeft");
  const isRight = tag(user_derived(() => strict_equals(get(frameAnchor), "right") || strict_equals(get(frameAnchor), "top-right") || strict_equals(get(frameAnchor), "bottom-right")), "isRight");
  const isTop = tag(user_derived(() => strict_equals(get(frameAnchor), "top") || strict_equals(get(frameAnchor), "top-left") || strict_equals(get(frameAnchor), "top-right")), "isTop");
  const isBottom = tag(user_derived(() => strict_equals(get(frameAnchor), "bottom") || strict_equals(get(frameAnchor), "bottom-left") || strict_equals(get(frameAnchor), "bottom-right")), "isBottom");
  const lineAnchor = tag(
    user_derived(() => resolveProp($$props.args.lineAnchor, $$props.d.datum, equals($$props.args.y, null, false) ? "middle" : get(isTop) ? "top" : get(isBottom) ? "bottom" : "middle")),
    "lineAnchor"
  );
  const textClassName = tag(user_derived(() => resolveProp($$props.args.textClass, $$props.d.datum, null)), "textClassName");
  const $$d = user_derived(() => equals($$props.args.x, null, false) && equals($$props.args.y, null, false) ? [$$props.d.x, $$props.d.y] : [
    equals($$props.args.x, null, false) ? $$props.d.x : (get(isLeft) ? plot.options.marginLeft : get(isRight) ? plot.options.marginLeft + plot.facetWidth : plot.options.marginLeft + plot.facetWidth * 0.5) + ($$props.d.dx ?? 0),
    equals($$props.args.y, null, false) ? $$props.d.y : (get(isTop) ? plot.options.marginTop : get(isBottom) ? plot.options.marginTop + plot.facetHeight : plot.options.marginTop + plot.facetHeight * 0.5) + ($$props.d.dy ?? 0)
  ]), $$array = tag(user_derived(() => to_array(get($$d), 2)), "[$derived iterable]"), x2 = tag(user_derived(() => get($$array)[0]), "x"), y2 = tag(user_derived(() => get($$array)[1]), "y");
  const $$d_1 = user_derived(() => resolveStyles(
    plot,
    { ...$$props.d, __tspanIndex: 0 },
    {
      fontSize: 12,
      fontWeight: 500,
      strokeWidth: 1.6,
      textAnchor: get(isLeft) ? "start" : get(isRight) ? "end" : "middle",
      ...$$props.args
    },
    "fill",
    $$props.usedScales
  )), $$array_1 = tag(user_derived(() => to_array(get($$d_1), 2)), "[$derived iterable]"), style = tag(user_derived(() => get($$array_1)[0]), "style"), styleClass = tag(user_derived(() => get($$array_1)[1]), "styleClass");
  const fontSize = tag(
    user_derived(() => $$props.textLines.length > 1 ? resolveProp($$props.args.fontSize, $$props.d.datum) ?? 12 : 0),
    "fontSize"
  );
  let textElement = tag(state(null), "textElement");
  const rootFontSize = tag(
    user_derived(() => get(textElement)?.ownerDocument?.documentElement && $$props.textLines.length > 1 ? maybeFromPixel(getComputedStyle(get(textElement).ownerDocument.documentElement).fontSize) : 14),
    "rootFontSize"
  );
  const computedFontSize = tag(
    user_derived(() => get(textElement) && $$props.textLines.length > 1 && CSS_VAR.test(get(fontSize)) ? maybeFromRem(maybeFromPixel(getComputedStyle(get(textElement)).getPropertyValue(`--${get(fontSize).match(CSS_VAR)[1]}`)), get(rootFontSize)) : get(fontSize)),
    "computedFontSize"
  );
  const lineHeight = tag(
    user_derived(() => $$props.textLines.length > 1 ? resolveProp($$props.args.lineHeight, $$props.d.datum) ?? 1.2 : 0),
    "lineHeight"
  );
  const rotate = tag(user_derived(() => +resolveProp($$props.args.rotate, $$props.d.datum, 0)), "rotate");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var text2 = root_124();
      var node_1 = child(text2);
      add_svelte_meta(
        () => each(node_1, 17, () => $$props.textLines, index, ($$anchor3, line, l) => {
          var tspan = root_216();
          var text_1 = child(tspan, true);
          reset(tspan);
          template_effect(() => {
            set_attribute(tspan, "dy", l ? get(computedFontSize) * get(lineHeight) : 0);
            set_class(tspan, 0, clsx(get(styleClass)));
            set_style(tspan, get(style));
            set_text(text_1, get(line));
          });
          append($$anchor3, tspan);
        }),
        "each",
        MultilineText,
        136,
        9
      );
      var node_2 = sibling(node_1);
      {
        var consequent = ($$anchor3) => {
          var title_1 = root_312();
          var text_2 = child(title_1, true);
          reset(title_1);
          template_effect(() => set_text(text_2, get(title)));
          append($$anchor3, title_1);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (get(title)) $$render(consequent);
          }),
          "if",
          MultilineText,
          141,
          20
        );
      }
      reset(text2);
      bind_this(text2, ($$value) => set(textElement, $$value), () => get(textElement));
      template_effect(
        ($0, $1) => {
          set_class(text2, 0, clsx([get(textClassName)]), "s-QWlCaIWF2tgZ");
          set_attribute(text2, "dominant-baseline", LINE_ANCHOR[get(lineAnchor)]);
          set_attribute(text2, "transform", `translate(${$0 ?? ""},${$1 ?? ""}) rotate(${get(rotate) ?? ""})`);
        },
        [
          () => Math.round(get(x2)),
          () => Math.round(get(y2) - (strict_equals(get(lineAnchor), "bottom") ? $$props.textLines.length - 1 : strict_equals(get(lineAnchor), "middle") ? ($$props.textLines.length - 1) * 0.5 : 0) * get(computedFontSize) * get(lineHeight))
        ]
      );
      append($$anchor2, text2);
    };
    var alternate = ($$anchor2) => {
      var text_3 = root_47();
      var text_4 = child(text_3, true);
      var node_3 = sibling(text_4);
      {
        var consequent_2 = ($$anchor3) => {
          var title_2 = root_56();
          var text_5 = child(title_2, true);
          reset(title_2);
          template_effect(() => set_text(text_5, get(title)));
          append($$anchor3, title_2);
        };
        add_svelte_meta(
          () => if_block(node_3, ($$render) => {
            if (get(title)) $$render(consequent_2);
          }),
          "if",
          MultilineText,
          149,
          23
        );
      }
      reset(text_3);
      template_effect(
        ($0, $1) => {
          set_class(text_3, 0, clsx([get(textClassName), get(styleClass)]), "s-QWlCaIWF2tgZ");
          set_attribute(text_3, "dominant-baseline", LINE_ANCHOR[get(lineAnchor)]);
          set_attribute(text_3, "transform", `translate(${$0 ?? ""},${$1 ?? ""}) rotate(${get(rotate) ?? ""})`);
          set_style(text_3, get(style));
          set_text(text_4, $$props.textLines[0]);
        },
        [() => Math.round(get(x2)), () => Math.round(get(y2))]
      );
      append($$anchor2, text_3);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.textLines.length > 1) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      MultilineText,
      120,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  MultilineText = hmr(MultilineText);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-QWlCaIWF2tgZ");
    MultilineText[HMR].update(module.default);
  });
}
var MultilineText_default = MultilineText;

// node_modules/svelteplot/dist/marks/Text.svelte
Text[FILENAME] = "node_modules/svelteplot/dist/marks/Text.svelte";
function Text($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text);
  const DEFAULTS = {
    fontSize: 12,
    c: 500,
    strokeWidth: 1.6,
    frameAnchor: "middle",
    lineHeight: 1.1,
    rotate: 0,
    ...getPlotDefaults().text
  };
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  const args = tag(user_derived(() => sort2({ data: indexData(get(data)), ...get(options) })), "args");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Text, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => get(className) ? 2 : get(args).data.length);
        add_svelte_meta(
          () => GroupMultiple_default(node_1, {
            get class() {
              return `text ${get(className) ?? ""}`;
            },
            get length() {
              return get($0);
            },
            children: wrap_snippet(Text, ($$anchor3, $$slotProps) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => each(node_2, 17, scaledData, index, ($$anchor4, d) => {
                  var fragment_3 = comment();
                  var node_3 = first_child(fragment_3);
                  {
                    var consequent = ($$anchor5) => {
                      const textLines = tag(user_derived(() => String(resolveProp(get(args).text, get(d).datum, "")).split("\n")), "textLines");
                      get(textLines);
                      var fragment_4 = comment();
                      var node_4 = first_child(fragment_4);
                      add_svelte_meta(
                        () => MultilineText_default(node_4, {
                          get textLines() {
                            return get(textLines);
                          },
                          get d() {
                            return get(d);
                          },
                          get args() {
                            return get(args);
                          },
                          get usedScales() {
                            return usedScales();
                          }
                        }),
                        "component",
                        Text,
                        130,
                        20,
                        { componentTag: "MultilineText" }
                      );
                      append($$anchor5, fragment_4);
                    };
                    add_svelte_meta(
                      () => if_block(node_3, ($$render) => {
                        if (get(d).valid) $$render(consequent);
                      }),
                      "if",
                      Text,
                      127,
                      16
                    );
                  }
                  append($$anchor4, fragment_3);
                }),
                "each",
                Text,
                126,
                12
              );
              append($$anchor3, fragment_2);
            }),
            $$slots: { default: true }
          }),
          "component",
          Text,
          125,
          8,
          { componentTag: "GroupMultiple" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "text",
          channels: [
            "x",
            "y",
            "r",
            "symbol",
            "fill",
            "stroke",
            "opacity",
            "strokeOpacity",
            "fillOpacity"
          ],
          required: []
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Text,
      109,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Text = hmr(Text);
  import.meta.hot.accept((module) => {
    Text[HMR].update(module.default);
  });
}
var Text_default = Text;

// node_modules/svelteplot/dist/marks/TickX.svelte
TickX[FILENAME] = "node_modules/svelteplot/dist/marks/TickX.svelte";
var root_48 = add_locations(from_svg(`<line class="s-UD0hmGwor-Gs"></line>`), TickX[FILENAME], [[93, 24]]);
var root_125 = add_locations(from_svg(`<g class="tick-x s-UD0hmGwor-Gs"></g>`), TickX[FILENAME], [[69, 8]]);
var $$css17 = {
  hash: "s-UD0hmGwor-Gs",
  code: "\n    .tick-x.s-UD0hmGwor-Gs line:where(.s-UD0hmGwor-Gs) {\n        stroke: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGlja1guc3ZlbHRlIiwic291cmNlcyI6WyJUaWNrWC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBcbiAgICBAY29tcG9uZW50IFxuICAgIFRoZSBUaWNrWCBtYXJrIGlzIHVzZWZ1bCBmb3Igc2hvd2luZyBvbmUtZGltZW5zaW9uYWwgZGlzdHJpYnV0aW9ucyBhbG9uZyB0aGUgeCBheGlzLiBUaGUgeSBheGlzIG11c3QgYmUgYSBiYW5kIHNjYWxlLlxuLS0+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCIgZ2VuZXJpY3M9XCJEYXR1bSBleHRlbmRzIERhdGFSb3dcIj5cbiAgICBpbnRlcmZhY2UgVGlja1hNYXJrUHJvcHMgZXh0ZW5kcyBPbWl0PEJhc2VNYXJrUHJvcHM8RGF0dW0+LCAnZmlsbCcgfCAnZmlsbE9wYWNpdHknPiB7XG4gICAgICAgIGRhdGE6IERhdHVtW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbjsgYm91bmQgdG8gdGhlIHggc2NhbGVcbiAgICAgICAgICovXG4gICAgICAgIHg/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIHZlcnRpY2FsIHBvc2l0aW9uOyBib3VuZCB0byB0aGUgeSBzY2FsZSwgd2hpY2ggbXVzdCBiZSBiYW5kLiBJZiB0aGUgeSBjaGFubmVsXG4gICAgICAgICAqIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB0aWNrIHdpbGwgc3BhbiB0aGUgZnVsbCB2ZXJ0aWNhbCBleHRlbnQgb2YgdGhlIGZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgeT86IENoYW5uZWxBY2Nlc3NvcjxEYXR1bT47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB0aWNrcyBhcmUgdXNlZCBvbiBhIG5vbi1iYW5kd2lkdGggc2NhbGUsIHRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlXG4gICAgICAgICAqIGxlbmd0aCBvZiB0aGUgdGljay4gRGVmYXVsdHMgdG8gMTAgcGl4ZWxcbiAgICAgICAgICovXG4gICAgICAgIHRpY2tMZW5ndGg/OiBDb25zdGFudEFjY2Vzc29yPG51bWJlciwgRGF0dW0+O1xuICAgIH1cbiAgICBpbXBvcnQgTWFyayBmcm9tICcuLi9NYXJrLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgaW1wb3J0IHsgcmVzb2x2ZUNoYW5uZWwsIHJlc29sdmVQcm9wLCByZXNvbHZlU2NhbGVkU3R5bGVzIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlLmpzJztcbiAgICBpbXBvcnQgdHlwZSB7XG4gICAgICAgIEJhc2VNYXJrUHJvcHMsXG4gICAgICAgIENoYW5uZWxBY2Nlc3NvcixcbiAgICAgICAgRGF0YVJvdyxcbiAgICAgICAgRmFjZXRDb250ZXh0LFxuICAgICAgICBDb25zdGFudEFjY2Vzc29yXG4gICAgfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgcmVjb3JkaXplWCB9IGZyb20gJy4uL2luZGV4LmpzJztcbiAgICBpbXBvcnQgeyBwcm9qZWN0WCwgcHJvamVjdFkgfSBmcm9tICcuLi9oZWxwZXJzL3NjYWxlcy5qcyc7XG4gICAgaW1wb3J0IHsgaXNWYWxpZCB9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IHRlc3RGaWx0ZXIsIHBhcnNlSW5zZXQgfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbiAgICBpbXBvcnQgeyBnZXRQbG90RGVmYXVsdHMgfSBmcm9tICcuLi9ob29rcy9wbG90RGVmYXVsdHMuanMnO1xuICAgIGltcG9ydCB7IHVzZVBsb3QgfSBmcm9tICcuLi9ob29rcy91c2VQbG90LnN2ZWx0ZS5qcyc7XG5cbiAgICBjb25zdCBwbG90ID0gdXNlUGxvdCgpO1xuXG4gICAgbGV0IG1hcmtQcm9wczogVGlja1hNYXJrUHJvcHMgPSAkcHJvcHMoKTtcbiAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgICAgLi4uZ2V0UGxvdERlZmF1bHRzKCkudGljayxcbiAgICAgICAgLi4uZ2V0UGxvdERlZmF1bHRzKCkudGlja1hcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSA9IFt7fV0sXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWUgPSAnJyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgIH06IFRpY2tYTWFya1Byb3BzID0gJGRlcml2ZWQoe1xuICAgICAgICAuLi5ERUZBVUxUUyxcbiAgICAgICAgLi4ubWFya1Byb3BzXG4gICAgfSk7XG5cbiAgICBsZXQgYXJncyA9ICRkZXJpdmVkKHJlY29yZGl6ZVgoeyBkYXRhLCAuLi5vcHRpb25zIH0sIHsgd2l0aEluZGV4OiBmYWxzZSB9KSk7XG5cbiAgICBjb25zdCB7IGdldFRlc3RGYWNldCB9ID0gZ2V0Q29udGV4dDxGYWNldENvbnRleHQ+KCdzdmVsdGVwbG90L2ZhY2V0Jyk7XG4gICAgbGV0IHRlc3RGYWNldCA9ICRkZXJpdmVkKGdldFRlc3RGYWNldCgpKTtcbjwvc2NyaXB0PlxuXG48TWFya1xuICAgIHR5cGU9XCJ0aWNrWFwiXG4gICAgY2hhbm5lbHM9e1sneCcsICd5JywgJ3N0cm9rZScsICdvcGFjaXR5JywgJ3N0cm9rZU9wYWNpdHknXX1cbiAgICB7Li4ubWFya1Byb3BzfVxuICAgIHsuLi5hcmdzfT5cbiAgICB7I3NuaXBwZXQgY2hpbGRyZW4oeyBtYXJrLCB1c2VkU2NhbGVzIH0pfVxuICAgICAgICA8ZyBjbGFzcz1cInRpY2steFwiPlxuICAgICAgICAgICAgeyNlYWNoIGFyZ3MuZGF0YSBhcyBkYXR1bSwgaSAoaSl9XG4gICAgICAgICAgICAgICAgeyNpZiB0ZXN0RmFjZXQoZGF0dW0sIG1hcmsub3B0aW9ucykgJiYgdGVzdEZpbHRlcihkYXR1bSwgYXJncyl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeF8gPSByZXNvbHZlQ2hhbm5lbCgneCcsIGRhdHVtLCBhcmdzKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCB5XyA9IHJlc29sdmVDaGFubmVsKCd5JywgZGF0dW0sIGFyZ3MpfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IGluc2V0XyA9IHJlc29sdmVQcm9wKGFyZ3MuaW5zZXQsIGRhdHVtLCAwKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCB0aWNrTGVuZ3RoXyA9IHJlc29sdmVQcm9wKGFyZ3MudGlja0xlbmd0aCwgZGF0dW0sIDEwKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCBkeF8gPSByZXNvbHZlUHJvcChhcmdzLmR4LCBkYXR1bSwgMCl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgZHlfID0gcmVzb2x2ZVByb3AoYXJncy5keSwgZGF0dW0sIDApfVxuICAgICAgICAgICAgICAgICAgICB7I2lmIGlzVmFsaWQoeF8pICYmIChpc1ZhbGlkKHlfKSB8fCBhcmdzLnkgPT0gbnVsbCkgJiYgKGFyZ3MuZmlsdGVyID09IG51bGwgfHwgcmVzb2x2ZVByb3AoYXJncy5maWx0ZXIsIGRhdHVtKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHggPSB1c2VkU2NhbGVzLnggPyBwcm9qZWN0WCgneCcsIHBsb3Quc2NhbGVzLCB4XykgOiB4X31cbiAgICAgICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeTEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MueSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXNlZFNjYWxlcy55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByb2plY3RZKCd5MScsIHBsb3Quc2NhbGVzLCB5XylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeV9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwbG90Lm9wdGlvbnMubWFyZ2luVG9wfVxuICAgICAgICAgICAgICAgICAgICAgICAge0Bjb25zdCB5MiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy55ICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB1c2VkU2NhbGVzLnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTnVtYmVyKHByb2plY3RZKCd5MicsIHBsb3Quc2NhbGVzLCB5XykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHlfXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGxvdC5vcHRpb25zLm1hcmdpblRvcCArIHBsb3QucGxvdEhlaWdodH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtAY29uc3QgaW5zZXQgPSBwYXJzZUluc2V0KGluc2V0XywgTWF0aC5hYnMoeTIgLSB5MSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoe3ggKyBkeF99LCB7ZHlffSlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXtyZXNvbHZlU2NhbGVkU3R5bGVzKGRhdHVtLCBhcmdzLCB1c2VkU2NhbGVzLCBwbG90LCAnc3Ryb2tlJyl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTE9e3kxICsgaW5zZXQgKyAoeTEgPT09IHkyID8gdGlja0xlbmd0aF8gKiAwLjUgOiAwKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5Mj17eTIgLSBpbnNldCAtICh5MSA9PT0geTIgPyB0aWNrTGVuZ3RoXyAqIDAuNSA6IDApfSAvPlxuICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZz5cbiAgICB7L3NuaXBwZXR9XG48L01hcms+XG5cbjxzdHlsZT5cbiAgICAudGljay14IGxpbmUge1xuICAgICAgICBzdHJva2U6IGN1cnJlbnRDb2xvcjtcbiAgICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiIiLCJpZ25vcmVMaXN0IjpbXX0= */"
};
function TickX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TickX);
  append_styles($$anchor, $$css17);
  const plot = usePlot();
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().tick, ...getPlotDefaults().tickX };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  let args = tag(user_derived(() => recordizeX({ data: get(data), ...get(options) }, { withIndex: false })), "args");
  const { getTestFacet } = getContext("svelteplot/facet");
  let testFacet = tag(user_derived(getTestFacet), "testFacet");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(TickX, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_125();
      add_svelte_meta(
        () => each(g, 21, () => get(args).data, index, ($$anchor3, datum) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent_1 = ($$anchor4) => {
              const x_ = tag(user_derived(() => resolveChannel("x", get(datum), get(args))), "x_");
              get(x_);
              const y_ = tag(user_derived(() => resolveChannel("y", get(datum), get(args))), "y_");
              get(y_);
              const inset_ = tag(user_derived(() => resolveProp(get(args).inset, get(datum), 0)), "inset_");
              get(inset_);
              const tickLength_ = tag(user_derived(() => resolveProp(get(args).tickLength, get(datum), 10)), "tickLength_");
              get(tickLength_);
              const dx_ = tag(user_derived(() => resolveProp(get(args).dx, get(datum), 0)), "dx_");
              get(dx_);
              const dy_ = tag(user_derived(() => resolveProp(get(args).dy, get(datum), 0)), "dy_");
              get(dy_);
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              {
                var consequent = ($$anchor5) => {
                  const x2 = tag(user_derived(() => usedScales().x ? projectX("x", plot.scales, get(x_)) : get(x_)), "x");
                  get(x2);
                  const y12 = tag(
                    user_derived(() => equals(get(args).y, null, false) ? usedScales().y ? projectY("y1", plot.scales, get(y_)) : get(y_) : plot.options.marginTop),
                    "y1"
                  );
                  get(y12);
                  const y2 = tag(
                    user_derived(() => equals(get(args).y, null, false) ? usedScales().y ? Number(projectY("y2", plot.scales, get(y_))) : get(y_) : plot.options.marginTop + plot.plotHeight),
                    "y2"
                  );
                  get(y2);
                  const inset = tag(user_derived(() => parseInset(get(inset_), Math.abs(get(y2) - get(y12)))), "inset");
                  get(inset);
                  var line = root_48();
                  template_effect(
                    ($0) => {
                      set_attribute(line, "transform", `translate(${get(x2) + get(dx_)}, ${get(dy_) ?? ""})`);
                      set_style(line, $0);
                      set_attribute(line, "y1", get(y12) + get(inset) + (strict_equals(get(y12), get(y2)) ? get(tickLength_) * 0.5 : 0));
                      set_attribute(line, "y2", get(y2) - get(inset) - (strict_equals(get(y12), get(y2)) ? get(tickLength_) * 0.5 : 0));
                    },
                    [
                      () => resolveScaledStyles(get(datum), get(args), usedScales(), plot, "stroke")
                    ]
                  );
                  append($$anchor5, line);
                };
                add_svelte_meta(
                  () => if_block(node_2, ($$render) => {
                    if (isValid(get(x_)) && (isValid(get(y_)) || equals(get(args).y, null)) && (equals(get(args).filter, null) || resolveProp(get(args).filter, get(datum)))) $$render(consequent);
                  }),
                  "if",
                  TickX,
                  78,
                  20
                );
              }
              append($$anchor4, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (get(testFacet)(get(datum), mark().options) && testFilter(get(datum), get(args))) $$render(consequent_1);
              }),
              "if",
              TickX,
              71,
              16
            );
          }
          append($$anchor3, fragment_1);
        }),
        "each",
        TickX,
        70,
        12
      );
      reset(g);
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "tickX",
          channels: ["x", "y", "stroke", "opacity", "strokeOpacity"]
        },
        () => markProps,
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      TickX,
      63,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  TickX = hmr(TickX);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-UD0hmGwor-Gs");
    TickX[HMR].update(module.default);
  });
}
var TickX_default = TickX;

// node_modules/svelteplot/dist/marks/TickY.svelte
TickY[FILENAME] = "node_modules/svelteplot/dist/marks/TickY.svelte";
var root_49 = add_locations(from_svg(`<line class="s-S3-An13p6Uv_"></line>`), TickY[FILENAME], [[92, 24]]);
var root_126 = add_locations(from_svg(`<g class="tick-y s-S3-An13p6Uv_"></g>`), TickY[FILENAME], [[68, 8]]);
var $$css18 = {
  hash: "s-S3-An13p6Uv_",
  code: "\n    .tick-y.s-S3-An13p6Uv_ line:where(.s-S3-An13p6Uv_) {\n        stroke: currentColor;\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGlja1kuc3ZlbHRlIiwic291cmNlcyI6WyJUaWNrWS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLSBcbiAgICBAY29tcG9uZW50IFxuICAgIFRoZSBUaWNrWSBtYXJrIGlzIHVzZWZ1bCBmb3Igc2hvd2luZyBvbmUtZGltZW5zaW9uYWwgZGlzdHJpYnV0aW9ucyBhbG9uZyB0aGUgeSBheGlzLiBUaGUgeCBheGlzIG11c3QgYmUgYSBiYW5kIHNjYWxlLlxuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiIGdlbmVyaWNzPVwiRGF0dW0gZXh0ZW5kcyBEYXRhUm93XCI+XG4gICAgaW50ZXJmYWNlIFRpY2tZTWFya1Byb3BzIGV4dGVuZHMgT21pdDxCYXNlTWFya1Byb3BzPERhdHVtPiwgJ2ZpbGwnIHwgJ2ZpbGxPcGFjaXR5Jz4ge1xuICAgICAgICBkYXRhOiBEYXR1bVtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIHZlcnRpY2FsIHBvc2l0aW9uOyBib3VuZCB0byB0aGUgeCBzY2FsZVxuICAgICAgICAgKi9cbiAgICAgICAgeT86IENoYW5uZWxBY2Nlc3NvcjxEYXR1bT47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbjsgYm91bmQgdG8gdGhlIHkgc2NhbGUsIHdoaWNoIG11c3QgYmUgYmFuZC4gSWYgdGhlIHkgY2hhbm5lbFxuICAgICAgICAgKiBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgdGljayB3aWxsIHNwYW4gdGhlIGZ1bGwgdmVydGljYWwgZXh0ZW50IG9mIHRoZSBmcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHg/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYgdGlja3MgYXJlIHVzZWQgb24gYSBub24tYmFuZHdpZHRoIHNjYWxlLCB0aGlzIHdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgICAgICAgKiBsZW5ndGggb2YgdGhlIHRpY2suIERlZmF1bHRzIHRvIDEwIHBpeGVsXG4gICAgICAgICAqL1xuICAgICAgICB0aWNrTGVuZ3RoPzogQ29uc3RhbnRBY2Nlc3NvcjxudW1iZXIsIERhdHVtPjtcbiAgICB9XG4gICAgaW1wb3J0IE1hcmsgZnJvbSAnLi4vTWFyay5zdmVsdGUnO1xuICAgIGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IHJlc29sdmVDaGFubmVsLCByZXNvbHZlUHJvcCwgcmVzb2x2ZVNjYWxlZFN0eWxlcyB9IGZyb20gJy4uL2hlbHBlcnMvcmVzb2x2ZS5qcyc7XG4gICAgaW1wb3J0IHR5cGUge1xuICAgICAgICBCYXNlTWFya1Byb3BzLFxuICAgICAgICBDaGFubmVsQWNjZXNzb3IsXG4gICAgICAgIERhdGFSb3csXG4gICAgICAgIEZhY2V0Q29udGV4dCxcbiAgICAgICAgQ29uc3RhbnRBY2Nlc3NvclxuICAgIH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuICAgIGltcG9ydCB7IHJlY29yZGl6ZVkgfSBmcm9tICcuLi9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgcHJvamVjdFgsIHByb2plY3RZIH0gZnJvbSAnLi4vaGVscGVycy9zY2FsZXMuanMnO1xuICAgIGltcG9ydCB7IGlzVmFsaWQgfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbiAgICBpbXBvcnQgeyB0ZXN0RmlsdGVyLCBwYXJzZUluc2V0IH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgZ2V0UGxvdERlZmF1bHRzIH0gZnJvbSAnLi4vaG9va3MvcGxvdERlZmF1bHRzLmpzJztcbiAgICBpbXBvcnQgeyB1c2VQbG90IH0gZnJvbSAnLi4vaG9va3MvdXNlUGxvdC5zdmVsdGUuanMnO1xuXG4gICAgY29uc3QgcGxvdCA9IHVzZVBsb3QoKTtcblxuICAgIGxldCBtYXJrUHJvcHM6IFRpY2tZTWFya1Byb3BzID0gJHByb3BzKCk7XG4gICAgY29uc3QgREVGQVVMVFMgPSB7XG4gICAgICAgIC4uLmdldFBsb3REZWZhdWx0cygpLnRpY2ssXG4gICAgICAgIC4uLmdldFBsb3REZWZhdWx0cygpLnRpY2tZXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICAgIGRhdGEgPSBbe31dLFxuICAgICAgICBjbGFzczogY2xhc3NOYW1lID0gJycsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9OiBUaWNrWU1hcmtQcm9wcyA9ICRkZXJpdmVkKHtcbiAgICAgICAgLi4uREVGQVVMVFMsXG4gICAgICAgIC4uLm1hcmtQcm9wc1xuICAgIH0pO1xuXG4gICAgbGV0IGFyZ3MgPSAkZGVyaXZlZChyZWNvcmRpemVZKHsgZGF0YSwgLi4ub3B0aW9ucyB9LCB7IHdpdGhJbmRleDogZmFsc2UgfSkpO1xuXG4gICAgY29uc3QgeyBnZXRUZXN0RmFjZXQgfSA9IGdldENvbnRleHQ8RmFjZXRDb250ZXh0Pignc3ZlbHRlcGxvdC9mYWNldCcpO1xuICAgIGxldCB0ZXN0RmFjZXQgPSAkZGVyaXZlZChnZXRUZXN0RmFjZXQoKSk7XG48L3NjcmlwdD5cblxuPE1hcmtcbiAgICB0eXBlPVwidGlja1lcIlxuICAgIGNoYW5uZWxzPXtbJ3gnLCAneScsICdzdHJva2UnLCAnb3BhY2l0eScsICdzdHJva2VPcGFjaXR5J119XG4gICAgey4uLm1hcmtQcm9wc31cbiAgICB7Li4uYXJnc30+XG4gICAgeyNzbmlwcGV0IGNoaWxkcmVuKHsgbWFyaywgdXNlZFNjYWxlcyB9KX1cbiAgICAgICAgPGcgY2xhc3M9XCJ0aWNrLXlcIj5cbiAgICAgICAgICAgIHsjZWFjaCBhcmdzLmRhdGEgYXMgZGF0dW0sIGkgKGkpfVxuICAgICAgICAgICAgICAgIHsjaWYgdGVzdEZhY2V0KGRhdHVtLCBtYXJrLm9wdGlvbnMpICYmIHRlc3RGaWx0ZXIoZGF0dW0sIGFyZ3MpfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHlfID0gcmVzb2x2ZUNoYW5uZWwoJ3knLCBkYXR1bSwgYXJncyl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgeF8gPSByZXNvbHZlQ2hhbm5lbCgneCcsIGRhdHVtLCBhcmdzKX1cbiAgICAgICAgICAgICAgICAgICAge0Bjb25zdCBpbnNldF8gPSByZXNvbHZlUHJvcChhcmdzLmluc2V0LCBkYXR1bSwgMCl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgdGlja0xlbmd0aF8gPSByZXNvbHZlUHJvcChhcmdzLnRpY2tMZW5ndGgsIGRhdHVtLCAxMCl9XG4gICAgICAgICAgICAgICAgICAgIHtAY29uc3QgZHhfID0gcmVzb2x2ZVByb3AoYXJncy5keCwgZGF0dW0sIDApfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IGR5XyA9IHJlc29sdmVQcm9wKGFyZ3MuZHksIGRhdHVtLCAwKX1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBpc1ZhbGlkKHlfKSAmJiAoaXNWYWxpZCh4XykgfHwgYXJncy54ID09IG51bGwpfVxuICAgICAgICAgICAgICAgICAgICAgICAge0Bjb25zdCB5ID0gdXNlZFNjYWxlcy55ID8gcHJvamVjdFkoJ3knLCBwbG90LnNjYWxlcywgeV8pIDogeV99XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHgxID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnggIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVzZWRTY2FsZXMueFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9qZWN0WCgneDEnLCBwbG90LnNjYWxlcywgeF8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHhfXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGxvdC5vcHRpb25zLm1hcmdpbkxlZnR9XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IHgyID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnggIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVzZWRTY2FsZXMueFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9qZWN0WCgneDInLCBwbG90LnNjYWxlcywgeF8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHhfXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcGxvdC5vcHRpb25zLm1hcmdpbkxlZnQgKyBwbG90LmZhY2V0V2lkdGh9XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IGluc2V0ID0gcGFyc2VJbnNldChpbnNldF8sIE1hdGguYWJzKHgyIC0geDEpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKHtkeF99LCB7eSArIGR5X30pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17cmVzb2x2ZVNjYWxlZFN0eWxlcyhkYXR1bSwgYXJncywgdXNlZFNjYWxlcywgcGxvdCwgJ3N0cm9rZScpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxPXt4MSArIGluc2V0ICsgKHgxID09PSB4MiA/IHRpY2tMZW5ndGhfICogMC41IDogMCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI9e3gyIC0gaW5zZXQgLSAoeDEgPT09IHgyID8gdGlja0xlbmd0aF8gKiAwLjUgOiAwKX0gLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2c+XG4gICAgey9zbmlwcGV0fVxuPC9NYXJrPlxuXG48c3R5bGU+XG4gICAgLnRpY2steSBsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiBjdXJyZW50Q29sb3I7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiaWdub3JlTGlzdCI6W119 */"
};
function TickY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TickY);
  append_styles($$anchor, $$css18);
  const plot = usePlot();
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = { ...getPlotDefaults().tick, ...getPlotDefaults().tickY };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, "")), "className"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class"])), "options");
  let args = tag(user_derived(() => recordizeY({ data: get(data), ...get(options) }, { withIndex: false })), "args");
  const { getTestFacet } = getContext("svelteplot/facet");
  let testFacet = tag(user_derived(getTestFacet), "testFacet");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(TickY, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      var g = root_126();
      add_svelte_meta(
        () => each(g, 21, () => get(args).data, index, ($$anchor3, datum) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent_1 = ($$anchor4) => {
              const y_ = tag(user_derived(() => resolveChannel("y", get(datum), get(args))), "y_");
              get(y_);
              const x_ = tag(user_derived(() => resolveChannel("x", get(datum), get(args))), "x_");
              get(x_);
              const inset_ = tag(user_derived(() => resolveProp(get(args).inset, get(datum), 0)), "inset_");
              get(inset_);
              const tickLength_ = tag(user_derived(() => resolveProp(get(args).tickLength, get(datum), 10)), "tickLength_");
              get(tickLength_);
              const dx_ = tag(user_derived(() => resolveProp(get(args).dx, get(datum), 0)), "dx_");
              get(dx_);
              const dy_ = tag(user_derived(() => resolveProp(get(args).dy, get(datum), 0)), "dy_");
              get(dy_);
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              {
                var consequent = ($$anchor5) => {
                  const y2 = tag(user_derived(() => usedScales().y ? projectY("y", plot.scales, get(y_)) : get(y_)), "y");
                  get(y2);
                  const x12 = tag(
                    user_derived(() => equals(get(args).x, null, false) ? usedScales().x ? projectX("x1", plot.scales, get(x_)) : get(x_) : plot.options.marginLeft),
                    "x1"
                  );
                  get(x12);
                  const x2 = tag(
                    user_derived(() => equals(get(args).x, null, false) ? usedScales().x ? projectX("x2", plot.scales, get(x_)) : get(x_) : plot.options.marginLeft + plot.facetWidth),
                    "x2"
                  );
                  get(x2);
                  const inset = tag(user_derived(() => parseInset(get(inset_), Math.abs(get(x2) - get(x12)))), "inset");
                  get(inset);
                  var line = root_49();
                  template_effect(
                    ($0) => {
                      set_attribute(line, "transform", `translate(${get(dx_) ?? ""}, ${get(y2) + get(dy_)})`);
                      set_style(line, $0);
                      set_attribute(line, "x1", get(x12) + get(inset) + (strict_equals(get(x12), get(x2)) ? get(tickLength_) * 0.5 : 0));
                      set_attribute(line, "x2", get(x2) - get(inset) - (strict_equals(get(x12), get(x2)) ? get(tickLength_) * 0.5 : 0));
                    },
                    [
                      () => resolveScaledStyles(get(datum), get(args), usedScales(), plot, "stroke")
                    ]
                  );
                  append($$anchor5, line);
                };
                add_svelte_meta(
                  () => if_block(node_2, ($$render) => {
                    if (isValid(get(y_)) && (isValid(get(x_)) || equals(get(args).x, null))) $$render(consequent);
                  }),
                  "if",
                  TickY,
                  77,
                  20
                );
              }
              append($$anchor4, fragment_2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if (get(testFacet)(get(datum), mark().options) && testFilter(get(datum), get(args))) $$render(consequent_1);
              }),
              "if",
              TickY,
              70,
              16
            );
          }
          append($$anchor3, fragment_1);
        }),
        "each",
        TickY,
        69,
        12
      );
      reset(g);
      append($$anchor2, g);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "tickY",
          channels: ["x", "y", "stroke", "opacity", "strokeOpacity"]
        },
        () => markProps,
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      TickY,
      62,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  TickY = hmr(TickY);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-S3-An13p6Uv_");
    TickY[HMR].update(module.default);
  });
}
var TickY_default = TickY;

// node_modules/svelteplot/dist/marks/helpers/trail.js
function trailPath(samples, defined, context, options = {}) {
  const { curve = "linear", cap = "round", tension = 0.5 } = options;
  const samplesPerSegment = options.samplesPerSegment ?? estimateSamplesPerSegment(samples, defined);
  const curveFactory = maybeCurve(curve, tension);
  let drawSamples = samples;
  let drawDefined = defined;
  if (curve !== "linear" || tension !== 0) {
    const smoothedSamples = [];
    const smoothedDefined = [];
    const len2 = Math.min(samples.length, defined.length);
    let i2 = 0;
    while (i2 < len2) {
      if (!defined[i2]) {
        smoothedSamples.push(samples[i2]);
        smoothedDefined.push(false);
        i2 += 1;
        continue;
      }
      const segment = [];
      while (i2 < len2 && defined[i2]) {
        segment.push(samples[i2]);
        i2 += 1;
      }
      const resampled = resampleCurve(segment, curveFactory, Math.max(1, samplesPerSegment));
      smoothedSamples.push(...resampled);
      smoothedDefined.push(...new Array(resampled.length).fill(true));
      if (i2 < len2) {
        smoothedSamples.push(samples[i2]);
        smoothedDefined.push(false);
      }
    }
    drawSamples = smoothedSamples;
    drawDefined = smoothedDefined;
  }
  const len = Math.min(drawSamples.length, drawDefined.length);
  if (len === 0)
    return;
  if (cap === "butt") {
    const normalizeVec = (x2, y2) => {
      const lenVec = Math.hypot(x2, y2);
      return lenVec === 0 ? [0, 0] : [x2 / lenVec, y2 / lenVec];
    };
    let i2 = 0;
    while (i2 < len) {
      if (!drawDefined[i2]) {
        i2 += 1;
        continue;
      }
      const runStart = i2;
      while (i2 < len && drawDefined[i2])
        i2 += 1;
      const runEnd = i2 - 1;
      const left = [];
      const right = [];
      for (let j = runStart; j <= runEnd; j += 1) {
        const curr = drawSamples[j];
        const r = curr.r;
        const hasPrev = j > runStart;
        const hasNext = j < runEnd;
        const prev = hasPrev ? drawSamples[j - 1] : curr;
        const next = hasNext ? drawSamples[j + 1] : curr;
        const dirPrev = hasPrev ? normalizeVec(curr.x - prev.x, curr.y - prev.y) : normalizeVec(next.x - curr.x, next.y - curr.y);
        const dirNext = hasNext ? normalizeVec(next.x - curr.x, next.y - curr.y) : dirPrev;
        const normPrev = [-dirPrev[1], dirPrev[0]];
        const normNext = [-dirNext[1], dirNext[0]];
        let nx = normPrev[0] + normNext[0];
        let ny = normPrev[1] + normNext[1];
        const nLen = Math.hypot(nx, ny);
        if (nLen < 1e-6) {
          nx = normPrev[0];
          ny = normPrev[1];
        } else {
          nx /= nLen;
          ny /= nLen;
        }
        const dot = nx * normPrev[0] + ny * normPrev[1];
        const safeDot = Math.abs(dot) < 1e-6 ? 1 : dot;
        const scale = r / safeDot;
        const ox = nx * scale;
        const oy = ny * scale;
        left.push([curr.x + ox, curr.y + oy]);
        right.push([curr.x - ox, curr.y - oy]);
      }
      if (left.length > 0) {
        context.moveTo(left[0][0], left[0][1]);
        for (let j = 1; j < left.length; j += 1) {
          context.lineTo(left[j][0], left[j][1]);
        }
        for (let j = right.length - 1; j >= 0; j -= 1) {
          context.lineTo(right[j][0], right[j][1]);
        }
        context.closePath();
      }
    }
    return typeof context.toString === "function" ? context.toString() : void 0;
  }
  let ready = false;
  let x12 = 0;
  let y12 = 0;
  let r1 = 0;
  function point6(x2, y2, r2, isStartOfRun, isEndOfRun) {
    if (ready) {
      let ux = y12 - y2;
      let uy = x2 - x12;
      if (ux || uy) {
        const ud = Math.hypot(ux, uy);
        const rx = (ux /= ud) * r1;
        const ry = (uy /= ud) * r1;
        const t = Math.atan2(uy, ux);
        const drawStartCap = !isStartOfRun || cap === "round";
        const drawEndCap = !isEndOfRun || cap === "round";
        context.moveTo(x12 - rx, y12 - ry);
        context.lineTo(x2 - ux * r2, y2 - uy * r2);
        if (drawEndCap) {
          context.arc(x2, y2, r2, t - Math.PI, t);
        } else {
          context.lineTo(x2 + ux * r2, y2 + uy * r2);
        }
        context.lineTo(x12 + rx, y12 + ry);
        if (drawStartCap) {
          context.arc(x12, y12, r1, t, t + Math.PI);
        }
      } else {
        if (cap === "round" || !isStartOfRun && !isEndOfRun) {
          context.arc(x2, y2, r2, 0, TAU);
        }
      }
      context.closePath();
    } else {
      ready = true;
    }
    x12 = x2;
    y12 = y2;
    r1 = r2;
  }
  let i = 0;
  while (i < len) {
    if (!drawDefined[i]) {
      i += 1;
      ready = false;
      continue;
    }
    const runStart = i;
    while (i < len && drawDefined[i])
      i += 1;
    const runEnd = i - 1;
    const first = drawSamples[runStart];
    ready = false;
    x12 = first.x;
    y12 = first.y;
    r1 = first.r;
    ready = true;
    for (let j = runStart + 1; j <= runEnd; j += 1) {
      const { x: x2, y: y2, r } = drawSamples[j];
      const isStart = j - 1 === runStart;
      const isEnd = j === runEnd;
      point6(Number(x2), Number(y2), Number(r), isStart, isEnd);
    }
    ready = false;
  }
  return typeof context.toString === "function" ? context.toString() : void 0;
}
function resampleCurve(points2, curveFactory, samplesPerSegment) {
  if (points2.length === 0)
    return [];
  const commands = [];
  let pendingRadius = points2[0].r;
  let currentRadius = points2[0].r;
  let currentPoint = null;
  const ctx = {
    beginPath() {
    },
    closePath() {
    },
    moveTo(x2, y2) {
      currentPoint = [x2, y2];
      currentRadius = pendingRadius;
      commands.push({ type: "move", to: [x2, y2], r: currentRadius });
    },
    lineTo(x2, y2) {
      const from = currentPoint ?? [x2, y2];
      commands.push({
        type: "line",
        from: [from[0], from[1], currentRadius],
        to: [x2, y2, pendingRadius]
      });
      currentPoint = [x2, y2];
      currentRadius = pendingRadius;
    },
    bezierCurveTo(x12, y12, x2, y2, x3, y3) {
      const from = currentPoint ?? [x3, y3];
      commands.push({
        type: "cubic",
        from: [from[0], from[1], currentRadius],
        cp1: [x12, y12],
        cp2: [x2, y2],
        to: [x3, y3, pendingRadius]
      });
      currentPoint = [x3, y3];
      currentRadius = pendingRadius;
    },
    quadraticCurveTo(x12, y12, x2, y2) {
      const from = currentPoint ?? [x2, y2];
      commands.push({
        type: "quad",
        from: [from[0], from[1], currentRadius],
        cp: [x12, y12],
        to: [x2, y2, pendingRadius]
      });
      currentPoint = [x2, y2];
      currentRadius = pendingRadius;
    },
    arc() {
    },
    rect() {
    }
  };
  const curve = curveFactory(ctx);
  curve.lineStart();
  for (let idx = 0; idx < points2.length; idx += 1) {
    const pt = points2[idx];
    pendingRadius = pt.r;
    curve.point(pt.x, pt.y);
  }
  curve.lineEnd();
  const geom = flattenCommands(commands, samplesPerSegment);
  if (geom.length === 0)
    return geom;
  const origCum = [0];
  for (let i = 1; i < points2.length; i += 1) {
    const dx = points2[i].x - points2[i - 1].x;
    const dy = points2[i].y - points2[i - 1].y;
    origCum.push(origCum[i - 1] + Math.hypot(dx, dy));
  }
  const origTotal = origCum[origCum.length - 1] || 1;
  const resCum = [0];
  for (let i = 1; i < geom.length; i += 1) {
    const dx = geom[i].x - geom[i - 1].x;
    const dy = geom[i].y - geom[i - 1].y;
    resCum.push(resCum[i - 1] + Math.hypot(dx, dy));
  }
  const resTotal = resCum[resCum.length - 1] || 1;
  const radiusAt = (target) => {
    let idx = 1;
    while (idx < origCum.length && origCum[idx] < target)
      idx += 1;
    if (idx === origCum.length)
      return points2[points2.length - 1].r;
    const t03 = origCum[idx - 1];
    const t13 = origCum[idx];
    const r0 = points2[idx - 1].r;
    const r1 = points2[idx].r;
    const t = t13 === t03 ? 0 : (target - t03) / (t13 - t03);
    return lerp(r0, r1, t);
  };
  for (let i = 0; i < geom.length; i += 1) {
    const frac = resCum[i] / resTotal;
    geom[i].r = Number(radiusAt(frac * origTotal).toFixed(2));
  }
  return geom;
}
function flattenCommands(commands, samplesPerSegment, precision = 2) {
  const result = [];
  let last2 = null;
  const round2 = (v) => {
    const m = 10 ** precision;
    return Math.round(v * m) / m;
  };
  const pushPoint = (x2, y2, r) => {
    x2 = round2(x2);
    y2 = round2(y2);
    r = round2(r);
    if (!last2 || last2[0] !== x2 || last2[1] !== y2 || last2[2] !== r) {
      result.push({ x: x2, y: y2, r });
      last2 = [x2, y2, r];
    }
  };
  for (const cmd of commands) {
    if (cmd.type === "move") {
      pushPoint(cmd.to[0], cmd.to[1], cmd.r);
      continue;
    }
    if (cmd.type === "line") {
      const [x12, y12, r1] = cmd.from;
      const [x2, y2, r2] = cmd.to;
      for (let step = 1; step <= samplesPerSegment; step += 1) {
        const t = step / samplesPerSegment;
        pushPoint(lerp(x12, x2, t), lerp(y12, y2, t), lerp(r1, r2, t));
      }
      continue;
    }
    if (cmd.type === "cubic") {
      const [x06, y06, r0] = cmd.from;
      const [x12, y12] = cmd.cp1;
      const [x2, y2] = cmd.cp2;
      const [x3, y3, r3] = cmd.to;
      for (let step = 1; step <= samplesPerSegment; step += 1) {
        const t = step / samplesPerSegment;
        pushPoint(cubic(x06, x12, x2, x3, t), cubic(y06, y12, y2, y3, t), lerp(r0, r3, t));
      }
      continue;
    }
    if (cmd.type === "quad") {
      const [x06, y06, r0] = cmd.from;
      const [cx, cy] = cmd.cp;
      const [x12, y12, r1] = cmd.to;
      for (let step = 1; step <= samplesPerSegment; step += 1) {
        const t = step / samplesPerSegment;
        pushPoint(quad(x06, cx, x12, t), quad(y06, cy, y12, t), lerp(r0, r1, t));
      }
    }
  }
  return result;
}
function cubic(p0, p1, p2, p3, t) {
  const it = 1 - t;
  return it * it * it * p0 + 3 * it * it * t * p1 + 3 * it * t * t * p2 + t * t * t * p3;
}
function quad(p0, p1, p2, t) {
  const it = 1 - t;
  return it * it * p0 + 2 * it * t * p1 + t * t * p2;
}
function lerp(a2, b, t) {
  return a2 + (b - a2) * t;
}
function estimateSamplesPerSegment(samples, defined) {
  const n = Math.min(samples.length, defined.length);
  let distSum = 0;
  let distCount = 0;
  let rSum = 0;
  let rCount = 0;
  for (let i = 0; i < n; i++) {
    if (defined[i]) {
      rSum += samples[i].r;
      rCount += 1;
    }
    if (i === 0 || !defined[i] || !defined[i - 1])
      continue;
    const dx = samples[i].x - samples[i - 1].x;
    const dy = samples[i].y - samples[i - 1].y;
    const d = Math.hypot(dx, dy);
    if (isFinite(d) && d > 0) {
      distSum += d;
      distCount += 1;
    }
  }
  const meanDist = distCount ? distSum / distCount : 0;
  const meanRadius = rCount ? rSum / rCount : 0;
  const base = meanRadius > 0 ? meanDist / meanRadius : meanDist;
  return Math.max(1, Math.min(32, Math.round(base || 1)));
}
var trail_default = trailPath;

// node_modules/svelteplot/dist/marks/helpers/TrailCanvas.svelte
TrailCanvas[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/TrailCanvas.svelte";
function TrailCanvas($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, TrailCanvas);
  function maybeOpacity(value) {
    return equals(value, null) ? 1 : +value;
  }
  const plot = usePlot();
  const render = (canvas) => {
    const context = canvas.getContext("2d");
    user_effect(() => {
      if (context) {
        context.resetTransform();
        context.scale(devicePixelRatio.current ?? 1, devicePixelRatio.current ?? 1);
        for (const trailData of $$props.data) {
          if (trailData.length < 2) continue;
          const firstPoint = trailData[0];
          if (!firstPoint || !firstPoint.valid) continue;
          const samples = trailData.map((d) => ({ x: Number(d.x), y: Number(d.y), r: Number(d.r ?? 0) }));
          const defined = trailData.map((d) => d.valid && d.r >= 0 && (resolveProp($$props.options.defined, d.datum, true) ?? true));
          let { fill: fill2, ...restStyles } = resolveScaledStyleProps(firstPoint.datum, $$props.options, $$props.usedScales, plot, "fill");
          const opacity = maybeOpacity(restStyles["opacity"]);
          const fillOpacity = maybeOpacity(restStyles["fill-opacity"]);
          fill2 = resolveColor(fill2, canvas);
          context.fillStyle = fill2 ? fill2 : "currentColor";
          context.beginPath();
          trailPath(samples, defined, context, {
            curve: $$props.curve,
            cap: $$props.cap,
            tension: $$props.tension,
            ...strict_equals(typeof $$props.resolution, "number") ? { samplesPerSegment: $$props.resolution } : {}
          });
          context.globalAlpha = opacity * fillOpacity;
          context.fill();
        }
      }
      return () => {
        context?.clearRect(0, 0, plot.width * (devicePixelRatio.current ?? 1), plot.height * (devicePixelRatio.current ?? 1));
      };
    });
  };
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => CanvasLayer_default(node, { [createAttachmentKey()]: render }), "component", TrailCanvas, 138, 0, { componentTag: "CanvasLayer" });
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  TrailCanvas = hmr(TrailCanvas);
  import.meta.hot.accept((module) => {
    TrailCanvas[HMR].update(module.default);
  });
}
var TrailCanvas_default = TrailCanvas;

// node_modules/svelteplot/dist/marks/Trail.svelte
Trail[FILENAME] = "node_modules/svelteplot/dist/marks/Trail.svelte";
var root_57 = add_locations(from_svg(`<path></path>`), Trail[FILENAME], [[147, 24]]);
var root_410 = add_locations(from_svg(`<g></g>`), Trail[FILENAME], [[117, 16]]);
function Trail($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Trail);
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const DEFAULTS = {
    curve: "linear",
    r: 3,
    canvas: false,
    resolution: "auto",
    cap: "round",
    tension: 0,
    ...getPlotDefaults().trail
  };
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), curve = tag(user_derived(() => get($$d).curve), "curve"), resolution = tag(user_derived(() => get($$d).resolution), "resolution"), tension = tag(user_derived(() => get($$d).tension), "tension"), canvas = tag(user_derived(() => get($$d).canvas), "canvas"), cap = tag(user_derived(() => get($$d).cap), "cap"), className = tag(user_derived(() => get($$d).class), "className"), options = tag(
    user_derived(() => exclude_from_object(get($$d), [
      "data",
      "curve",
      "resolution",
      "tension",
      "canvas",
      "cap",
      "class"
    ])),
    "options"
  );
  const args = tag(user_derived(() => sort2({ data: get(data), ...get(options) })), "args");
  const plot = usePlot();
  function groupIndex(data2, groupByKey2) {
    if (!groupByKey2) return [data2];
    let group3 = [];
    const groups2 = [group3];
    let lastGroupValue;
    for (const d of data2) {
      const groupValue = resolveProp(groupByKey2, d.datum);
      if (strict_equals(groupValue, lastGroupValue) || strict_equals(group3.length, 0)) {
        group3.push(d);
        lastGroupValue = groupValue;
      } else {
        group3 = [d];
        groups2.push(group3);
        lastGroupValue = groupValue;
      }
    }
    return groups2.filter((d) => d.length > 0);
  }
  const groupByKey = tag(user_derived(() => get(args).z || get(args).fill), "groupByKey");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Trail, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent_1 = ($$anchor3) => {
          const groupedTrailData = tag(user_derived(() => groupIndex(scaledData(), get(groupByKey))), "groupedTrailData");
          get(groupedTrailData);
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              add_svelte_meta(
                () => TrailCanvas_default(node_3, {
                  get curve() {
                    return get(curve);
                  },
                  get cap() {
                    return get(cap);
                  },
                  get tension() {
                    return get(tension);
                  },
                  get resolution() {
                    return get(resolution);
                  },
                  get usedScales() {
                    return usedScales();
                  },
                  get data() {
                    return get(groupedTrailData);
                  },
                  get options() {
                    return get(args);
                  }
                }),
                "component",
                Trail,
                108,
                16,
                { componentTag: "TrailCanvas" }
              );
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var g = root_410();
              add_svelte_meta(
                () => each(g, 21, () => get(groupedTrailData), index, ($$anchor5, trailData) => {
                  const samples = tag(user_derived(() => get(trailData).map((d) => ({ x: Number(d.x), y: Number(d.y), r: Number(d.r ?? 0) }))), "samples");
                  get(samples);
                  const defined = tag(user_derived(() => get(trailData).map((d) => d.valid && d.r >= 0 && (resolveProp(get(options).defined, d.datum, true) ?? true))), "defined");
                  get(defined);
                  const pathString = tag(
                    user_derived(() => trail_default(get(samples), get(defined), path(), {
                      curve: get(curve),
                      cap: get(cap),
                      tension: get(tension),
                      ...strict_equals(typeof get(resolution), "number") ? { samplesPerSegment: get(resolution) } : {}
                    })),
                    "pathString"
                  );
                  get(pathString);
                  const computed_const = tag(
                    user_derived(() => {
                      const [style, styleClass] = resolveStyles(plot, get(trailData)[0], { ...get(args) }, "fill", usedScales());
                      return { style, styleClass };
                    }),
                    "[@const]"
                  );
                  get(computed_const);
                  var path2 = root_57();
                  attach(path2, () => addEventHandlers({
                    plot,
                    options: mark().options,
                    datum: get(trailData)[0].datum
                  }));
                  template_effect(() => {
                    set_attribute(path2, "d", get(pathString));
                    set_style(path2, get(computed_const).style);
                    set_class(path2, 0, clsx(get(computed_const).styleClass));
                  });
                  append($$anchor5, path2);
                }),
                "each",
                Trail,
                118,
                20
              );
              reset(g);
              template_effect(() => set_class(g, 0, clsx(["trail", get(className)])));
              append($$anchor4, g);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (get(canvas)) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Trail,
              106,
              12
            );
          }
          append($$anchor3, fragment_2);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (scaledData().length > 0) $$render(consequent_1);
          }),
          "if",
          Trail,
          104,
          8
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "trail",
          channels: ["x", "y", "opacity", "fill", "fillOpacity", "r"],
          required: ["x", "y"]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      Trail,
      98,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Trail = hmr(Trail);
  import.meta.hot.accept((module) => {
    Trail[HMR].update(module.default);
  });
}
var Trail_default = Trail;

// node_modules/svelteplot/dist/marks/helpers/waffle.js
function wafflePolygon(y2, options, scales) {
  const x2 = y2 === "y" ? "x" : "y";
  const y12 = `${y2}1`;
  const y22 = `${y2}2`;
  const xScale = scales[x2];
  const yScale = scales[y2];
  const barwidth = xScale.fn.bandwidth();
  const { unit: unit2 = 1, gap = 1 } = options;
  const round2 = maybeRound(options.round);
  const scale = Math.abs(yScale.fn(unit2) - yScale.fn(0));
  const multiple = options.multiple ?? Math.max(1, Math.floor(Math.sqrt(barwidth / scale)));
  const cx = Math.min(barwidth / multiple, scale * multiple);
  const cy = scale * multiple;
  const tx = (barwidth - multiple * cx) / 2;
  const transform = y2 === "y" ? ([x3, y3]) => [x3 * cx, -y3 * cy] : ([x3, y3]) => [y3 * cy, x3 * cx];
  const [ix, iy] = y2 === "y" ? [0, 1] : [1, 0];
  const y06 = yScale.fn(0);
  const mx = -barwidth / 2;
  return (d) => {
    const y1val = d.resolved[y12];
    const y2val = d.resolved[y22];
    const P = wafflePoints(round2(y1val / unit2), round2(y2val / unit2), multiple).map(transform);
    P.pop();
    const id = getPatternId();
    const pos = [d[x2] + tx + mx, y06];
    return {
      pattern: {
        id,
        patternUnits: "userSpaceOnUse",
        width: cx,
        height: cy
      },
      rect: {
        x: gap / 2,
        y: gap / 2,
        width: cx - gap,
        height: cy - gap
      },
      path: {
        fill: `url(#${id})`,
        transform: `translate(${pos[ix]},${pos[iy]})`,
        d: `M${P.join("L")}Z`
      }
    };
  };
}
function wafflePoints(i1, i2, columns) {
  if (i2 < i1)
    return wafflePoints(i2, i1, columns);
  if (i1 < 0)
    return wafflePointsOffset(i1, i2, columns, Math.ceil(-Math.min(i1, i2) / columns));
  const x1f = Math.floor(i1 % columns);
  const x1c = Math.ceil(i1 % columns);
  const x2f = Math.floor(i2 % columns);
  const x2c = Math.ceil(i2 % columns);
  const y1f = Math.floor(i1 / columns);
  const y1c = Math.ceil(i1 / columns);
  const y2f = Math.floor(i2 / columns);
  const y2c = Math.ceil(i2 / columns);
  const points2 = [];
  if (y2c > y1c)
    points2.push([0, y1c]);
  points2.push([x1f, y1c], [x1f, y1f + i1 % 1], [x1c, y1f + i1 % 1]);
  if (!(i1 % columns > columns - 1)) {
    points2.push([x1c, y1f]);
    if (y2f > y1f)
      points2.push([columns, y1f]);
  }
  if (y2f > y1f)
    points2.push([columns, y2f]);
  points2.push([x2c, y2f], [x2c, y2f + i2 % 1], [x2f, y2f + i2 % 1]);
  if (!(i2 % columns < 1)) {
    points2.push([x2f, y2c]);
    if (y2c > y1c)
      points2.push([0, y2c]);
  }
  points2.push(waffleCentroid(i1, i2, columns));
  return points2;
}
function wafflePointsOffset(i1, i2, columns, k2) {
  return wafflePoints(i1 + k2 * columns, i2 + k2 * columns, columns).map(([x2, y2]) => [x2, y2 - k2]);
}
function waffleCentroid(i1, i2, columns) {
  const r = Math.floor(i2 / columns) - Math.floor(i1 / columns);
  return r === 0 ? (
    // Single row
    waffleRowCentroid(i1, i2, columns)
  ) : r === 1 ? (
    // Two incomplete rows; use the midpoint of their overlap if any, otherwise the larger row
    Math.floor(i2 % columns) > Math.ceil(i1 % columns) ? [(Math.floor(i2 % columns) + Math.ceil(i1 % columns)) / 2, Math.floor(i2 / columns)] : i2 % columns > columns - i1 % columns ? waffleRowCentroid(i2 - i2 % columns, i2, columns) : waffleRowCentroid(i1, columns * Math.ceil(i1 / columns), columns)
  ) : (
    // At least one full row; take the midpoint of all the rows that include the middle
    [columns / 2, (Math.round(i1 / columns) + Math.round(i2 / columns)) / 2]
  );
}
function waffleRowCentroid(i1, i2, columns) {
  const c4 = Math.floor(i2) - Math.floor(i1);
  return c4 === 0 ? (
    // Single cell
    [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (i1 + i2) / 2 % 1]
  ) : c4 === 1 ? (
    // Two incomplete cells; use the overlap if large enough, otherwise use the largest
    i2 % 1 - i1 % 1 > 0.5 ? [Math.ceil(i1 % columns), Math.floor(i2 / columns) + (i1 % 1 + i2 % 1) / 2] : i2 % 1 > 1 - i1 % 1 ? [Math.floor(i2 % columns) + 0.5, Math.floor(i2 / columns) + i2 % 1 / 2] : [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (1 + i1 % 1) / 2]
  ) : (
    // At least one full cell; take the midpoint
    [
      Math.ceil(i1 % columns) + Math.ceil(Math.floor(i2) - Math.ceil(i1)) / 2,
      Math.floor(i1 / columns) + (i2 >= 1 + i1 ? 0.5 : (i1 + i2) / 2 % 1)
    ]
  );
}
function maybeRound(round2) {
  if (round2 === void 0 || round2 === false)
    return Number;
  if (round2 === true)
    return Math.round;
  if (typeof round2 !== "function")
    throw new Error(`invalid round: ${round2}`);
  return round2;
}

// node_modules/svelteplot/dist/marks/WaffleX.svelte
WaffleX[FILENAME] = "node_modules/svelteplot/dist/marks/WaffleX.svelte";
var root_58 = add_locations(from_svg(`<path></path>`), WaffleX[FILENAME], [[100, 24]]);
var root_66 = add_locations(from_svg(`<rect></rect>`), WaffleX[FILENAME], [[105, 24]]);
var root_217 = add_locations(from_svg(`<g><pattern><!></pattern><path></path></g>`), WaffleX[FILENAME], [[95, 12, [[96, 16], [108, 16]]]]);
function WaffleX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, WaffleX);
  const DEFAULTS = {
    fill: "currentColor",
    ...getPlotDefaults().waffle,
    ...getPlotDefaults().waffleX
  };
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, null)), "className"), stack = tag(user_derived(() => get($$d).stack), "stack"), symbol = tag(user_derived(() => fallback(get($$d).symbol, null)), "symbol"), unit2 = tag(user_derived(() => get($$d).unit), "unit"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class", "stack", "symbol", "unit"])), "options");
  const plot = usePlot();
  const args = tag(
    user_derived(() => stackX(
      intervalX(
        // by default, sort by y channel (the ordinal labels)
        sort2(recordizeX({ data: get(data), ...get(options) })),
        { plot }
      ),
      get(stack)
    )),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(WaffleX, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      const wafflePoly = tag(user_derived(() => wafflePolygon("x", get(args), plot.scales)), "wafflePoly");
      get(wafflePoly);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => each(node_1, 17, scaledData, index, ($$anchor3, d) => {
          const borderRadius = tag(user_derived(() => resolveProp(get(args).borderRadius, get(d)?.datum, 0)), "borderRadius");
          get(borderRadius);
          const hasBorderRadius = tag(user_derived(() => strict_equals(typeof get(borderRadius), "number") && get(borderRadius) > 0 || strict_equals(typeof get(borderRadius), "object") && Math.max(get(borderRadius).topRight ?? 0, get(borderRadius).bottomRight ?? 0, get(borderRadius).topLeft ?? 0, get(borderRadius).bottomLeft ?? 0) > 0), "hasBorderRadius");
          get(hasBorderRadius);
          const computed_const = tag(
            user_derived(() => {
              const [style, styleClass] = resolveStyles(plot, get(d), get(options), "fill", usedScales());
              return { style, styleClass };
            }),
            "[@const]"
          );
          get(computed_const);
          const computed_const_1 = tag(
            user_derived(() => {
              const { pattern, rect, path: path2 } = get(wafflePoly)(get(d));
              return { pattern, rect, path: path2 };
            }),
            "[@const]"
          );
          get(computed_const_1);
          var g = root_217();
          var pattern_1 = child(g);
          attribute_effect(pattern_1, () => ({ ...get(computed_const_1).pattern }));
          var node_2 = child(pattern_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              {
                let $0 = user_derived(() => ({
                  ...get(computed_const_1).rect,
                  style: get(computed_const).style,
                  styleClass: get(computed_const).styleClass,
                  datum: get(d).datum
                }));
                add_svelte_meta(() => snippet(node_3, () => get(symbol), () => get($0)), "render", WaffleX, 98, 24);
              }
              append($$anchor4, fragment_2);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              {
                var consequent_1 = ($$anchor5) => {
                  var path_1 = root_58();
                  template_effect(
                    ($0) => {
                      set_attribute(path_1, "d", $0);
                      set_style(path_1, get(computed_const).style);
                      set_class(path_1, 0, clsx(get(computed_const).styleClass));
                    },
                    [
                      () => roundedRect(get(computed_const_1).rect.x, get(computed_const_1).rect.y, get(computed_const_1).rect.width, get(computed_const_1).rect.height, get(borderRadius))
                    ]
                  );
                  append($$anchor5, path_1);
                };
                var alternate = ($$anchor5) => {
                  var rect_1 = root_66();
                  attribute_effect(rect_1, () => ({
                    style: get(computed_const).style,
                    class: get(computed_const).styleClass,
                    ...get(computed_const_1).rect
                  }));
                  append($$anchor5, rect_1);
                };
                add_svelte_meta(
                  () => if_block(
                    node_4,
                    ($$render) => {
                      if (get(hasBorderRadius)) $$render(consequent_1);
                      else $$render(alternate, false);
                    },
                    true
                  ),
                  "if",
                  WaffleX,
                  99,
                  20
                );
              }
              append($$anchor4, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (get(symbol)) $$render(consequent);
                else $$render(alternate_1, false);
              }),
              "if",
              WaffleX,
              97,
              20
            );
          }
          reset(pattern_1);
          var path_2 = sibling(pattern_1);
          attribute_effect(path_2, () => ({ ...get(computed_const_1).path }));
          reset(g);
          template_effect(() => set_class(g, 0, clsx(["waffle-x", get(className)])));
          append($$anchor3, g);
        }),
        "each",
        WaffleX,
        82,
        8
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "waffleX",
          requiredScales: { y: ["band"] },
          channels: [
            "x1",
            "x2",
            "y",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      WaffleX,
      75,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  WaffleX = hmr(WaffleX);
  import.meta.hot.accept((module) => {
    WaffleX[HMR].update(module.default);
  });
}
var WaffleX_default = WaffleX;

// node_modules/svelteplot/dist/marks/WaffleY.svelte
WaffleY[FILENAME] = "node_modules/svelteplot/dist/marks/WaffleY.svelte";
var root_59 = add_locations(from_svg(`<path></path>`), WaffleY[FILENAME], [[103, 24]]);
var root_67 = add_locations(from_svg(`<rect></rect>`), WaffleY[FILENAME], [[108, 24]]);
var root_218 = add_locations(from_svg(`<g><pattern><!></pattern><path></path></g>`), WaffleY[FILENAME], [[98, 12, [[99, 16], [111, 16]]]]);
function WaffleY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, WaffleY);
  const DEFAULTS = { ...getPlotDefaults().waffle, ...getPlotDefaults().waffleY };
  let markProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "markProps");
  const $$d = user_derived(() => ({ ...DEFAULTS, ...markProps })), data = tag(user_derived(() => fallback(get($$d).data, () => [{}], true)), "data"), className = tag(user_derived(() => fallback(get($$d).class, null)), "className"), stack = tag(user_derived(() => get($$d).stack), "stack"), symbol = tag(user_derived(() => fallback(get($$d).symbol, null)), "symbol"), options = tag(user_derived(() => exclude_from_object(get($$d), ["data", "class", "stack", "symbol"])), "options");
  const plot = usePlot();
  const args = tag(
    user_derived(() => stackY(
      intervalY(
        // by default, sort by y channel (the ordinal labels)
        sort2(recordizeY({ data: get(data), ...get(options) })),
        { plot }
      ),
      get(stack)
    )),
    "args"
  );
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(WaffleY, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let mark = () => $$arg0?.().mark;
      mark();
      let usedScales = () => $$arg0?.().usedScales;
      usedScales();
      let scaledData = () => $$arg0?.().scaledData;
      scaledData();
      const wafflePoly = tag(user_derived(() => wafflePolygon("y", get(args), plot.scales)), "wafflePoly");
      get(wafflePoly);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => each(node_1, 17, scaledData, index, ($$anchor3, d) => {
          const computed_const = tag(
            user_derived(() => {
              const [style, styleClass] = resolveStyles(plot, get(d), get(args), get(args).stroke && !get(args).fill ? "stroke" : "fill", usedScales());
              return { style, styleClass };
            }),
            "[@const]"
          );
          get(computed_const);
          const borderRadius = tag(user_derived(() => resolveProp(get(args).borderRadius, get(d)?.datum, 0)), "borderRadius");
          get(borderRadius);
          const hasBorderRadius = tag(user_derived(() => strict_equals(typeof get(borderRadius), "number") && get(borderRadius) > 0 || strict_equals(typeof get(borderRadius), "object") && Math.max(get(borderRadius).topRight ?? 0, get(borderRadius).bottomRight ?? 0, get(borderRadius).topLeft ?? 0, get(borderRadius).bottomLeft ?? 0) > 0), "hasBorderRadius");
          get(hasBorderRadius);
          const computed_const_1 = tag(
            user_derived(() => {
              const { pattern, rect, path: path2 } = get(wafflePoly)(get(d));
              return { pattern, rect, path: path2 };
            }),
            "[@const]"
          );
          get(computed_const_1);
          var g = root_218();
          var pattern_1 = child(g);
          attribute_effect(pattern_1, () => ({ ...get(computed_const_1).pattern }));
          var node_2 = child(pattern_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              {
                let $0 = user_derived(() => ({
                  ...get(computed_const_1).rect,
                  style: get(computed_const).style,
                  styleClass: get(computed_const).styleClass,
                  datum: get(d).datum
                }));
                add_svelte_meta(() => snippet(node_3, () => get(symbol), () => get($0)), "render", WaffleY, 101, 24);
              }
              append($$anchor4, fragment_2);
            };
            var alternate_1 = ($$anchor4) => {
              var fragment_3 = comment();
              var node_4 = first_child(fragment_3);
              {
                var consequent_1 = ($$anchor5) => {
                  var path_1 = root_59();
                  template_effect(
                    ($0) => {
                      set_attribute(path_1, "d", $0);
                      set_style(path_1, get(computed_const).style);
                      set_class(path_1, 0, clsx(get(computed_const).styleClass));
                    },
                    [
                      () => roundedRect(get(computed_const_1).rect.x, get(computed_const_1).rect.y, get(computed_const_1).rect.width, get(computed_const_1).rect.height, get(borderRadius))
                    ]
                  );
                  append($$anchor5, path_1);
                };
                var alternate = ($$anchor5) => {
                  var rect_1 = root_67();
                  attribute_effect(rect_1, () => ({
                    style: get(computed_const).style,
                    class: get(computed_const).styleClass,
                    ...get(computed_const_1).rect
                  }));
                  append($$anchor5, rect_1);
                };
                add_svelte_meta(
                  () => if_block(
                    node_4,
                    ($$render) => {
                      if (get(hasBorderRadius)) $$render(consequent_1);
                      else $$render(alternate, false);
                    },
                    true
                  ),
                  "if",
                  WaffleY,
                  102,
                  20
                );
              }
              append($$anchor4, fragment_3);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (get(symbol)) $$render(consequent);
                else $$render(alternate_1, false);
              }),
              "if",
              WaffleY,
              100,
              20
            );
          }
          reset(pattern_1);
          var path_2 = sibling(pattern_1);
          attribute_effect(path_2, () => ({ ...get(computed_const_1).path }));
          reset(g);
          template_effect(() => set_class(g, 0, clsx(["waffle-y", get(className)])));
          append($$anchor3, g);
        }),
        "each",
        WaffleY,
        79,
        8
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => Mark_default(node, spread_props(
        {
          type: "waffleY",
          requiredScales: { x: ["band"] },
          channels: [
            "y1",
            "y2",
            "x",
            "fill",
            "stroke",
            "opacity",
            "fillOpacity",
            "strokeOpacity"
          ]
        },
        () => get(args),
        { children, $$slots: { default: true } }
      )),
      "component",
      WaffleY,
      72,
      0,
      { componentTag: "Mark" }
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  WaffleY = hmr(WaffleY);
  import.meta.hot.accept((module) => {
    WaffleY[HMR].update(module.default);
  });
}
var WaffleY_default = WaffleY;

// node_modules/svelteplot/dist/marks/HTMLTooltip.svelte
HTMLTooltip[FILENAME] = "node_modules/svelteplot/dist/marks/HTMLTooltip.svelte";
var root12 = add_locations(from_html(`<div><!></div>`), HTMLTooltip[FILENAME], [[90, 0]]);
var $$css19 = {
  hash: "s-wykI-uNAaCdg",
  code: "\n    div.svelteplot-tooltip.s-wykI-uNAaCdg {\n        position: absolute;\n        pointer-events: none;\n\n        &.hide {\n            display: none;\n        }\n    }\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSFRNTFRvb2x0aXAuc3ZlbHRlIiwic291cmNlcyI6WyJIVE1MVG9vbHRpcC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLVxuICAgIEBjb21wb25lbnRcbiAgICBGb3Igc2hvd2luZyBjdXN0b20gSFRNTCB0b29sdGlwcyBwb3NpdGlvbmVkIGF0IHgveSBjb29yZGluYXRlc1xuLS0+XG48c2NyaXB0IGxhbmc9XCJ0c1wiIGdlbmVyaWNzPVwiRGF0dW0gPSBEYXRhUm93XCI+XG4gICAgaW50ZXJmYWNlIEhUTUxUb29sdGlwTWFya1Byb3BzIHtcbiAgICAgICAgZGF0YTogRGF0dW1bXTtcbiAgICAgICAgeD86IENoYW5uZWxBY2Nlc3NvcjxEYXR1bT47XG4gICAgICAgIHk/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICByPzogQ2hhbm5lbEFjY2Vzc29yPERhdHVtPjtcbiAgICAgICAgZng/OiBDaGFubmVsQWNjZXNzb3I8RGF0dW0+O1xuICAgICAgICBmeT86IENoYW5uZWxBY2Nlc3NvcjxEYXR1bT47XG4gICAgICAgIGNoaWxkcmVuOiBTbmlwcGV0PFt7IGRhdHVtOiBEYXR1bSB9XT47XG4gICAgfVxuICAgIGltcG9ydCB7IHR5cGUgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgaW1wb3J0IHR5cGUgeyBDaGFubmVsQWNjZXNzb3IsIERhdGFSb3cgfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG4gICAgaW1wb3J0IHsgdXNlUGxvdCB9IGZyb20gJy4uL2hvb2tzL3VzZVBsb3Quc3ZlbHRlLmpzJztcblxuICAgIGltcG9ydCB7IHJlc29sdmVDaGFubmVsIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlLmpzJztcbiAgICBpbXBvcnQgeyBxdWFkdHJlZSB9IGZyb20gJ2QzLXF1YWR0cmVlJztcbiAgICBpbXBvcnQgeyBwcm9qZWN0WCwgcHJvamVjdFkgfSBmcm9tICcuLi9oZWxwZXJzL3NjYWxlcy5qcyc7XG4gICAgaW1wb3J0IHsgZ3JvdXBGYWNldHNBbmRaIH0gZnJvbSAnLi4vaGVscGVycy9ncm91cC5qcyc7XG5cbiAgICBjb25zdCBwbG90ID0gdXNlUGxvdCgpO1xuXG4gICAgbGV0IHsgZGF0YSwgeCwgeSwgciwgZngsIGZ5LCBjaGlsZHJlbiB9OiBIVE1MVG9vbHRpcE1hcmtQcm9wcyA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGRhdHVtID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgdG9vbHRpcFggPSAkc3RhdGUoKTtcbiAgICBsZXQgdG9vbHRpcFkgPSAkc3RhdGUoKTtcblxuICAgIGxldCBmYWNldE9mZnNldFggPSAkc3RhdGUoMCk7XG4gICAgbGV0IGZhY2V0T2Zmc2V0WSA9ICRzdGF0ZSgwKTtcblxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZ0OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHBsb3RSZWN0ID0gcGxvdC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZmFjZXRFbCA9IGV2dC50YXJnZXQgYXMgU1ZHRWxlbWVudDtcbiAgICAgICAgd2hpbGUgKGZhY2V0RWwgJiYgIWZhY2V0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWNldCcpKSB7XG4gICAgICAgICAgICBmYWNldEVsID0gZmFjZXRFbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY2V0SW5kZXggPSArKGZhY2V0RWw/LmRhdGFzZXQ/LmZhY2V0ID8/IDApO1xuICAgICAgICBjb25zdCBmYWNldFJlY3QgPSAoZmFjZXRFbD8uZmlyc3RDaGlsZCA/PyBwbG90LmJvZHkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGZhY2V0T2Zmc2V0WCA9IGZhY2V0UmVjdC5sZWZ0IC0gcGxvdFJlY3QubGVmdCAtIHBsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0O1xuICAgICAgICBmYWNldE9mZnNldFkgPSBmYWNldFJlY3QudG9wIC0gcGxvdFJlY3QudG9wIC0gcGxvdC5vcHRpb25zLm1hcmdpblRvcDtcblxuICAgICAgICBjb25zdCByZWxhdGl2ZVggPSBldnQuY2xpZW50WCAtIGZhY2V0UmVjdC5sZWZ0ICsgKHBsb3Qub3B0aW9ucy5tYXJnaW5MZWZ0ID8/IDApO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVkgPSBldnQuY2xpZW50WSAtIGZhY2V0UmVjdC50b3AgKyAocGxvdC5vcHRpb25zLm1hcmdpblRvcCA/PyAwKTtcblxuICAgICAgICBjb25zdCBwdCA9IHRyZWVzW2ZhY2V0SW5kZXhdLmZpbmQocmVsYXRpdmVYLCByZWxhdGl2ZVksIDI1KTtcbiAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICB0b29sdGlwWCA9IHJlc29sdmVDaGFubmVsKCd4JywgcHQsIHsgeCwgeSwgciB9KTtcbiAgICAgICAgICAgIHRvb2x0aXBZID0gcmVzb2x2ZUNoYW5uZWwoJ3knLCBwdCwgeyB4LCB5LCByIH0pO1xuICAgICAgICAgICAgZGF0dW0gPSBwdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdHVtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJMZWF2ZSgpIHtcbiAgICAgICAgZGF0dW0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGxvdC5ib2R5Py5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybGVhdmUnLCBvblBvaW50ZXJMZWF2ZSk7XG4gICAgICAgIHBsb3QuYm9keT8uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcGxvdC5ib2R5Py5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25Qb2ludGVyTGVhdmUpO1xuICAgICAgICAgICAgcGxvdC5ib2R5Py5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZ3JvdXBzID0gJGRlcml2ZWQuYnkoKCkgPT4ge1xuICAgICAgICBjb25zdCBncm91cHM6IERhdHVtW11bXSA9IFtdO1xuICAgICAgICBncm91cEZhY2V0c0FuZFooZGF0YSwgeyBmeCwgZnkgfSwgKGQpID0+IGdyb3Vwcy5wdXNoKGQpKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9KTtcblxuICAgIGNvbnN0IHRyZWVzID0gJGRlcml2ZWQoXG4gICAgICAgIGdyb3Vwcy5tYXAoKGl0ZW1zKSA9PlxuICAgICAgICAgICAgcXVhZHRyZWUoKVxuICAgICAgICAgICAgICAgIC54KChkKSA9PiBwcm9qZWN0WCgneCcsIHBsb3Quc2NhbGVzLCByZXNvbHZlQ2hhbm5lbCgneCcsIGQsIHsgeCwgeSwgciB9KSkpXG4gICAgICAgICAgICAgICAgLnkoKGQpID0+IHByb2plY3RZKCd5JywgcGxvdC5zY2FsZXMsIHJlc29sdmVDaGFubmVsKCd5JywgZCwgeyB4LCB5LCByIH0pKSlcbiAgICAgICAgICAgICAgICAuYWRkQWxsKGl0ZW1zKVxuICAgICAgICApXG4gICAgKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9e1snc3ZlbHRlcGxvdC10b29sdGlwJywgeyBoaWRlOiAhZGF0dW0gfV19XG4gICAgc3R5bGU6bGVmdD1cInt0b29sdGlwWCA/IGZhY2V0T2Zmc2V0WCArIHByb2plY3RYKCd4JywgcGxvdC5zY2FsZXMsIHRvb2x0aXBYKSA6IDB9cHhcIlxuICAgIHN0eWxlOnRvcD1cInt0b29sdGlwWSA/IGZhY2V0T2Zmc2V0WSArIHByb2plY3RZKCd5JywgcGxvdC5zY2FsZXMsIHRvb2x0aXBZKSA6IDB9cHhcIj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbih7IGRhdHVtIH0pfVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICBkaXYuc3ZlbHRlcGxvdC10b29sdGlwIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgICAgICAmLmhpZGUge1xuICAgICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function HTMLTooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, HTMLTooltip);
  append_styles($$anchor, $$css19);
  const plot = usePlot();
  let datum = tag(state(false), "datum");
  let tooltipX = tag(state(void 0), "tooltipX");
  let tooltipY = tag(state(void 0), "tooltipY");
  let facetOffsetX = tag(state(0), "facetOffsetX");
  let facetOffsetY = tag(state(0), "facetOffsetY");
  function onPointerMove(evt) {
    const plotRect = plot.body.getBoundingClientRect();
    let facetEl = evt.target;
    while (facetEl && !facetEl.classList.contains("facet")) {
      facetEl = facetEl.parentElement;
    }
    const facetIndex = +(facetEl?.dataset?.facet ?? 0);
    const facetRect = (facetEl?.firstChild ?? plot.body).getBoundingClientRect();
    set(facetOffsetX, facetRect.left - plotRect.left - plot.options.marginLeft);
    set(facetOffsetY, facetRect.top - plotRect.top - plot.options.marginTop);
    const relativeX = evt.clientX - facetRect.left + (plot.options.marginLeft ?? 0);
    const relativeY = evt.clientY - facetRect.top + (plot.options.marginTop ?? 0);
    const pt = get(trees)[facetIndex].find(relativeX, relativeY, 25);
    if (pt) {
      set(tooltipX, resolveChannel("x", pt, { x: $$props.x, y: $$props.y, r: $$props.r }), true);
      set(tooltipY, resolveChannel("y", pt, { x: $$props.x, y: $$props.y, r: $$props.r }), true);
      set(datum, pt, true);
    } else {
      set(datum, false);
    }
  }
  function onPointerLeave() {
    set(datum, false);
  }
  user_effect(() => {
    plot.body?.addEventListener("pointerleave", onPointerLeave);
    plot.body?.addEventListener("pointermove", onPointerMove);
    return () => {
      plot.body?.removeEventListener("mouseleave", onPointerLeave);
      plot.body?.removeEventListener("pointermove", onPointerMove);
    };
  });
  const groups2 = tag(
    user_derived(() => {
      const groups3 = [];
      groupFacetsAndZ($$props.data, { fx: $$props.fx, fy: $$props.fy }, (d) => groups3.push(d));
      return groups3;
    }),
    "groups"
  );
  const trees = tag(user_derived(() => get(groups2).map((items) => quadtree().x((d) => projectX("x", plot.scales, resolveChannel("x", d, { x: $$props.x, y: $$props.y, r: $$props.r }))).y((d) => projectY("y", plot.scales, resolveChannel("y", d, { x: $$props.x, y: $$props.y, r: $$props.r }))).addAll(items))), "trees");
  var $$exports = { ...legacy_api() };
  var div = root12();
  let styles;
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children, () => ({ datum: get(datum) })), "render", HTMLTooltip, 94, 4);
  reset(div);
  template_effect(
    ($0) => {
      set_class(div, 1, clsx(["svelteplot-tooltip", { hide: !get(datum) }]), "s-wykI-uNAaCdg");
      styles = set_style(div, "", styles, $0);
    },
    [
      () => ({
        left: `${get(tooltipX) ? get(facetOffsetX) + projectX("x", plot.scales, get(tooltipX)) : 0}px`,
        top: `${get(tooltipY) ? get(facetOffsetY) + projectY("y", plot.scales, get(tooltipY)) : 0}px`
      })
    ]
  );
  append($$anchor, div);
  return pop($$exports);
}
if (import.meta.hot) {
  HTMLTooltip = hmr(HTMLTooltip);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-wykI-uNAaCdg");
    HTMLTooltip[HMR].update(module.default);
  });
}
var HTMLTooltip_default = HTMLTooltip;

// node_modules/svelteplot/dist/marks/helpers/LinearGradientX.svelte
LinearGradientX[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/LinearGradientX.svelte";
var root_127 = add_locations(from_svg(`<stop></stop>`), LinearGradientX[FILENAME], [[24, 8]]);
var root13 = add_locations(from_svg(`<linearGradient gradientUnits="userSpaceOnUse"></linearGradient>`), LinearGradientX[FILENAME], [[22, 0]]);
function LinearGradientX($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinearGradientX);
  const plot = usePlot();
  const projectedStops = tag(user_derived(() => $$props.stops.map((d) => ({ ...d, px: plot.scales.x.fn(d.x) / plot.width })).sort((a2, b) => a2.px - b.px)), "projectedStops");
  var $$exports = { ...legacy_api() };
  var linearGradient = root13();
  set_attribute(linearGradient, "x1", 0);
  set_attribute(linearGradient, "y2", 0);
  set_attribute(linearGradient, "y1", 0);
  add_svelte_meta(
    () => each(linearGradient, 21, () => get(projectedStops), index, ($$anchor2, $$item) => {
      let px = () => get($$item).px;
      px();
      let color2 = () => get($$item).color;
      color2();
      var stop = root_127();
      template_effect(() => {
        set_attribute(stop, "stop-color", color2());
        set_attribute(stop, "offset", px());
      });
      append($$anchor2, stop);
    }),
    "each",
    LinearGradientX,
    23,
    4
  );
  reset(linearGradient);
  template_effect(() => {
    set_attribute(linearGradient, "id", $$props.id);
    set_attribute(linearGradient, "x2", plot.width);
  });
  append($$anchor, linearGradient);
  return pop($$exports);
}
if (import.meta.hot) {
  LinearGradientX = hmr(LinearGradientX);
  import.meta.hot.accept((module) => {
    LinearGradientX[HMR].update(module.default);
  });
}
var LinearGradientX_default = LinearGradientX;

// node_modules/svelteplot/dist/marks/helpers/LinearGradientY.svelte
LinearGradientY[FILENAME] = "node_modules/svelteplot/dist/marks/helpers/LinearGradientY.svelte";
var root_128 = add_locations(from_svg(`<stop></stop>`), LinearGradientY[FILENAME], [[24, 8]]);
var root14 = add_locations(from_svg(`<linearGradient gradientUnits="userSpaceOnUse"></linearGradient>`), LinearGradientY[FILENAME], [[22, 0]]);
function LinearGradientY($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinearGradientY);
  const plot = usePlot();
  const projectedStops = tag(user_derived(() => $$props.stops.map((d) => ({ ...d, py: plot.scales.y.fn(d.y) / plot.height })).sort((a2, b) => a2.py - b.py)), "projectedStops");
  var $$exports = { ...legacy_api() };
  var linearGradient = root14();
  set_attribute(linearGradient, "x1", 0);
  set_attribute(linearGradient, "x2", 0);
  set_attribute(linearGradient, "y1", 0);
  add_svelte_meta(
    () => each(linearGradient, 21, () => get(projectedStops), index, ($$anchor2, $$item) => {
      let py = () => get($$item).py;
      py();
      let color2 = () => get($$item).color;
      color2();
      var stop = root_128();
      template_effect(() => {
        set_attribute(stop, "stop-color", color2());
        set_attribute(stop, "offset", py());
      });
      append($$anchor2, stop);
    }),
    "each",
    LinearGradientY,
    23,
    4
  );
  reset(linearGradient);
  template_effect(() => {
    set_attribute(linearGradient, "id", $$props.id);
    set_attribute(linearGradient, "y2", plot.height);
  });
  append($$anchor, linearGradient);
  return pop($$exports);
}
if (import.meta.hot) {
  LinearGradientY = hmr(LinearGradientY);
  import.meta.hot.accept((module) => {
    LinearGradientY[HMR].update(module.default);
  });
}
var LinearGradientY_default = LinearGradientY;

// node_modules/svelteplot/dist/helpers/formats.js
function formatMonth(locale3, format2 = "long") {
  return (month) => new Intl.DateTimeFormat(locale3, { month: format2 }).format(new Date(2e3, month, 1));
}
export {
  Area_default as Area,
  AreaX_default as AreaX,
  AreaY_default as AreaY,
  Arrow_default as Arrow,
  AxisX_default as AxisX,
  AxisY_default as AxisY,
  BarX_default as BarX,
  BarY_default as BarY,
  BollingerX_default as BollingerX,
  BollingerY_default as BollingerY,
  BoxX_default as BoxX,
  BoxY_default as BoxY,
  Brush_default as Brush,
  BrushX_default as BrushX,
  BrushY_default as BrushY,
  Cell_default as Cell,
  CellX_default as CellX,
  CellY_default as CellY,
  ColorLegend_default as ColorLegend,
  CustomMark_default as CustomMark,
  CustomMarkHTML_default as CustomMarkHTML,
  DifferenceY_default as DifferenceY,
  Dot_default as Dot,
  DotX_default as DotX,
  DotY_default as DotY,
  Frame_default as Frame,
  Geo_default as Geo,
  Graticule_default as Graticule,
  GridX_default as GridX,
  GridY_default as GridY,
  HTMLTooltip_default as HTMLTooltip,
  Image_default as Image,
  Line_default as Line,
  LineX_default as LineX,
  LineY_default as LineY,
  LinearGradientX_default as LinearGradientX,
  LinearGradientY_default as LinearGradientY,
  Link_default as Link,
  Plot_default2 as Plot,
  Plot_default as PlotCore,
  Pointer_default as Pointer,
  Rect_default as Rect,
  RectX_default as RectX,
  RectY_default as RectY,
  RegressionX_default as RegressionX,
  RegressionY_default as RegressionY,
  RuleX_default as RuleX,
  RuleY_default as RuleY,
  Sphere_default as Sphere,
  Spike_default as Spike,
  SymbolLegend_default as SymbolLegend,
  Text_default as Text,
  TickX_default as TickX,
  TickY_default as TickY,
  Trail_default as Trail,
  Vector_default as Vector,
  WaffleX_default as WaffleX,
  WaffleY_default as WaffleY,
  bin2 as bin,
  binX,
  binY,
  bollingerX,
  bollingerY,
  densityX,
  densityY,
  filter2 as filter,
  formatMonth,
  geoCentroid,
  getPlotDefaults,
  group2 as group,
  groupX,
  groupY,
  groupZ,
  intervalX,
  intervalY,
  jitter,
  jitterX,
  jitterY,
  map4 as map,
  mapX,
  mapY,
  normalizeParallelX,
  normalizeParallelY,
  normalizeX,
  normalizeY,
  recordizeX,
  recordizeY,
  renameChannels,
  replaceChannels,
  reverse2 as reverse,
  select,
  selectFirst,
  selectLast,
  selectMaxX,
  selectMaxY,
  selectMinX,
  selectMinY,
  setPlotDefaults,
  shiftX,
  shiftY,
  shuffle,
  sort2 as sort,
  stackMosaicX,
  stackMosaicY,
  stackX,
  stackY,
  usePlot,
  windowX,
  windowY,
  wordwrap
};
//# sourceMappingURL=svelteplot.js.map
