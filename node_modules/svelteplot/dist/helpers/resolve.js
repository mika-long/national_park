import { CHANNEL_SCALE, INDEX } from '../constants.js';
import isDataRecord from './isDataRecord.js';
import isRawValue from './isRawValue.js';
import { isValid } from './index.js';
import { getBaseStylesObject } from './getBaseStyles.js';
import { RAW_VALUE } from '../transforms/recordize.js';
export function resolveProp(accessor, datum, _defaultValue = null) {
    if (typeof accessor === 'function') {
        const accessorFn = accessor;
        // datum[RAW_VALUE] exists if an array of raw values was used as dataset and got
        // "recordized" by the recordi e transform. We want to hide this wrapping to the user
        // so we're passing the original value to accessor functions instead of our wrapped record
        return datum == null
            ? accessorFn()
            : accessorFn(datum.hasOwnProperty(RAW_VALUE) ? datum[RAW_VALUE] : datum, datum[INDEX]);
    }
    else {
        const accessorValue = accessor;
        // accessor may be a
        if ((typeof accessorValue === 'string' || typeof accessorValue === 'symbol') &&
            datum &&
            datum[accessorValue] !== undefined) {
            return datum[accessor];
        }
    }
    return isRawValue(accessor) ? accessor : _defaultValue;
}
export function toChannelOption(name, channel) {
    const isPositionScale = CHANNEL_SCALE[name] === 'x' || CHANNEL_SCALE[name] === 'y';
    const isOpacityScale = CHANNEL_SCALE[name] === 'opacity';
    return isDataRecord(channel)
        ? channel
        : {
            value: channel,
            scale: (!isPositionScale && !isOpacityScale && typeof channel === 'number') ||
                typeof channel === 'undefined'
                ? null
                : CHANNEL_SCALE[name],
            channel: null
        };
}
export function resolveChannel(channel, datum, channels) {
    const scale = CHANNEL_SCALE[channel];
    // the z channel has an automatic alias mechanism
    const accessor = channel === 'z' ? channels.z || channels.fill || channels.stroke : channels[channel];
    const channelOptions = toChannelOption(channel, accessor);
    if (channelOptions.channel) {
        return resolveChannel(channelOptions.channel, datum, channels);
    }
    return resolve(datum, channelOptions.value, channel, scale);
}
function resolve(datum, accessor, channel, scale) {
    if (isDataRecord(datum)) {
        // use accessor function
        if (typeof accessor === 'function')
            // datum[RAW_VALUE] exists if an array of raw values was used as dataset and got
            // "recordized" by the recordize transform. We want to hide this wrapping to the user
            // so we're passing the original value to accessor functions instead of our wrapped record
            return accessor(datum[RAW_VALUE] != null ? datum[RAW_VALUE] : datum, datum?.[INDEX]);
        // use accessor string
        if ((typeof accessor === 'string' || typeof accessor === 'symbol') &&
            datum[accessor] !== undefined)
            return datum[accessor];
        // fallback to channel name as accessor
        if (accessor === null && datum[channel] !== undefined)
            return datum[channel];
        return isRawValue(accessor) ? accessor : null;
    }
    else if (Array.isArray(datum) &&
        (typeof accessor === 'string' || typeof accessor === 'number') &&
        datum[accessor] != null) {
        return datum[accessor];
    }
    else {
        // return single value or accessor
        return typeof accessor === 'function'
            ? accessor(datum, datum?.[INDEX])
            : accessor !== null && isRawValue(accessor)
                ? accessor
                : !Array.isArray(datum) && (scale === 'x' || scale === 'y')
                    ? datum
                    : null;
    }
}
const scaledStyleProps = {
    fill: 'fill',
    stroke: 'stroke',
    fillOpacity: 'fill-opacity',
    strokeOpacity: 'stroke-opacity',
    opacity: 'opacity'
};
const scaledStylePropsKeys = Object.keys(scaledStyleProps);
// TODO: find a better name
const oppositeColor = {
    fill: 'stroke',
    stroke: 'fill'
};
export function resolveScaledStyleProps(datum, channels, useScale, plot, defaultColorProp = null) {
    return {
        ...getBaseStylesObject(datum, channels),
        fill: 'none',
        stroke: 'none',
        ...(defaultColorProp && channels[oppositeColor[defaultColorProp]] == null
            ? { [defaultColorProp]: 'currentColor' }
            : {}),
        ...Object.fromEntries(Object.entries(scaledStyleProps)
            .filter(([key]) => channels[key] != null)
            .map(([key, cssAttr]) => [key, cssAttr, resolveChannel(key, datum, channels)])
            .filter(([key, , value]) => isValid(value) || key === 'fill' || key === 'stroke')
            .map(([key, cssAttr, value]) => {
            if (useScale[key]) {
                if (value == undefined &&
                    (key === 'fill' || key === 'stroke') &&
                    plot.options.color.unknown) {
                    return [cssAttr, plot.options.color.unknown];
                }
                return [cssAttr, plot.scales[CHANNEL_SCALE[key]].fn(value)];
            }
            return [cssAttr, value];
        }))
    };
}
export function resolveScaledStyles(datum, channels, useScale, plot, defaultColorProp = null) {
    return `${stylePropsToCSS(resolveScaledStyleProps(datum, channels, useScale, plot, defaultColorProp))};${channels.style || ''}`;
}
function stylePropsToCSS(props) {
    return `${Object.entries(props)
        .map(([key, value]) => `${key}: ${value}`)
        .join(';')}`;
}
export function resolveStyles(plot, datum, channels, defaultColorProp = null, useScale, recomputeChannels = false) {
    const styleProps = {
        ...getBaseStylesObject(datum?.datum, channels),
        fill: 'none',
        stroke: 'none',
        ...(defaultColorProp &&
            (channels[oppositeColor[defaultColorProp]] == null ||
                channels[oppositeColor[defaultColorProp]] === 'none')
            ? { [defaultColorProp]: 'currentColor' }
            : {}),
        ...Object.fromEntries(Object.entries(scaledStyleProps)
            .filter(([key]) => channels[key] != null)
            .map(([key, cssAttr]) => [
            key,
            cssAttr,
            recomputeChannels ? resolveChannel(key, datum?.datum, channels) : datum?.[key]
        ])
            .filter(([key, , value]) => isValid(value) || key === 'fill' || key === 'stroke')
            .map(([key, cssAttr, value]) => {
            if (useScale[key]) {
                if (value == undefined &&
                    (key === 'fill' || key === 'stroke') &&
                    plot.options.color.unknown) {
                    return [cssAttr, plot.options.color.unknown];
                }
            }
            else if ((key === 'fill' || key === 'stroke') && value === true) {
                return [cssAttr, 'currentColor'];
            }
            return [cssAttr, value];
        }))
    };
    if (plot.css) {
        return [null, plot.css(`${stylePropsToCSS(styleProps)};${channels.style ?? ''}`)];
    }
    else {
        return [`${stylePropsToCSS(styleProps)};${channels.style ?? ''}`, null];
    }
}
