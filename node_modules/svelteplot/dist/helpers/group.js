import { resolveChannel } from './resolve.js';
import { groups as d3Groups } from 'd3-array';
/**
 * Groups the data by the fx, fy and z channels and calls the reduce function
 * for each group. Returns the new channels to be added in the transform.
 */
export function groupFacetsAndZ(items, channels, reduce) {
    const groupBy = ['fx', 'fy', 'z'].map((groupChannel) => {
        let groupByChannel = null;
        if (groupChannel === 'z') {
            if (channels.z)
                groupByChannel = 'z';
            else if (channels.fill)
                groupByChannel = 'fill';
            else if (channels.stroke)
                groupByChannel = 'stroke';
        }
        else if (channels[groupChannel]) {
            groupByChannel = groupChannel;
        }
        if (groupByChannel) {
            const groupByPropName = typeof channels[groupByChannel] === 'string'
                ? channels[groupByChannel]
                : `__group_${groupByChannel}`;
            return [
                groupByChannel,
                groupByPropName,
                (d) => resolveChannel(groupByChannel, d, channels)
            ];
        }
        else {
            return [null, null, () => true];
        }
    });
    const groups = d3Groups(items, ...groupBy.map((d) => d[2]));
    for (const [fxKey, fxGroups] of groups) {
        const newItemGroupProps = {};
        if (groupBy[0][0] !== null && groupBy[0][1])
            newItemGroupProps[groupBy[0][1]] = fxKey;
        for (const [fyKey, fyGroups] of fxGroups) {
            if (groupBy[1][0] !== null && groupBy[1][1])
                newItemGroupProps[groupBy[1][1]] = fyKey;
            for (const [zKey, zGroups] of fyGroups) {
                if (groupBy[2][0] !== null && groupBy[2][1])
                    newItemGroupProps[groupBy[2][1]] = zKey;
                reduce(zGroups, newItemGroupProps);
            }
        }
    }
    // return the new channel accessors to be added in the transform
    return Object.fromEntries(groupBy
        .filter(([groupByChannel]) => groupByChannel !== null)
        .map(([groupByChannel, groupByProp]) => [groupByChannel, groupByProp]));
}
