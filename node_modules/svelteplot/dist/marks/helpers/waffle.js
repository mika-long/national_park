/**
 * This implementation is based on the waffle chart implementation in Observable Plot!
 * https://github.com/observablehq/plot/blob/main/src/marks/waffle.js
 *
 * Kept the comments from the original implementation for clarity.
 */
import { getPatternId } from '../../helpers/getBaseStyles';
export function wafflePolygon(y, options, scales) {
    const x = y === 'y' ? 'x' : 'y';
    const y1 = `${y}1`;
    const y2 = `${y}2`;
    const xScale = scales[x];
    const yScale = scales[y];
    const barwidth = xScale.fn.bandwidth();
    const { unit = 1, gap = 1 } = options;
    const round = maybeRound(options.round);
    // The length of a unit along y in pixels.
    const scale = Math.abs(yScale.fn(unit) - yScale.fn(0));
    // The number of cells on each row (or column) of the waffle.
    const multiple = options.multiple ?? Math.max(1, Math.floor(Math.sqrt(barwidth / scale)));
    // The outer size of each square cell, in pixels, including the gap.
    const cx = Math.min(barwidth / multiple, scale * multiple);
    const cy = scale * multiple;
    // The reference position.
    const tx = (barwidth - multiple * cx) / 2;
    const transform = y === 'y' ? ([x, y]) => [x * cx, -y * cy] : ([x, y]) => [y * cy, x * cx];
    // const mx = typeof x0 === 'function' ? (i) => x0(i) - barwidth / 2 : () => x0;
    const [ix, iy] = y === 'y' ? [0, 1] : [1, 0];
    const y0 = yScale.fn(0);
    const mx = -barwidth / 2;
    return (d) => {
        const y1val = d.resolved[y1];
        const y2val = d.resolved[y2];
        const P = wafflePoints(round(y1val / unit), round(y2val / unit), multiple).map(transform);
        P.pop();
        const id = getPatternId();
        const pos = [d[x] + tx + mx, y0];
        return {
            pattern: {
                id,
                patternUnits: 'userSpaceOnUse',
                width: cx,
                height: cy
            },
            rect: {
                x: gap / 2,
                y: gap / 2,
                width: cx - gap,
                height: cy - gap
            },
            path: {
                fill: `url(#${id})`,
                transform: `translate(${pos[ix]},${pos[iy]})`,
                d: `M${P.join('L')}Z`
            }
        };
        // return `M${P.join('L')}Z`;
    };
    // const points = wafflePoints(i1, i2, columns);
    // return dimension === 'x' ? points : points.map(([x, y]: Point): Point => [y, x]);
}
export function wafflePoints(i1, i2, columns) {
    if (i2 < i1)
        return wafflePoints(i2, i1, columns); // ensure i1 <= i2
    if (i1 < 0)
        return wafflePointsOffset(i1, i2, columns, Math.ceil(-Math.min(i1, i2) / columns)); // ensure i1 >= 0
    const x1f = Math.floor(i1 % columns);
    const x1c = Math.ceil(i1 % columns);
    const x2f = Math.floor(i2 % columns);
    const x2c = Math.ceil(i2 % columns);
    const y1f = Math.floor(i1 / columns);
    const y1c = Math.ceil(i1 / columns);
    const y2f = Math.floor(i2 / columns);
    const y2c = Math.ceil(i2 / columns);
    const points = [];
    if (y2c > y1c)
        points.push([0, y1c]);
    points.push([x1f, y1c], [x1f, y1f + (i1 % 1)], [x1c, y1f + (i1 % 1)]);
    if (!(i1 % columns > columns - 1)) {
        points.push([x1c, y1f]);
        if (y2f > y1f)
            points.push([columns, y1f]);
    }
    if (y2f > y1f)
        points.push([columns, y2f]);
    points.push([x2c, y2f], [x2c, y2f + (i2 % 1)], [x2f, y2f + (i2 % 1)]);
    if (!(i2 % columns < 1)) {
        points.push([x2f, y2c]);
        if (y2c > y1c)
            points.push([0, y2c]);
    }
    points.push(waffleCentroid(i1, i2, columns));
    return points;
}
/**
 * Compute waffle points when indices start in negative rows by applying a row offset.
 * - Shifts both indices down by `k` rows (adding `k * columns`) so they are non-negative,
 *   delegates to `wafflePoints`, then translates the resulting points back up by `k` on y.
 * - `k` is the number of rows of vertical offset applied.
 */
function wafflePointsOffset(i1, i2, columns, k) {
    return wafflePoints(i1 + k * columns, i2 + k * columns, columns).map(([x, y]) => [x, y - k]);
}
/**
 * Centroid of the waffle region representing the interval [i1, i2).
 * Chooses a strategy based on how many rows the interval spans:
 * - Single row: delegate to `waffleRowCentroid`.
 * - Two rows: if the projected columns overlap, return the midpoint of the overlap;
 *   otherwise, return the centroid of the larger partial row.
 * - >= 3 rows: return the center column and halfway between the middle rows.
 */
function waffleCentroid(i1, i2, columns) {
    const r = Math.floor(i2 / columns) - Math.floor(i1 / columns);
    return r === 0
        ? // Single row
            waffleRowCentroid(i1, i2, columns)
        : r === 1
            ? // Two incomplete rows; use the midpoint of their overlap if any, otherwise the larger row
                Math.floor(i2 % columns) > Math.ceil(i1 % columns)
                    ? [(Math.floor(i2 % columns) + Math.ceil(i1 % columns)) / 2, Math.floor(i2 / columns)]
                    : i2 % columns > columns - (i1 % columns)
                        ? waffleRowCentroid(i2 - (i2 % columns), i2, columns)
                        : waffleRowCentroid(i1, columns * Math.ceil(i1 / columns), columns)
            : // At least one full row; take the midpoint of all the rows that include the middle
                [columns / 2, (Math.round(i1 / columns) + Math.round(i2 / columns)) / 2];
}
/**
 * Centroid of a waffle segment constrained to a single row.
 * Cases:
 * - c === 0: both endpoints fall into the same cell; center on x, average fractional y.
 * - c === 1: two adjacent partial cells; use the overlap center if > 0.5 cell,
 *   otherwise the center of the larger partial cell.
 * - c >= 2: at least one full cell between; x is the midpoint of full cells,
 *   y is the row center (0.5) if thereâ€™s a full cell spanned, otherwise average fractional y.
 */
function waffleRowCentroid(i1, i2, columns) {
    const c = Math.floor(i2) - Math.floor(i1);
    return c === 0
        ? // Single cell
            [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (((i1 + i2) / 2) % 1)]
        : c === 1
            ? // Two incomplete cells; use the overlap if large enough, otherwise use the largest
                (i2 % 1) - (i1 % 1) > 0.5
                    ? [Math.ceil(i1 % columns), Math.floor(i2 / columns) + ((i1 % 1) + (i2 % 1)) / 2]
                    : i2 % 1 > 1 - (i1 % 1)
                        ? [Math.floor(i2 % columns) + 0.5, Math.floor(i2 / columns) + (i2 % 1) / 2]
                        : [Math.floor(i1 % columns) + 0.5, Math.floor(i1 / columns) + (1 + (i1 % 1)) / 2]
            : // At least one full cell; take the midpoint
                [
                    Math.ceil(i1 % columns) + Math.ceil(Math.floor(i2) - Math.ceil(i1)) / 2,
                    Math.floor(i1 / columns) + (i2 >= 1 + i1 ? 0.5 : ((i1 + i2) / 2) % 1)
                ];
}
export function maybeRound(round) {
    if (round === undefined || round === false)
        return Number;
    if (round === true)
        return Math.round;
    if (typeof round !== 'function')
        throw new Error(`invalid round: ${round}`);
    return round;
}
