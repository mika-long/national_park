/**
 * implementation based on science.js by Jason Davies
 */
import type { TransformArg } from '../types';
type Kernel = 'uniform' | 'triangular' | 'epanechnikov' | 'quartic' | 'triweight' | 'gaussian' | 'cosine' | ((u: number) => number);
type DensityOptions<T> = {
    /**
     * The kernel function to use for smoothing.
     */
    kernel?: Kernel;
    /**
     * The bandwidth to use for smoothing. Can be a fixed number or a function that computes the bandwidth based on the data.
     */
    bandwidth?: number | ((data: number[]) => number);
    /**
     * If an interval is provided, the smoothing will be computed over that interval instead of the raw data points.
     */
    interval?: number | string;
    /**
     * If true, the density values will be trimmed to the range of the data.
     */
    trim?: boolean;
    /**
     * If true, the density values will be cumulative.
     */
    cumulative?: false | 1 | -1;
};
/**
 * One-dimensional kernel density estimation
 */
export declare function densityX<T>(args: TransformArg<T>, options: DensityOptions<T> & {
    channel?: 'y' | 'y1' | 'y2';
}): TransformArg<T>;
/**
 * One-dimensional kernel density estimation
 */
export declare function densityY<T>(args: TransformArg<T>, options: DensityOptions<T> & {
    channel?: 'x' | 'x1' | 'x2';
}): TransformArg<T>;
export {};
